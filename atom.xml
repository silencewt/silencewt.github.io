<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silence 婷婷 Blog]]></title>
  <subtitle><![CDATA[既然选择远方，便风雨兼程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://silencewt.github.io/"/>
  <updated>2014-12-28T02:29:31.679Z</updated>
  <id>http://silencewt.github.io/</id>
  
  <author>
    <name><![CDATA[Wangt]]></name>
    <email><![CDATA[wangt_hust@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2014年年度总结]]></title>
    <link href="http://silencewt.github.io/2014/12/28/2014%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://silencewt.github.io/2014/12/28/2014年年度总结/</id>
    <published>2014-12-28T02:26:08.000Z</published>
    <updated>2014-12-28T02:29:08.000Z</updated>
    <content type="html"><![CDATA[<p>　　好好回顾了下，这一年自己走过的时光，发现很多事情真的不是自己可以计划和安排的，犹记去年的这个时候是怎样的告诉自己不能浪费时光，要好好对待自己，也给自己设定了目标，也有一部分达成了，一部分终归是不了了之了。到了年底，没想到这一年的时间就这样了没了，回顾过去，<strong>只为更好的前进，成为更好的自己</strong>。</p>
<p>　　2014年收获了很多，也失去了很多，感概最多就是没有好好的使用时间，但是，每次回过头来看，都会觉得这一段路走的很有必要，没有经历过这些，怎么会知道自己要的是什么，怎么会感受到自己的成长，也许，这就是人们常说的，成长的所失与所得。虽然这段日子没有什么惊天动地的大事件，但是确确实实给了我很多的东西，不仅仅是学习也是做人。2014基本可以分为几个阶段性报告。</p>
<h3 id="学习">学习</h3>
<p>1、1-4月属于真真正正的迷茫期。一月忙于各种研究生结业考试，天天呆在图书馆，除了考试不知道自己还能那忙什么，去实验室的时间就是休息娱乐。当然，这段时间也过得很充实，达到了我要的目标，成绩优秀，这样的日子在10月份的时候出了成绩，轻松拿得国奖，学生的最高奖项。</p>
<p>2、寒假回家，除了和家人愉快的玩耍之外，也静下心来想了想之后的生涯该怎么过，没有结果但是紧迫感越来越大，提早来了实验室。从放假回来到三月，一直在思考，该怎么度过剩下的时间，该怎么才能提升自我竞争力？我可以做什么？我想做什么？未来的职业是什么？这几个问题一直就这样困扰着我。导师方向的更改造成我很大的压力，这不是我喜欢的。实验室的压力和责任也很大，不能任性的扔下实验室的事情不管，但有不能放弃找工作的目的。就是这么纠结的过了一两个月。白天，看论文，学图像处理，看opencv，学机器学习，了解这方面的各种信息和资料；晚上，接触前端，接触互联网，学写网站。虽然会被各种杂事打断但基本就是这个节奏。</p>
<p>3、这两个月内，纠结归纠结，期间自己设定的目标还是有完成一点的。这段时间，让我真正的踏入<strong>图像处理和机器学习</strong>的大门，自学了图像检测，目标识别这个领域的知识。回过头来看，原来这些都很简单，量的积累确实换来了质的飞跃。我所谓的简单，只是局限于现有简单算法的实现和理解。优化以及实际应用这又是一个大的世界。</p>
<p>4、还踏入了互联网领域，通过各种渠道的信息，通过师姐，通过不断的关注最新互联网信息，开启联通外面世界之路。对于<strong>构建网站，博客，页面交互，前端</strong>等等有了认识，接触了html，css，js，nodejs，mongodb，bootstrap，github，trello各种有趣的东西。学习这些的过程中，让我知道如何作用好网络找到自己想要的东西，如何查看官方文档，如何解决问题，不敢说每个都学的很深，不敢说都精通，但基本的我都知道。个人觉得重要的不是你学会了哪门技术，重要的是<strong>学会了怎么解决和处理问题，怎么寻求帮助，怎么思考，这个过程带给我的体会及自我进化才是慢珍贵的。</strong></p>
<p>5、在经过一段时间的挣扎，在听过阿里测试大讲坛之后，我坚定了要做测试这个行业的心，于是从5月开始就利用课余的时间重新将测试的东西捡起来，慢慢的深入到测试的领域，收集信息，找到自己想做的方向，web测试，由于自己对互联网很有的热情，鉴于之前接触了前端的知识，这一块能很快的上手，理解很快。这个期间，有尝试着去找实习，但是每次都被实验室的事情压着，没有办法顺利的离开，最后只能放弃。学习python，跟本科同学，尝试django建立一个网站，类似于博客收集信息的，界面基本上是copy某个网站的，只是内容和逻辑是自己的。</p>
<p>6、暑假回来后，对微信订阅号知道了怎么有效的利用了，重点关注了几个有效的订阅号，每天通过其了解最新的消息。坚持了2-3个月后，发现自己了解到的领域多了，知识面广了，和他人聊天的时候，什么话题都能聊下去，周围的人都说，我怎么知道这么多的。<strong>寻找消息的渠道，增长见识。</strong></p>
<p>7、下学期开学，变得更有目标性了，基本上就是图像处理（重点关注机器学习）和软件测试。开始完成车牌识别的项目，对于车牌识别领域的各个知识点都有所掌握，重点在字符识别这一块，结合<strong>python和机器学习</strong>这本书，完成了python的学习，加深对学习算法的理解。</p>
<p>8、之后，开始加入一个<strong>实验室的团队，做安卓开发</strong>，一个创业项目，手机App应用。由于本科有java和安卓的一点基础,花了7天的时间，通过极客学院的视频学习Android。这样时间被分为两段，白天在实验室，晚上在工作室那边。11月底，一方面感觉时间过于紧张，没有时间做自己的事情。实验室也有了新的项目，另一方面由于团队的内部原因，选择离开。</p>
<p>9、11月下旬开始接触自动化测试、单元测试、测试驱动开发思想、接口测试以及java、设计模式等等。</p>
<p>10、11月份开始，重点放在实验室项目上，<strong>三光检测系统</strong>，红外和可见光图像配准，图像融合，结合硬件在<strong>Linux</strong>下搭建便于三光检测的手持设备，该项目使用qt编程，有摄像头、视频服务器、pc主板、触摸屏等硬件设备，了解了融合硬件设备和软件的开发流程，自学了linux，由于是实际应用，对方只要知道是否可以在Linux下使用设备即可，所以只接触了简单的liunx，重点负责，Linux和图像融合配准模块。</p>
<h3 id="生活">生活</h3>
<p>11、上半年，组织实验室外出游玩三天，整个过程，从行程安排到住宿，坐车，吃饭，到游玩路线都是我一个人安排下来，全程自助游，路上不断收到大家的赞美声，都说安排的很好很贴心，太开心了。下半年，实验室周末的各种小聚，小活动，都组织得挺好的，为自己的<strong>交际能力和组织能力</strong>喝彩，总的一个感觉就是不管在实验室，在寝室，还是以前本科班，我的人缘还是很不错的，大家都愿意和我交流。这点希望继续保持，用一颗包容的心去对待大家，做一个大家眼里的开心果，传播正能量。</p>
<p>12、暑假回去帮哥哥忙活了大半个月，也算是尽到做妹妹的心了，照顾锦娴，帮助管理店里的生意，感触最深的就是：生活的不容易，各行各业都不是那么轻松的，自己做老板也不轻松，站在不同的位置就会有不同的角度看待问题，也就会有不同的烦恼问题出现。老板有老板的出发点，打工有打工的想法。其实都是不容易，唯有尽心尽力做好就好。不亏待自己，善待他人，包容理解换位思考。家里因为多了个小孩，变得更好欢乐了，只能说小孩好萌，好可爱啊~~~，和小孩接触就了，才发现自己也有一颗童心，未泯的赤子之心。</p>
<p>13、和闺蜜相处融洽，大家都说我们谁也离不开谁。我们能从09年一直走到现在，5年的友情，除了彼此的包容之外，更多的是彼此的维护，愿意为对方迁就自己的一些东西，<strong>愿意用心经营，愿意倾听</strong>。我一直相信，任何一段感情，不管是亲情、友情还是爱情都是需要彼此用心经营的，双方都需要付出，需要包容，若有一方从不付出，再浓感情慢慢的也会随着时间消失。对待生活的态度上，我觉得自个比较像“鬼脚七”（一个很有名的自媒体人），他对网友的一些回答我都很赞同，在价值观上挺一致的。</p>
<p>14、在瑜伽馆兼职了一段时间，爱上了瑜伽，深深感受到瑜伽的魅力，瑜伽成为我的业余爱好，以后有机会要好好的学学瑜伽。</p>
<h3 id="感情">感情</h3>
<p>15、顺其自然，能遇到一个懂你的人不容易，但还是希望那个他能快点出现，不要让我等久了。</p>
<p>　　这一年，给自己一个赞，也希望自己改掉拖拉的毛病，在年尾将所有的工作做个总结和了断，该写报告的写报告，该做记录的做记录，博客该发的发，来年不再为2014年买单了。所有的这些就在元旦前结束。</p>
<p>　　来年，愿自个不再拖延，坚持写博客，每周一次整理和总结所学的知识点，找个好的实习、好的工作，羽毛球技术飞升，和闺蜜好好的享受生活，好好的维持实验室的欢乐氛围，总之：<strong>用心生活，享受乐趣，不让自己遗憾。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　好好回顾了下，这一年自己走过的时光，发现很多事情真的不是自己可以计划和安排的，犹记去年的这个时候是怎样的告诉自己不能浪费时光，要好好对待自己，也给自己设定了目标，也有一部分达成了，一部分终归是不了了之了。到了年底，没想到这一年的时间就这样了没了，回顾过去，<strong]]>
    </summary>
    
      <category term="总结" scheme="http://silencewt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="心路历程" scheme="http://silencewt.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="心路历程" scheme="http://silencewt.github.io/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://silencewt.github.io/2014/12/28/hello-world/"/>
    <id>http://silencewt.github.io/2014/12/28/hello-world/</id>
    <published>2014-12-28T02:18:07.000Z</published>
    <updated>2014-09-12T14:17:00.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试之美有感]]></title>
    <link href="http://silencewt.github.io/2014/12/28/%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%BE%8E%E6%9C%89%E6%84%9F/"/>
    <id>http://silencewt.github.io/2014/12/28/测试之美有感/</id>
    <published>2014-12-28T02:18:07.000Z</published>
    <updated>2014-12-24T12:55:54.000Z</updated>
    <content type="html"><![CDATA[<p>　　<strong>王小波说：这个世界上有两种人，一类人将有趣的事情做成无趣，一类人把无趣的事情做成有趣。</strong>软件测试原本是件很有趣的事情，可是网上有很多的人或者一些做测试的人很不幸将测试这件有趣的事做成了无趣的事情：觉得是日复一日的手工劳动，不断的和开发人员争执，等等……但其实不是这样的。测试是一个软件项目，公司成功的基石，是一种在成本、质量、效率、周期之间平衡的艺术。</p>
<h3 id="一、性能测试，协作是关键">一、性能测试，协作是关键</h3>
<p>　　性能测试是比较复杂的一个测试环节，比如对一个学生进度跟踪系统，客户会要求“100%的网页在5秒或者是更短的时间内显示出来，应用程序支持1000及以上用户同时使用，98%的情况下，课程将在第一次尝试时就完全正确下载”，等等。虽然这是客户的要求，在这样是不可以写进目标里的，因为这完全无法验证，不能讲模棱两可的性能指标写到合同义务中。性能测试应该做到可度量有价值。将其改为“对于内部版本（出现情况需上报），在任意数量的用户条件下，有超过5%的情况加载网页的时间超过5S，超过2%的情况，课程无法完整或正确的下载……对于外部版附有性能报告，包括在，任意数量的用户条件下，有超过5%的情况加载时间超过5S的网页，超过2%的情况无法完整或正确下载的课程……”。<br>　　<strong>对于性能测试的需求从承诺达到一定水平转变为承诺报告在什么样的条件下目标将无法实现。这个过程就涉及到项目经理，客户，开发人员之间的交流和协作。</strong><br>　　但是面对这样的目标还是无法给出测试用例，那么应该在系统中设置检查点，策略：收集系统性能指标基准，并验证使用模型中包括的每个功能任务，分别在1个用户的负荷下，10个用户，1000甚至更多负荷下载每一个包含该功能任务的性能测试中都达到性能需求，每一个下面都需要列出功能任务清单。一个系统的性能是客户最关注的，但是你无法不能性能测试所有的东西。文中用一个超级杯营销的案例，说明性能测试需要与其他测试人员协作，于项目管理协作，于客户协作，于开发团队协作，于IT人员协作，以及与最终用户协作。</p>
<h3 id="二、模糊测试，让系统更可靠">二、模糊测试，让系统更可靠</h3>
<p>　　模糊测试大多数用于办公软件，<strong>那什么是模糊测试：是通过对输入数据进行随机修改和破坏来测试程序的方法。</strong>他为测试和编程人员在开发软件时面临的棘手问题提供多种优美的解决方案。办公软件需要支持很多种格式，我们或许能找到特定格式的文档，但这些文档可能不准确或有丢失处。例如与其他软件之间的互操作性，我们就需要模拟其他复杂软件，或者用一个模糊器生成范围很广的各种文档来模拟各种应用软件和软件版本的差别。office2007在开发的时候就大量使用了模糊测试。<br>　　在进行模糊测试的时候需要准备一组有代表性的文档，一个模糊器，从常规模型到自定义模型。在测试过程中也要不断的修改你的模糊器，以产生更多的测试用例并去除可能影响输出的偏差。模糊测试擅长发现诸如崩溃和挂起的明显问题，但对判断正确性的作用很小。在办公软件领域，它对开发和测试人员所面临的操作性、安全性、和稳定性在内的许多复杂问题提供有创意且简洁的解决方案。</p>
<h3 id="三、自动化测试">三、自动化测试</h3>
<p>　　自动化测试不仅仅是简单的编写和运行那些不需要人为干预的测试用例。事实上，在很多测试人员看来，自动化这是由一些手动生成的，用来执行特定测试场景或一部分产品功能的测试脚本或代码组成。但是很多时候自动化测试并没有给测试人员带来方便，因为除了实际的执行程序之外，流程中的其他部分没有一个实现了自动化。那么为了实施自动化，特别是规模较大的自动化测试，整个过程从头到尾—从测试人员编写玩测试程序到结果被分析出来给人看，都必须自动化。如果没有这个层次上的自动化，测试人员在监控测试程序运行上所花的时间将会变成难以控制的增长。<br>　　在什么情况下自动化可以帮助测试团队，以及什么情况下自动化会妨碍测试的工作，应该百分百的自动化那些应该被自动化的测试，这一准则本身是简单多额，困难就在于决定那些是应该被自动化的，产品架构，相关参与者，都可以帮助测试团队做出正确的决定。很多自动化之所以失败的原因在在于测试人员花太多的时间进行自动化或者试着去自动化，并把时间花在了根本不值得自动化的目标任务上。<br>　　一个基本的自动化测试流程：编写自动化测试—-选择测试和测试平台—-运行测试—-收集用于报告的测试结果—-报告新的额bug解决已近修复的bug。自动化测试要成功的第一步是：测试代码要写得棒。必须要能够易于维护，要对测试带进行源代码控制，并且集中编译和创建。测试员可以成为设计和实现系统测试框架的专家，这于应用程序开发是不一样的。<strong>编写一个漂亮的测试自动化工具需要对被测系统的理解，需要对可能将要编写的测试的理解，需要知道哪些测试对项目最优价值，还需要知道哪些测试最可能在将来随着被测软件的变化而具有可维护性。</strong><br>　　<em>如果在某一阶段，测试通过率仅为94%，你会怎么做？对于合理的测试通过率目标，与其去设定一个神奇的数字，你真正需要的是100%的失败调研并确保那些失败中没有一个严重到阻碍发布。回答”这要看失败来定了，如果阻碍我么达到目标的错误不满足我们的门槛，我们就让他过去“</em></p>
<h3 id="四、测试随机数发生器">四、测试随机数发生器</h3>
<h3 id="五、QA不是魔鬼">五、QA不是魔鬼</h3>
<p>　　测试人员是好的流程的促进者，能准确的发现（在发布之前）软件需求与实现之间不吻合的人，也是最广泛了解软件开发实践的人，对项目总体状态最了解的人。QA的工作是引导软件开发过程以提高成功率，以及建设性的批判软件开发过程而不是阻碍这个过程并成为拖后腿的人。<br>　　检验：通过重复的操作来确认事情做得正确的过程。<br>　　调查：反馈驱动的过程<br>　　很多人认为测试就是简单的触屏和点击，无聊的文本进行，是一个简单无聊的工作，如果这么想就错了，这样的工作不是调查而是检验。测试不仅仅是这些，测试往往需要和各类人员沟通，测试是对产品质量负责，保证每个产品能满足客户的需求及时上线。</p>
<h3 id="六、高效测试">六、高效测试</h3>
<p>　　软件测试中首要考虑的问题就是：安全性测试。导致用户数据的丢失是一件很糟糕的事情！安全性测试必须最早考虑，因为其贯穿在整个产品的架构之中。即架构上如果有所改动，那么几乎需要重新测试所有的东西，比如如果数据库的权限有问题，那么就不得不重新测试所有与数据库交互有关的测试用例，或者一旦程序和操作系统的交互存在安全问题，所有与操作系统交互有关的测试用例也必须重测。安全性对于应用程序的测试几乎会影响到每一个测试领域，需涉及到整个应用程序，对于安全性要求高的领域最好有相关的信息安全人员提供高级全面的解决方案。<br>　　在互联网应用程序中，可以考虑一下几个问题：跨站脚本、SQL注入、越权访问、信息泄露。</p>
<h3 id="七、查找缺陷">七、查找缺陷</h3>
<p>　　问：如果处于整个软件开发周期的最后一个环节：所有的新功能都实现了所有的测试用例也通过了，那么产品可以发布了吗？<br>　　理论上讲是测试用例都通过了就没有问题了，但是怎么保证你的测试集是完美的，如何才能知道你的测试集能有效的检查出缺陷。在这种情况下，可以系统化的植入认为的缺陷，然后测试集能否发现他们。测试集的代码覆盖率就是量化的度量测试集的质量指标（检查是否执行了程序的每一种状态）、分支覆盖率（保证代码中的分支至少被执行一次）、条件覆盖率（保证代码中每个条件分支子条件都经历过是和否的状态）。80%的缺陷都集中在20%的模块中。<br>　　覆盖率只能告诉你测试执行的情况并没有测试集本身的信息。可以使用变异测试，在程序中植入大量的人为的漏洞，并逐个对他们进行测试看哪些变异没有检测出来。然后系统化的改进这个测试集，知道所有的变异都能被检测出来。但是变异测试非常耗时。变异测试依赖于自动化测试。<br>　　问：怎么对程序进行变异呢？改变常量的值（对某一常量X，尝试用X-1,X+1，0来替换），用常量来替换变量的值，用变量来替换数组的引用，改变操作符，改变调用方法，将某一条件置返（判断条件c为非c）。改变数字操作符+改成-,&gt;&gt;改成&lt;&lt;。省略方法调用(将一个方法调用直接改为0.如果该方法不需要返回值，可以直接删除)。</p>
<h3 id="八、测试分类">八、测试分类</h3>
<p>　　黑盒和白盒测试是软件测试中最普遍的设计方法，在黑盒测试中，软件被看做是一个神秘的对象，他的内部结构和设计是未知的，他接受一些输入数据，对数据进行处理，然后输出结果。如果一个程序能正确处理数据并输出预期的结果，则认为测试师成功的。黑盒测试是以软件说明书为基础的，而白盒测试则需要具有软件内部实现的了解，并关注于程序的某一特定路径的测试。程序员要小心的选择测试用例以覆盖所有重要的代码单元。虽然黑盒和白盒测试方法是互相补充的，但二者都有一些共同的局限。其中主要的一个问题就是他们都不能对程序进行全面的测试。这就要求你富有创造型、有效的进行设计，甚至为了在用户使用软件之前将缺陷找到，还要开发出漂亮的测试来覆盖个整蛊你用例。<br>　　静态分析：白盒测试一种，不需要代码的执行，在于查找一般性错误确保代码满足所有重要的要求和标准。一般自动化执行。例如GCC编译器是静态分析工具。<br>　　单元测试：白盒测试一种，检查代码单元个体单个函数或模块是否正常工作，是否接受和处理数据u，并返回预期的值。<br>　　测试脚本：一系列逐步运行的指令集合，再现各种不同的条件来检查程序各项功能是否正常，模仿日常对应用程序的使用，给定在一系列牌值下下能否输出正确的的结果。不关心程序的内部细节。 </p>
<hr>
<p>　　<br>　　<em>这本书并不适合出学者看，建议有了一定的测试基础之后在过来看本书。以上的只是书里的一些摘录，对于测试的理解还不是很深入，但是对于测试会有一点大概的了解，书中提到的一些经验还是不错的，但是个人感觉这本书有点旧时了，不建议看。当然这个只能我个人的看法。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<strong>王小波说：这个世界上有两种人，一类人将有趣的事情做成无趣，一类人把无趣的事情做成有趣。</strong>软件测试原本是件很有趣的事情，可是网上有很多的人或者一些做测试的人很不幸将测试这件有趣的事做成了无趣的事情：觉得是日复一日的手工劳动，不断的和开发人员]]>
    </summary>
    
      <category term="测试" scheme="http://silencewt.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://silencewt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[opencv函数系列---漫水填充floodfill]]></title>
    <link href="http://silencewt.github.io/2014/12/28/opencv%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97-fillfood/"/>
    <id>http://silencewt.github.io/2014/12/28/opencv函数系列-fillfood/</id>
    <published>2014-12-28T02:18:07.000Z</published>
    <updated>2014-09-16T13:57:22.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、floodFill思想">一、floodFill思想</h3>
<p>　　所谓漫水填充，简单来说，就是自动选中了和种子点相连的区域，接着将该区域替换成指定的颜色，这是个非常有用的功能,经常用来标记或者分离图像的一部分进行处理或分析.漫水填充也可以用来从输入图像获取掩码区域,掩码会加速处理过程,或者只处理掩码指定的像素点。操作结果总是某个连续的区域。当邻近像素点位于给定的范围（从lodiff到updiff）内或在原始seedPoint像素值范围内是，floodFill将会为这个点涂上颜色。以此填充算法为基础，类似photoshop的魔术棒选择工具就很容易实现了。<br>　　漫水填充（FloodFill）是查找和种子点联通的颜色相同的点，魔术棒选择工具则是查找和种子点联通的颜色相近的点，将和初始种子像素颜色相近的点压进栈作为新种子。<br>　　泛红填充实现最常见有四邻域像素填充法，八邻域像素填充法，基于扫描线的像素填充方法。根据实现又可以分为递归与非递归（基于栈）。</p>
<h3 id="二、函数介绍">二、函数介绍</h3>
<p>　　</p>
<pre><code>floodFill ( InputOutputArray image,   <span class="comment">//输入/输出1通道或3通道，8位或浮点图像，具体参数由之后的参数具体指明InputOutputArray mask,     </span>
     Point seedPoint,                <span class="comment">//漫水填充算法的起始点</span>
     Scalar newVal,                   <span class="comment">//像素点被染色的值，即在重绘区域像素的新值</span>
     Scalar loDiff=Scalar(), 
     Scalar upDiff=Scalar(), 
     CvConnectedComp*  comp = <span class="keyword">NULL</span>
     <span class="keyword">int</span> flags=<span class="number">4</span> )
</code></pre><p>　　mask：表示操作掩模,（控制被填充的区域）。它应该为单通道、8位、长和宽上都比输入图像 image 大2个像素点的图像（是内部运算简单快速）。floodFill需要使用以及更新掩膜。需要注意的是，漫水填充不会填充掩膜mask的非零像素区域。例如，一个边缘检测算子的输出可以用来作为掩膜，以防止填充到边缘。同样的，也可以在多次的函数调用中使用同一个掩膜，以保证填充的区域不会重叠。另外需要注意的是，掩膜mask会比需填充的图像大，所以mask中与输入图像(x,y)像素点相对应的点的坐标为(x+1,y+1)。<br>　　<br>　　lodiff、updiff：表示当前观察像素值与其部件邻域像素值或者待加入该部件的种子像素之间的亮度或颜色之负差（lower brightness/color difference）或正差的最大值。 如果一个像素点的值不低于被染色的相邻点减去lodiff且不高于其加上updiff，那么该像素点就会被染色。如果flags参数包含FLOODFILL_FIXED_RANGE 这时每个像素点都将于种子点而不是相邻点比较。可以理解成阈值范围，在这个范围里的像素都会被染色。<br>　　<br>　　flags：低8位（第0~7位）用于控制算法的连通性，可取4 (4为缺省值) 或者 8。如果设为4，表示填充算法只考虑当前像素水平方向和垂直方向的相邻点；如果设为 8，除上述相邻点外，还会包含对角线方向的相邻点。高8位部分（16~23位）可以为0 或者如下两种选项标识符的组合：<br>　　（1） FLOODFILL_FIXED_RANGE－如果设置为这个标识符的话，就会考虑当前像素与种子像素之间的差，否则就考虑当前像素与其相邻像素的差。也就是说，这个范围是浮动的。<br>　　（2）FLOODFILL_MASK_ONLY－如果设置为这个标识符的话，函数不会去填充改变原始图像 (也就是忽略第三个参数newVal),而是去填充掩模图像（mask）。中间8位部分，上面关于高八位FLOODFILL_MASK_ONLY标识符中已经说的很明显，需要输入符合要求的掩码。Floodfill的flags参数的中间八位的值就是用于指定填充掩码图像的值的。但如果flags中间八位的值为0，则掩码会用1来填充。<br>　　而所有flags可以用or操作符连接起来，即“|”。例如，如果想用8邻域填充，并填充固定像素值范围，填充掩码而不是填充源图像，以及设填充值为47，那么输入的参数是这样：</p>
<pre><code><span class="attribute">flags</span>=<span class="string">8 | FLOODFILL_MASK_ONLY | FLOODFILL_FIXED_RANGE | （47&lt;&lt;8）</span>
</code></pre><h3 id="三、函数演示">三、函数演示</h3>
<p>待写ing……</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、floodFill思想">一、floodFill思想</h3>
<p>　　所谓漫水填充，简单来说，就是自动选中了和种子点相连的区域，接着将该区域替换成指定的颜色，这是个非常有用的功能,经常用来标记或者分离图像的一部分进行处理或分析.漫水填充也可以用来从输入图像]]>
    </summary>
    
      <category term="opencv" scheme="http://silencewt.github.io/tags/opencv/"/>
    
      <category term="opencv" scheme="http://silencewt.github.io/categories/opencv/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[时间管理--小强升职记]]></title>
    <link href="http://silencewt.github.io/2014/12/28/%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0/"/>
    <id>http://silencewt.github.io/2014/12/28/小强升职记/</id>
    <published>2014-12-28T02:18:07.000Z</published>
    <updated>2014-09-16T13:47:36.000Z</updated>
    <content type="html"><![CDATA[<p>　　书中已对话的形式，主管老付如何教会小强对自己时间进行管理，如何高效的完成工作，培养其成为主管。<br>　　在我们觉得时间很多的时候，他就偷偷的溜走了，时间对于每个人都是公平的。我们每天在忙忙碌碌的日子里过去，是否过得有意义，浑浑噩噩的日子真的是我们所要的吗？到底我自己追求的是什么？每天工作学习是为了什么？什么样的人生才有意义?我们需要站在一个更高的位置上审视自己。问问自己什么才是真正想要的。<br>　　<br>　　我们的时间总是在无意义的事情上面一点点的浪费掉。确实如此，以前总是每次开电脑的时候。登下QQ，看下新闻什么的，以为这样浪费不了多少时间，可是每次都没有忍住，还有点像滚雪球似的的越滚越长，结果一看时间已经10:00多了，过一会就要吃饭了，自然就没有心思学习了，或者每次时间很轻易的就被同学打断，被QQ消息打断，那么在要集中注意就很难，就是这样的时间黑洞将我们的时间吞噬掉。<br>　　<br>　　有时候也会有同时有很多事情向我袭来，很多时候就应该根据自己的价值观，给他们分出优先级，找出核心事件，及时解决这些问题。时间管理的方法有很多，四象限法则，时间投资法，衣柜整理法等，具体哪一种是适合你的，还是需要自己去摸索，去实践才知道什么是适合自己的。书里的时间资本法，对于时间价值的计算让我忽然醒来，原来我的时间就剩这么一点了，可是我想要的生活还没有实现。。<br>　　<img src="/images/zbjs2.png" alt="资本计算2"><br>    <img src="/images/zbjs.png" alt="资本计算"><br>　　很典型的，在今后工作的日子里，只有8年是在工作，有10年是在睡觉，其他时间是13年，有人曾统计过一个人活得72岁时对时间的消费情况：睡觉21年，工作14奶奶，个人卫生7年，吃饭6年，旅行6年，排队5年，学习4年，开会3年，打电话2年，找东西1年，其他3年。如果加上我们的年新来计算时间资本，那么很廉价。。</p>
<h3 id="目标">目标</h3>
<p>　　时间，是一个非常奇怪的东西，当你想挥霍它的时候，它会尽量的满足你，让你觉得怎么挥霍都用不完。但是当你想要珍惜它的时候，他又会i特别的吝啬，让你觉得时光飞逝，转眼已是尽头。<br>　　对于一个项目或是什么要有明确的目标，具体的下一步行动，一个行动清单。对人生有规划，有明确的目标是很好的，但如果沉迷在未来美好生活的幻想中，而不是执行它，只是做个梦想家，我们要将目标化为行动，做个建筑家，梦想的缔造者。<br>　　当然，目标也不是有了完美的计划就能达成的，我们需要方法避免失败。<br>　　1、找到最大的石头，就是要问问自己实现这个目标最大的石头（障碍）在哪里，如果最大的石头没有移除，你除去了99%的小石头也是没有用的。<br>　　2、有什么想法计划一定要写下来，白字黑子是最好的契约，写到了才可以做到，那么所有的想想就不再只是想想了，而是需要实现的东西了。<br>　　3、拒绝第一次失败，万事开头难，很多目标的夭折都是从第一次失败开始的。所以我们要重视第一次的是吧，摆正心态不让它产生连锁反应。我们有一种很可怕的适应性，不敢是对好习惯还是坏习惯的适应。失败了，我们更应该找出原因，为什么会失败？到底为什么成功？花时间思考这两个问题是非常重要的。</p>
<h3 id="习惯">习惯</h3>
<p>　　习惯是个很可怕的东西，对于长期做在电脑前的上班族，最重要的一点就是要养成健身的习惯，平时我们可能没有大把的时间可以去运动，为了身体的健康，每天坚持一个小时的锻炼。向着你要养成多习惯，每天去做一些你不愿意的事情，这样你就不会为那些真正需要你完成的责任而痛苦。</p>
<h3 id="思维导图">思维导图</h3>
<p><img src="/images/swdt.bmp" alt="思维导图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　书中已对话的形式，主管老付如何教会小强对自己时间进行管理，如何高效的完成工作，培养其成为主管。<br>　　在我们觉得时间很多的时候，他就偷偷的溜走了，时间对于每个人都是公平的。我们每天在忙忙碌碌的日子里过去，是否过得有意义，浑浑噩噩的日子真的是我们所要的吗？到底我自己追]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://silencewt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单Xpath入门]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E7%AE%80%E5%8D%95Xpath%E5%85%A5%E9%97%A8/"/>
    <id>http://silencewt.github.io/2014/12/25/简单Xpath入门/</id>
    <published>2014-12-25T13:54:52.000Z</published>
    <updated>2014-12-25T14:01:04.000Z</updated>
    <content type="html"><![CDATA[<p>　　XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。XPath 是 XML 的查询语言，和 SQL 的角色很类似。以下面 XML 为例，介绍 XPath 的语法。</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span>
<span class="tag">&lt;<span class="title">catalog</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"USA"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Empire Burlesque<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bob Dylan<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>10.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"UK__time"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"UK"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"USA"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Greatest Hits<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Dolly Parton<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span><span class="tag">&lt;/<span class="title">catalog</span>&gt;</span>
</code></pre><p><strong>定位节点</strong></p>
<p>　　XML 是树状结构，类似档案系统内数据夹的结构，XPath 也类似档案系统的路径命名方式。不过 XPath 是一种模式(Pattern)，可以选出 XML 档案中，路径符合某个模式的所有节点出来。<br>1）要选 catalog 底下的 cd 中所有 price 元素可以用：<br>　　 /catalog/cd/price<br> 　 如果 XPath 的开头是一个斜线（/）代表这是绝对路径。如果开头是两个斜线（//）表示文件中所有符合模式的元素都会被选出来，即使是处于树中不同的层级也会被选出来。</p>
<p>2）选出文件中所有叫做 cd 的元素（在树中的任何层级都会被选出来）：<br>　　//cd　　使用星号（Wildcards,＊）可以选择未知的元素。</p>
<p>3）选出/catalog/cd 的所有子元素：<br>　　/catalog/cd/*</p>
<p>4）选出所有 catalog 的子元素中，包含有 price 作为子元素的元素。<br>　　/catalog/*/price</p>
<p>5）选出有两层父节点，叫做 price 的所有元素。<br>　　/<em>/</em>/price</p>
<p>6）选择出文件中的所有元素。<br>　　//<em>　<br>　　要注意的是，想要存取不分层级的元素，XPath 语法必须以两个斜线开头(//)，想要存取未知元素才用星号(</em>)，星号只能代表未知名称的元素，不能代表未知层级的元素。</p>
<p><strong>选择分支</strong><br>使用中括号可以选择分支。</p>
<p>1）从 catalog 的子元素中取出第一个叫做 cd 的元素。XPath 的定义中没有第0元素<br>　　/catalog/cd[1]</p>
<p>2）选择 catalog 中的最后一个 cd 元素： XPath 没有定义 first() 这种函式，用上例的 [1]就可以取出第一个元素。<br>　　/catalog/cd[last()]</p>
<p>3）选出含有 price 子元素的所有/catalog/cd 元素。<br>　　/catalog/cd[price]</p>
<p>4）选出 price 元素的值等于10.90的所有/catalog/cd 元素<br>　　/catalog/cd[price=10.90]</p>
<p>5）选出 price 元素的值等于10.90的所有/catalog/cd 元素 的 price 元素<br>　　/catalog/cd[price=10.90]/price</p>
<p><strong>选择一个以上的路径</strong></p>
<p>使用 Or 操作数(|)就可以选择一个以上的路径</p>
<p>1）选择所有 title 以及 artist 元素<br>　　//title | //artist</p>
<p>2）选择所有 title 以及 artist 以及 price 元素<br>　　//title | //artist | //price</p>
<p><strong>选择属性</strong> </p>
<p>在XPath的属性。除了选择元素以外，也可以选择属性，属性都是以@开头。</p>
<p>1）选择文件中所有叫做 country的属性。<br>　　//@conutry</p>
<p>2）选择所有含有country 这个属性的 cd元素。<br>　　//cd[@country]</p>
<p>3) 选择出country属性值为UK的cd元素<br>　　//country[@country==’UK’]</p>
<p><strong>部分匹配</strong></p>
<p>有些属性的值具有一定的规律，例如上面的UK就是前缀，一部分是不变的。也可以用start-with</p>
<p>1）定位属性值前缀为UK<em>的元素<br>　　//cd[containers(@country，’UK</em>‘)]<br>　　//cd[start-with(@country，’UK_’)]  </p>
<p>这是在某个文档里面学习来的，感觉简单又易上手，故摘录于此。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。XPath 是 XML 的查询语言，和 SQL 的角色很类似。以下面 XML 为例，介绍 XPath ]]>
    </summary>
    
      <category term="selenium" scheme="http://silencewt.github.io/tags/selenium/"/>
    
      <category term="selenium" scheme="http://silencewt.github.io/categories/selenium/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[selenium--大家庭介绍]]></title>
    <link href="http://silencewt.github.io/2014/12/25/selenium-%E5%A4%A7%E5%AE%B6%E5%BA%AD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://silencewt.github.io/2014/12/25/selenium-大家庭介绍/</id>
    <published>2014-12-25T13:29:10.000Z</published>
    <updated>2014-12-25T14:01:20.000Z</updated>
    <content type="html"><![CDATA[<p>安装好配置环境后，开始我的selenium之旅。简单的了解一下色，selenium大家庭的组成。</p>
<p>Selenium是ThoughtWorks专门为Web应用而开发的功能测试工具。Selenium使用JavaScript和Iframes在浏览器嵌入自动化测试引擎，可以在任何支持JavaScript的浏览器中进行工作，模拟用户在浏览器中进行的操作。Selenium的强大之处就在于可以使用集成开发环境，让用户使用自己最熟悉的开发语言进行调试操作。</p>
<p><strong>Selenium的优势</strong>：<br>1）它是开源的    </p>
<p>2）简单，易于安装，易于工作    </p>
<p>3）提供Selenium IDE ，一个FireFox plugin，能自动记录用户的操作，生成测试脚本。生成的测试脚本可以基于Selenium RC放入Java，C#，Ruby的单元测试用例中自动运行。selenium ide是selenium的唯一可以在浏览器窗口上记录用户行为的组件     </p>
<p>4）除了火狐上的事件外不会记录你电脑上的任何其他事件    </p>
<p>5）Selenium支持多种浏览器，能够运行与多种操作系统，因此更容易帮助测试人员发现应用程序在不同浏览器上的兼容性问题。通过在不同浏览器中运行测试，更容易发现浏览器的不兼容性. </p>
<p>6）通过编写模仿用户操作的 Selenium 测试脚本，可以从终端用户的角度来测试应用程序；可以操作 Web 页面上的各种元素，诸如：点击按钮、输入文本框，以及断言 Web 页面上存在某些文本与 Web 元素等。<br><br>7）测试用例调用实际的浏览器(如IE、FireFox)来执行测试。和有些开源方案自行实现Web解释引擎相比，实际的浏览器能模拟更多用户交互和JS语法。    </p>
<p> 8） SELENIUM录制的脚本比较灵活，因为它生成的是PERL的脚本程序。作为几乎最为强大和最广泛使用语言之一，PERL这种程序给予我最大的灵活性和控制度。</p>
<p><strong>Selenium IDE</strong> 支持并且只支持 Firefox 浏览器，支持的浏览器太少，而依附于 Firefox 也不便于日后开展自动化测试，但是，它的录制快捷好用！并且有代码 转换功能，可以把 Selenium 语言测试案例转为 C#,Java 等语言的测试案例，使用 Selenium IDE + FireBug 进行测试案例的编写，然后转为其他语言的测试案例后，再调用 Selenium RC运行测试案例。</p>
<p><strong>Selenium RC</strong> 它支持很多浏览器，可以使用 C#，Java 等语言编写测试案例，易于维护，同时提供了很好的扩展性，将使用Selenium RC 测试工具。</p>
<p>selenium 和 WebDriver 合幵后创建了一个新的 Selenium 2 框架。 Selenium 是一个针对网页应用测试非常好的框架。他有着一些积极的影响。WebDriver 也不像 Selenium 1 一样需要一个代理。你可以直接和浏览器进行对话。这也非常受人们欢迎的，因为可以加快测试的执行速度，不需要一个“中间人”进行传递消息。</p>
<p><strong>Selenium IDE</strong>：右Command、target、value组成的表格就是脚本，每个脚本都是一条条的action行为组成，action有CTV 三者组成，command就是api中的各种函数，target就是web中的某个目标对象，比如：输入框、按钮等，使用xpath选取对象。Value：根据实际内容填写。</p>
<p>　　在这里可以手动的增加两种页面校验：verify和assert。他们都能对显示内容，输出内等做验证，区别在于：</p>
<ul>
<li>verify：验证失败了，会抛出期望结果不存在的错误，但是测试过程会继续执行下面的步骤，但会显示成淡红的。</li>
<li>assert：验证失败，测试不会继续执行下去。</li>
</ul>
<p>Selenium 没有指明会等到需要交互的元素出现，所以你最好等到需要交互元素出现时再迕行交互，即利用wait指令。如带有下拉菜单，带有ajax的页面都要有所等待，等页面元素准备好了再进行下一步的操作。</p>
<p>Selenium RC：有两部分组成</p>
<ul>
<li>Selenium Server：负责控制浏览器行为，包括三个部分：launcher、http proxy、Selenium core，其中Selenium core是Selenium server嵌入到浏览器页面中的，Selenium core是一堆JS函数的集合，从而实现对浏览器的操作。</li>
<li>Selenium Clientlibrary：写测试案例时用来控制server的库。</li>
</ul>
<p>支持很多浏览器，可以使用C#，Java 等语言编写测试案例，易于维护，同时提供了很好的扩展性。</p>
<p><strong>Selenium Grid</strong>允许创建很多个 Selenium RC实例，由一个中心来发送 Selenium RC命令。拥有一个中心点 Hub， 测试可以连接到此点，  测试命令会推送到连接在此集线器上的Remote RC 实例上。 这个中心有一个 web 界面（localhost：4444/console）， 告诉你连接在此集线器上的Selenium RC 实例，和返些实例是否正在使用的状态。</p>
<blockquote>
<p>启动Selenium Server<br>java –jar selenium-server-standalone-2.22.0.jar -port 4444<br>启动Selenium Grid的Hub<br>java –jar selenium-server-standalone-2.22.0.jar -port 4000 -role hub<br>启动Selenium Grid的Node，其中的-hub参数，是Selenium Grid的Hub的URL<br>java -jar selenium-server-standalone-2.22.0.jar -port 4001 -role node -hub <a href="http://127.0.0.1:4000/grid/register" target="_blank" rel="external">http://127.0.0.1:4000/grid/register</a></p>
</blockquote>
<p>显然，可以启动多个Node：<br>java -jar selenium-server-standalone-2.22.0.jar -port 4002 -role node -hub <a href="http://127.0.0.1:4000/grid/register" target="_blank" rel="external">http://127.0.0.1:4000/grid/register</a></p>
<h4 id="WebDriver">WebDriver</h4>
<p>　　WebDriver 提供一个先进技术来定位 web 页面元素。其实WebDriver就是基于Selenium的一个自动化测试类库，但它不再是运行在浏览器内的JS程序，而是自己可以控制浏览器。webdriver提供了很多方式来定位元素，对于不同平台的语言都有相关的api，如C#、java、python、ruby等等。</p>
<p>　　前段时间利用空余的时间学习这方面的知识，现将其一点点的整理出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>安装好配置环境后，开始我的selenium之旅。简单的了解一下色，selenium大家庭的组成。</p>
<p>Selenium是ThoughtWorks专门为Web应用而开发的功能测试工具。Selenium使用JavaScript和Iframes在浏览器嵌入自动化测试引擎]]>
    </summary>
    
      <category term="selenium" scheme="http://silencewt.github.io/tags/selenium/"/>
    
      <category term="selenium" scheme="http://silencewt.github.io/categories/selenium/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个网页的测试用例]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://silencewt.github.io/2014/12/25/一个网页的测试用例/</id>
    <published>2014-12-25T13:23:58.000Z</published>
    <updated>2014-12-25T14:03:45.000Z</updated>
    <content type="html"><![CDATA[<p>　　今天在看51testing的博客时，看到这么一个网页登录的测试用例，想到自己之前写的那个关于登录页面的简单的功能测试用例真的是太弱了，感觉很多都没有考虑进去。特此在这里记录下来，参考。具体需求： 有一个登陆页面， （假如上面有2个textbox, 一个提交按钮。 请针对这个页面设计30个以上的TestCase.）</p>
<p>　　此题的考察目的：面试者是否熟悉各种测试方法，是否有丰富的web测试经验， 是否了解Web开发，以及设计Test case的能力<br>首先，你要了解用户的需求，比如这个登录界面应该是弹出窗口式的，还是直接在网页里面。对用户名的长度，和密码的强度（就是是不是必须多少位，大小写，特殊字符混搭）等。还有比如用户对界面的美观是不是有特殊的要求？（即是否要进行UI测试）。剩下的就是设计用例了 ，等价类，边界值等等。<br>　　请你记住一点，<strong>任何测试，不管测什么都是从了解需求开始的。</strong></p>
<p><strong>功能测试(Function test)</strong><br>　　0.  什么都不输入，点击提交按钮，看提示信息。（非空检查）<br>　　1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。（正常输入）<br>　　2.输入错误的用户名或者密码, 验证登录会失败，并且提示相应的错误信息。（错误校验）<br>　　3.登录成功后能否能否跳转到正确的页面（低）<br>　　4.用户名和密码，如果太短或者太长，应该怎么处理（安全性，密码太短时是否有提示）<br>　　5.用户名和密码，中有特殊字符（比如空格），和其他非英文的情况（是否做了过滤）<br>　　6.记住用户名的功能<br>　　7.登陆失败后，不能记录密码的功能<br>　　8.用户名和密码前后有空格的处理<br>　　9.密码是否加密显示（星号圆点等）<br>　　10.牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个按钮是否好用<br>　　11.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确<br>　　12.输入密码的时候，大写键盘开启的时候要有提示信息。</p>
<p><strong>界面测试(UI Test)</strong><br>　　1.布局是否合理，2个testbox 和一个按钮是否对齐<br>　　2.testbox和按钮的长度，高度是否复合要求<br>　　3. 界面的设计风格是否与UI的设计风格统一<br>　　4. 界面中的文字简洁易懂，没有错别字。</p>
<p><strong>性能测试(performance test)</strong><br>　　1.打开登录页面，需要几秒<br>　　2.输入正确的用户名和密码后，登录成功跳转到新页面，不超过5秒</p>
<p><strong>安全性测试(Security test)</strong><br>　　1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)<br>　　2.用户名和密码是否通过加密的方式，发送给Web服务器<br>　　3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript验证<br>　　4.用户名和密码的输入框，应该屏蔽SQL注入攻击<br>　　5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）<br>　　6.错误登陆的次数限制（防止暴力破解）<br>　　7. 考虑是否支持多用户在同一机器上登录；<br>　　8. 考虑一用户在多台机器上登录</p>
<p><strong>可用性测试(Usability Test)</strong><br>　　1. 是否可以全用键盘操作，是否有快捷键<br>　　2. 输入用户名，密码后按回车，是否可以登陆<br>　　3. 输入框能否可以以Tab键切换</p>
<p><strong>兼容性测试（Compatibility Test）</strong><br>　　1.主流的浏览器下能否显示正常已经功能正常（IE,6,7,8,9, Firefox, Chrome, Safari,等）<br>　　2.不同的平台是否能正常工作，比如Windows, Mac<br>　　3.移动设备上是否正常工作，比如Iphone, Andriod<br>　　4.不同的分辨率</p>
<p><strong>本地化测试（Localization test）</strong><br>　　1. 不同语言环境下，页面的显示是否正确。<br>　　软件辅助性测试 （Accessibility test）<br>　　软件辅助功能测试是指测试软件是否向残疾用户提供足够的辅助功能<br>　　2. 高对比度下能否显示正常 （视力不好的人使用）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　今天在看51testing的博客时，看到这么一个网页登录的测试用例，想到自己之前写的那个关于登录页面的简单的功能测试用例真的是太弱了，感觉很多都没有考虑进去。特此在这里记录下来，参考。具体需求： 有一个登陆页面， （假如上面有2个textbox, 一个提交按钮。 请针对]]>
    </summary>
    
      <category term="测试用例" scheme="http://silencewt.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试用例" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[9本java程序员必读的书]]></title>
    <link href="http://silencewt.github.io/2014/12/25/9%E6%9C%ACjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB%E7%9A%84%E4%B9%A6/"/>
    <id>http://silencewt.github.io/2014/12/25/9本java程序员必读的书/</id>
    <published>2014-12-25T13:11:05.000Z</published>
    <updated>2014-12-25T13:22:59.000Z</updated>
    <content type="html"><![CDATA[<p>来源：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scene=1#rd" target="_blank" rel="external">http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scene=1#rd</a></p>
<p>　　本文列出的9本书在Java程序员界都是被认为很棒的书。当一个程序员开始初学Java时，他的第一个问题应该是如何选择一本书来作为指导学习Java。这个问题也就表明，相对于其他的教程和博客，Java书籍还是很重要的参考，主要表现在以下两点</p>
<p>●通常书籍是由比较权威的程序员来撰写的。</p>
<p>●相比其他媒介，书籍对于内容的描述更加详细，解释更加明确。</p>
<p>　　本文列出的九本书是我个人非常喜欢的Java书籍，当我有时间的时候，我就会将它们捧在手里阅读。甚至有些书我反复读过很多遍，每次重新读的时候总会有新的收获。因此这些书也是大部分Java程序员喜欢的书籍。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java1.jpg" alt="javabook1"><br>　　Head　First Java是所有编程或者Java初学者最适合的书籍，我很喜欢轻松和寓教于乐的Head First风格，这应该是最有意思的关于Java的书。无论是初级，中级还是高级都能从中有所收获。学习本书，你可以了解到类，对象，线程，集合等编程知识，还可以了解到泛型，枚举，可变参数和自动装箱等语言特性。本书中还涉及到了Java高级编程中的Swing，网络编程，IO操作等，可以让初学者对Java有比较完整地概念。如果你是一位Java初学者，不要犹豫，这本书最适合你了。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java2.jpg" alt="javabook２"><br>　　Head First设计模式又是一部Head First系列的书籍。作者为Kathy Sierra及其团队。当我在2006年开始读这本书的时候，我对设计模式并不是很了解。设计模式解决什么问题，怎么解决问题，如何使用设计模式，设计模式有什么好处，这些问题我几乎都无法回答出来。但是当我读完这本书的时候，一切都豁然开朗。在本书介绍继承和组合一章，使用简单有趣的例子，一步一步提出问题并解决问题，最终得出最优解。本书中会有很多要点总结，幽默对话，练习题还有有名的单词接龙等帮助你更好地了解设计模式。如果你想了解Java中的设计模式，请带走这本书。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java3.jpg" alt="javabook3"><br>　　Effective Java这本书也是一本我最喜欢的。本书为领导开发Java集合框架和并发API包的 约书亚·布洛克 大神所著。本书适合于有着数年开发经验Java程序员，通过本书我们可以很多编程中的最佳实践，并且可以从JDK贡献者布洛克大神这里汲取经验。Effective Java从质量，内容和问题解答方式上来说都是一本评价很高的书，因此读这本书会是一种感觉很棒的体验。另外本书的章节相对比较轻量，与其他章节耦合度较低，因此在旅行或者闲暇时间阅读也是可以的。在内容方面，Effective Java包含了从静态工厂，序列化，equals和hashcode到泛型，枚举，可变参数以及反射的最佳解决方法。本书对Java各方面知识点的讲解会让你受益匪浅。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java4.jpg" alt="enter image description here"><br>又一部 约书亚·布洛克 大神的经典之作，当然本书的另一位主作者为 Doug Lea（影响两次Java历史上的大变革的大神）。这本书几乎就是Java并发和多线程编程方面的权威，同时也是核心Java开发人员必读的一本书。本书的强大主要表现在</p>
<ul>
<li>本书非常详细地描述了多线程和并发中的诸多(小)细节。</li>
<li>本书并非聚焦于核心Java代码的实现，而是关注并发引起的问题，比如死锁，饥饿，线程安全，竞争条件，然后提供可行的方法来解决这些问题。因此这本书可以很好地帮助开发者了解并掌握并发包以及其中的CountDownLatch，CyclicBarrier，BlockingQueue，Semaphore这些类。这也是我一遍一遍阅读这本书的原因。</li>
<li>书中的例子简明扼要清晰，很能描述问题。</li>
<li>解释明确：本书很好地解释了什么是错的，为什么错，怎样改正。这也是本书畅销的原因之一。</li>
</ul>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/java5.jpg" alt="enter image description here"><br>　　这本书是来自O’Reilly的一本成功之作，作者为Naftalin和Philip Wadler。正如书名可知，这本书的内容关注于泛型和集合这两个Java语言的核心方面。本书对于那些有编程经验的程序员加强对集合和泛型的理解和掌握有很大的帮助。本书详细介绍了每一个集合的API，Set, List, Map, Queue，以及他们的实现，对比不同场景下它们的性能优劣。每个章节最后的对比图表很不错。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java6.jpg" alt="enter image description here"><br>　　本书为我个人的最爱，本书重点关注性能监视，性能剖析以及如何使用工具对性能分析。本书不同于其他的编程书籍，因为本书中涉及到很多Java虚拟机的细节，垃圾回收机制，Java堆内存监视以及对程序性能剖析。其中讲述JVM的章节写的很不错，很值得咀嚼。注意，这本书属于编程高级层次，阅读需要具有足够的Java编程经验。初级和中级Java开发者也可以阅读本书也会学到不同程度的干货。所以，你想进行性能调优，把这本书放到你的书架上吧。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java7.jpg" alt="enter image description here"><br>　　再介绍一本 约书亚·布洛克 大神写的书。本书的另一位作者为Neal Gafter（已转到微软做Donet Compiler技术Lead）。本书讲述了Java语言中的极端情况和陷阱。相对于C++，Java更加安全低风险，JVM有着垃圾回收机制，让Java程序员不用关心内存分配和释放，大大提高了程序的开发效率。但是有些时候，即便是经验丰富的程序员也会被Java中的极端情况或陷阱给绊倒。本书列举并详细描述了Java中的这些陷阱。如果你喜欢刨根问底，钻牛角尖，这本书就是为你而写。通过本书，你可以了解很多java的核心知识并对自己的Java水平有所知晓。本人更加喜欢上面提到的 约书亚·布洛克 的 Effective Java 和 Concurrency Practice in Java。但是如果你感兴趣，还是可以去尝试的。为了让收获最大化，你可以先尝试解决书中的问题，然后对着书中的解释进行比较。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java8.jpg" alt="enter image description here"><br>　　这是一本属于Head First系列的关于面向对象编程的书。本书建议和Head First设计模式结合阅读，效果更佳。本书关注于面向对象设计原则，比如多用组合少用继承，针对接口编程而非针对实现编程，不要重复你自己等。这本书可以帮助你写出好代码并且参考最佳实践进行优化改善。当然本书中的内容也适合使用其他面向对象的语言的程序员。想学好面向对象编码和设计规则，现在就开始读这本书哈。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java9.jpg" alt="enter image description here"><br> 　　Thinking in Java book应该是Java中文界最有名的书籍了，中文又名 Java编程思想。作者为Bruce Eckel，他也是Thinking in C++的作者，他用自己很独特的观点讲述了Java。据我所知，这本书获得了很高的认可，本书是一本介绍齐全的Java学习参考书。如果你不喜欢Head First类似小人书那样的讲解，可以尝试这本书。本书的内容讲解详细，成熟（相对Head First有种教科书的感觉）。</p>
<p>　　这就是我的关于Java编程相关的推荐的书，这些都可以说是看成经典中的经典。像Effective Java 和 Head First 系列我已经反复阅读了很多遍。相信看完本文，根据自己的水平和想要提升的知识侧重，你应该能选出最适合自己的书了。<br>　　Mark下，以后慢慢看。。。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来源：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scen]]>
    </summary>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java--面向抽象编程]]></title>
    <link href="http://silencewt.github.io/2014/12/25/java-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://silencewt.github.io/2014/12/25/java-面向抽象编程/</id>
    <published>2014-12-25T13:09:48.000Z</published>
    <updated>2014-12-25T13:10:15.000Z</updated>
    <content type="html"><![CDATA[<p>　　所谓面向抽象编程是指当设计某种重要的类时，不让该类面向具体的类，而是面向抽象类，及所设计类中的重要数据是抽象类声明的对象，而不是具体类声明的对象。就是利用abstract来设计实现用户需求。</p>
<p>比如：我们有一个Circle圆类，计算其面积。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Geometry</span></span>{
<span class="keyword">double</span> r;
Circle(<span class="keyword">double</span> r){
    <span class="keyword">this</span>.r = r;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span>(){
    <span class="keyword">return</span> (<span class="number">3.14</span>*r*r);
}
}
</code></pre><p>现在要设计一个Pillar（柱类），getvolume（）可以计算柱体的体积。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Pillar{
Circle bottom;
<span class="keyword">double</span> height;
Pillar(Circle bottom, <span class="keyword">double</span> height){
    <span class="keyword">this</span>.bottom = bottom;
    <span class="keyword">this</span>.height = height;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVolume</span>(){
    <span class="keyword">return</span> bottom.getArea() * height;
}
}
</code></pre><p>　　在Pillar（柱类）中，bottom是用具体类Circle声明的对象，如果不涉及用户需求的变化，上面Pillar（柱类）的设计没有什么不妥，但是在某个时候，用户希望Pillar（柱类）能创建出底部是三角形的柱体。显然上面的Pillar（柱类）就无法创建出这样的柱体，即上述设计的Pillar（柱类）不能应对用户的这中需求。</p>
<p>　　重新修改Pillar（柱类）。注意到柱体的计算体积的关键是计算出底面积，一个柱体在计算底面积是不应该关心他的底是社么形状的具体图案，应该只关心这种图像是否具有计算出面积的方法。因此，在设计Pillar（柱类）的时候不应当让他的底是某个具体类的声明的对象，一旦这么做，Pillar（柱类）就会依赖具体类，缺乏弹性，难以应对需求的变化。</p>
<p><strong>第一步</strong>：定义一个抽象类Geometry，类中定义一个抽象的getArea（）方法，Geometry类如下。这个抽象类将所有计算面积的方法都抽象为一个标识：getArea（）无需考虑算法细节。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Geometry{
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getArea</span>();
}
</code></pre><p><strong>第二步</strong>：Pillar（柱类）可以面向Geometry类编写代码，即Pillar（柱类）应当把Geometry类作为自己的成员，该成员可以调用Geometry的子类重写的getArea（）方法。这样，Pillar（柱类）就将计算底面积的任务指派个Geometry类的子类的实例，不再依赖于某一个具体的类，而是面向Geometry类的，即Pillar（柱类）的bottom是用抽象类Geometry声明的对象，而不是具体的某一类，新的Pillar（柱类）如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Pillar{
Geometry botom;
<span class="keyword">double</span> height;
Pillar(Geometry bottom, <span class="keyword">double</span> height){
    <span class="keyword">this</span>.bottom = bottom;
    <span class="keyword">this</span>.height = height;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVolume</span>(){
    <span class="keyword">return</span> bottom.getArea() * height;
}
}
</code></pre><p>在新增Geometry的子类时就不需要修改Pillar（柱类）的任何代码，只需要增加一个Triangle类（三角形）。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Geometry</span></span>{
<span class="keyword">double</span> a,b;
Circle(<span class="keyword">double</span> a, <span class="keyword">double</span> b){
    <span class="keyword">this</span>.a = a;
    <span class="keyword">this</span>.b = b;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span>(){
    <span class="keyword">return</span> (a*b);
}
}
</code></pre><p>应用：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Application{
<span class="keyword">public</span> state <span class="keyword">void</span> <span class="title">main</span>(String args[]){
    Pillar pillar;
    Geometry bottom;
    bottom = <span class="keyword">new</span> Circle(<span class="number">10</span>);             <span class="comment">//子类的上转型对象</span>
    pillar = <span class="keyword">new</span> Pillar(bottom, <span class="number">10</span>);
    System.<span class="keyword">out</span>.println(<span class="string">"圆柱体的体积"</span> + pillar.getVolume());
    bottom = <span class="keyword">new</span> Rectangle(<span class="number">10</span>,<span class="number">10</span>);
    pillar = <span class="keyword">new</span> Pillar(bottom, <span class="number">10</span>);
    System.<span class="keyword">out</span>.println(<span class="string">"矩形底的体积"</span> + pillar.getVolume());
}
}
</code></pre><p><strong>总结</strong>：面向抽象编程目的是为了应对用户需求的变化，将某个类中经常因需求变化而需要改变的代码从类中分离出去。其核心是让类中每种可能的变化对应的交给抽象类的一个子类去负责，从而让该类的设计者不去关心具体的实现，避免所设计的类依赖于具体的实现。</p>
<p><strong>关于抽象类</strong>：</p>
<ul>
<li>对于抽象类不能用new创建该类的对象，但可以成为其子类的上转型对象，从而该对象可以调用子类重写的方法。</li>
<li>一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法，给出方法体。</li>
</ul>
<p>　　</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　所谓面向抽象编程是指当设计某种重要的类时，不让该类面向具体的类，而是面向抽象类，及所设计类中的重要数据是抽象类声明的对象，而不是具体类声明的对象。就是利用abstract来设计实现用户需求。</p>
<p>比如：我们有一个Circle圆类，计算其面积。</p>
<pre]]>
    </summary>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java--面向接口编程]]></title>
    <link href="http://silencewt.github.io/2014/12/25/java-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
    <id>http://silencewt.github.io/2014/12/25/java-面向接口编程/</id>
    <published>2014-12-25T12:58:46.000Z</published>
    <updated>2014-12-25T13:05:55.000Z</updated>
    <content type="html"><![CDATA[<p>　　之前看的一本书的笔记，上周再看设计模式的时候，想到了这篇之前在看某本书时候的笔记。</p>
<p>　　面向接口编程很重要的一点就是接口回调，用接口声明的变量称作接口变量，属于引用型变量，可以存放实现该接口的类的实例的引用，对象引用。<strong>接口回调</strong>：可以把实现某一接口的类创建的对象的引用赋值给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口方法。</p>
<p>Com com;      //接口<br>ImplCom object;    //实现接口的对象<br>com = object;        //接口回调，com会根据对象的不同而实现不同的接口方法，回调类重写的接口方法<br>接口和abstract类的比较如下：<br>abstract类和接口都可以有abstract方法。<br>接口中只可以有常量，不能有变量；而abstract类中既可以有常量也可以有变量。abstract类中也可以有非abstract方法，接口不可以。</p>
<p>　　在设计程序时应当根据具体的分析来确定是使用抽象类还是接口。abstract类除了提供重要的需要重写的abstract方法外，也提供了子类可以继承的变量和非abstract方法。如果某个重要问题需要使用继承才能更好地解决，比如，子类需要重写父类的abstract方法，还需要从父类继承一些变量或继承一些重要的非abstract方法，就可以考虑用abstract类。如果某个问题不需要继承，只是需要若干个类给出某些重要的abstract方法的实现细节，就可以考虑使用接口。<br>　　使用接口编程的最重要的<strong>核心思想就是使用接口回调</strong>，及接口变量存放实现该接口的类的对象的引用，从而接口变量就可以回调类实现的接口方法。<br>　　<img src="http://7te8s4.com1.z0.glb.clouddn.com/jiekou.jpg" alt="接口编程">　　</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Advertisement {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAdvertisement</span>();
    <span class="keyword">public</span> String <span class="title">getCorpName</span>();
}
</code></pre><p>2、设计AdvertisementBoard类（广告牌），该类有一个show（Advertisement adver）方法，该方法的参数是接口Advertisement的类型，显然该参数adver可以存放任何实现Advertisement接口的类的对象的引用，并回调类重写的接口方法showAdvertisement()来显示公司的广告词，回调类重写的接口方法getCorpName来获取公司名称。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> AdvertisementBoard{
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> (Advertisement adver){
    System.<span class="keyword">out</span>.println(adver.getCorpName()+<span class="string">"广告词"</span>);
    adver.showAdvertisement（）; <span class="comment">//接口回调</span>
}
}
</code></pre><p>实现接口的A公司类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Acorp implement Advertisement {
<span class="keyword">public</span> <span class="keyword">void</span> showAdvertisement（）{
    System.<span class="keyword">out</span>.println(<span class="string">"AAAAAAAAAAAAAAAAA"</span>);
}
<span class="keyword">public</span> String getCorpName（）{
    <span class="keyword">return</span> <span class="string">"A Corp"</span>;
}
}
</code></pre><p>实现接口的B公司类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Bcorp implement Advertisement {
<span class="keyword">public</span> <span class="keyword">void</span> showAdvertisement（）{
    System.<span class="keyword">out</span>.println(<span class="string">"BBBBBBBBBBBBBBBBB"</span>);
}
<span class="keyword">public</span> String getCorpName（）{
    <span class="keyword">return</span> <span class="string">"B Corp"</span>;
}
}
</code></pre><p>运行住程序：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> test （）{
<span class="keyword">public</span> state <span class="keyword">void</span> main （<span class="keyword">string</span> args[]）{
    AdvertisementBoard board = <span class="keyword">new</span> AdvertisementBoard();
    board.show(<span class="keyword">new</span> Acorp());
    board.show(<span class="keyword">new</span> Bcorp());
}
}
</code></pre><p>最后程序会根据对象的不同调用不同的方法。若想要添加C公司，只要实现接口的方法就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　之前看的一本书的笔记，上周再看设计模式的时候，想到了这篇之前在看某本书时候的笔记。</p>
<p>　　面向接口编程很重要的一点就是接口回调，用接口声明的变量称作接口变量，属于引用型变量，可以存放实现该接口的类的实例的引用，对象引用。<strong>接口回调</stron]]>
    </summary>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式----建造者模式]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://silencewt.github.io/2014/12/25/设计模式-建造者模式/</id>
    <published>2014-12-25T12:50:32.000Z</published>
    <updated>2014-12-28T02:29:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong></p>
<p>建造者模式：又叫生成器模式，就是对流程的抽象，一步一步的去创建一个复杂的对象。</p>
<p>举个实例，有一个化学老师需要在公开课上向校长等人演示摸个试管实验，老师请了两个同学A和B上台演示，ＡＢ的操作顺序都是一样的，只是试剂所放的量不一样而已，那么老师要如何控制这个学生呢？如果我们只是简单地定义两个学生类A和B的话，由于两个人的实验顺序（方法）是一样的，那么就很容易出错，搞错了顺序？或者漏掉某个步骤？</p>
<p><strong>解决</strong>：因为他们具有一样的组成成分，那么就可以让他们同时继承一个抽象接口，该接口提供他们所需要的步骤，以确保不会漏掉某步。因为子类必须实现抽象接口里的所有方法。</p>
<p>抽象接口类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Student {
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou1</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou2</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou3</span>();
}
</code></pre><p>学生A：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentA</span> <span class="keyword">extends</span> <span class="title">Student</span></span>{

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou1</span>() {
    System.out.println(<span class="string">"AAAAA"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou2</span>() {
    System.out.println(<span class="string">"BBBBBB"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou3</span>() {
    System.out.println(<span class="string">"CCCCCC"</span>);
}
}
</code></pre><p>学生B：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">Student</span></span>{
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou1</span>() {
    System.out.println(<span class="string">"OOOOO"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou2</span>() {
    System.out.println(<span class="string">"PPPPP"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou3</span>() {
    System.out.println(<span class="string">"QQQQQQ"</span>);
}
}
</code></pre><p>虽然保证了不会漏掉某部，但是还是无法保证学生能正确操作？这是就可以使用建造者模式，有老师来控制。</p>
<p>teacher类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Teacher {
<span class="keyword">private</span> Student student;
<span class="keyword">public</span> <span class="title">Teacher</span>(Student student) {
    <span class="keyword">this</span>.student = student;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DirectEx</span>() {
    student.buZou1();
    student.buZou2();
    student.buZou3();
}
}
</code></pre><p>主函数：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]) {
    Student studentA = <span class="keyword">new</span> StudentA();
    Student studentB = <span class="keyword">new</span> StudentB();
    Teacher teacher = <span class="keyword">new</span> Teacher(studentA);
    teacher.DirectEx();
    teacher = <span class="keyword">new</span> Teacher(studentB);
    teacher.DirectEx();
}
</code></pre><p>   <strong>总结</strong>：建造者模式就是当需要一个复杂对象的构建或者造作过程和这个对象的表示相分离，就可以使用了。就相当于A和 B是具体的创建者，知道怎么操作，但是学生不知道完成一次实验需要按照何种步骤来进行，而老师作为指挥者，了解实验步骤，可以指挥学生（按一定顺序调用学生类提供的方法）来实验，客户端就只需要关心结果就好了。使用这个模式，用户只要制定要创建的类型就可以得到对应的对象，为具体的过程被direct和builder影藏了。而这正体现了依赖倒转的原则，抽象不依赖于细节，细节依赖于抽象。</p>
<hr>
<p>建造者模式的<code>标准代码</code>：<br>Builder：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Builder {
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPartA</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPartB</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">getResult</span>();   
}
</code></pre><p>product：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Product {
    ArrayList&lt;String&gt; parts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(String part) {
        parts.add(part);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"create product"</span>);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.size(); i++) {
            String part = parts.<span class="keyword">get</span>(i) ;
            System.<span class="keyword">out</span>.println(part);
        }
    }
}
</code></pre><p>建造者类A：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilderA</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>{
<span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartA</span>() {
    product.add(<span class="string">"part A"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartB</span>() {
    product.add(<span class="string">"part B"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> Product <span class="title">getResult</span>() {
    <span class="keyword">return</span> product;
}
}
</code></pre><p>建造者B:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilderB</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>{

<span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartA</span>() {
    product.add(<span class="string">"part W"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartB</span>() {
    product.add(<span class="string">"part Q"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> Product <span class="title">getResult</span>() {
    <span class="keyword">return</span> product;
}
}
</code></pre><p>指挥者：这里控制之行动的顺序</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Director {
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span>(Builder builder){
    builder.builderPartA();
    builder.builderPartB();
}
}
</code></pre><p>客户端：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]) {
    Director director = <span class="keyword">new</span> Director();
    Builder builder = <span class="keyword">new</span> ConcreteBuilderA();
    Builder builder2 = <span class="keyword">new</span> ConcreteBuilderB();

    director.construct(builder);
    Product productA = builder.getResult();
    productA.show();
    director.construct(builder2);
    Product productB = builder2.getResult();
    productB.show();
}
</code></pre><p>  建造者优点：</p>
<p>1）在建造者模式中，客户端不必知道产品内部组成的具体细节，将产品本身于产品的创建过程进行解耦，是的相同的创建过程可以创建不同的产品对象。</p>
<p>2）每一个具体的建造者都是独立的，而与其他的具体建造者没有关系，可以很方便的去增加或者删除一个建造者，用户用不同的建造者就可以获得不同的产品。</p>
<p>3）可以更加精细的控制产品创建的具体过程，将复杂的产品步骤分解在不同的方法当中，是的创建过程更加清晰。</p>
<p>4）增加新的建造者不用修改原有类库的代码，指挥者类是针对抽象建造者类编写的，扩展方便，符合开放封闭原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong></p>
<p>建造者模式：又叫生成器模式，就是对流程的抽象，一步一步的去创建一个复杂的对象。</p>
<p>举个实例，有一个化学老师需要在公开课上向校长等人演示摸个试管实验，老师请了两个同学A和B上台演示，ＡＢ的操作顺序都是一样]]>
    </summary>
    
      <category term="设计模式" scheme="http://silencewt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式----原型模式]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://silencewt.github.io/2014/12/25/设计模式-原型模式/</id>
    <published>2014-12-25T12:49:44.000Z</published>
    <updated>2014-12-25T12:50:02.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong></p>
<p><strong>原型模式</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。就是依托一个已经实例化的对象去创建另外一个可以进行定制的对象，而不需要知道创建过程的具体细节。本质特点：在不重新初始化的情况下动态获取对象在运行时的状态。</p>
<p>在Java中直接实现接口Cloneable接口就可以了，override其中clone方法，</p>
<p><strong>举个例子</strong>：在我们考证的时候，都要填写报名信息，每次都一样的，如果每次都要填写一样的信息会很烦，能不能写好一份后，以后不管什么考试都只要复制过去就好了呢？</p>
<p>报名信息类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestrationInfo</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>{
<span class="keyword">private</span> String name;
<span class="keyword">private</span> String birthday;
<span class="keyword">private</span> String school;
<span class="keyword">private</span> String ID;

<span class="keyword">public</span> <span class="title">RestrationInfo</span>(String name){
    <span class="keyword">this</span>.name = name;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span>(String birthday) {
    <span class="keyword">this</span>.birthday = birthday;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchool</span>(String school) {
    <span class="keyword">this</span>.school = school;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setID</span>(String iD) {
    ID = iD;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>(){
    System.out.println(<span class="string">"name:"</span>+name);
    System.out.println(<span class="string">" birthday:"</span>+ birthday);
    System.out.println(<span class="string">"school:"</span>+school);
    System.out.println(<span class="string">"ID:"</span>+ID);
}
<span class="annotation">@Override</span>
<span class="keyword">protected</span> Object <span class="title">clone</span>() <span class="keyword">throws</span> CloneNotSupportedException {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> <span class="keyword">super</span>.clone();
    } <span class="keyword">catch</span> (CloneNotSupportedException e) {
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

}
}
</code></pre><p>客户端：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> MyMain {

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    System.<span class="keyword">out</span>.println(<span class="string">"cet 4"</span>);
    RestrationInfo restrationInfo = <span class="keyword">new</span> RestrationInfo(<span class="string">"wang"</span>);
    restrationInfo.setBirthday(<span class="string">"XXXx"</span>);
    restrationInfo.setID(<span class="string">"dfd"</span>);
    restrationInfo.setSchool(<span class="string">"dfd"</span>);
    restrationInfo.show();

    System.<span class="keyword">out</span>.println(<span class="string">"cet 6"</span>);
    RestrationInfo restrationInfo2 = (RestrationInfo) restrationInfo.clone();
    restrationInfo2.show();
}
}
</code></pre><p>　　这样就实现了一份信息，一直使用。如果我们只是简单的每次new一个对象的，就每次都要执行构造函数，如果构造函数复杂，就会影响到性能。在信息没有变化的情况下，复制是最好的解决方案。</p>
<p>　　<strong>问题</strong>：调用一个函数操作某对象的时候，常常会使得改对象陷入不可用的状态（不稳定状态），等操作结束后才会重新回到完全可用的状态。如果有线程企图访问一个处于不可用状态的对象，改对象会发生不能正确不相应的情况，由此会产生无法预料的后果。对一个实力对象进行克隆的时候，如果恰巧在多线程的情况下且该对象处于不稳定状态，那么克隆可能就会失败。所以说原型模式在实现时不是线程安全的。一定要在其属于稳定的情况下克隆。</p>
<p>　　<strong>问题</strong>：复制的深度，clone对于值类型的字段会逐位复制，而对于引用型的变量会复制引用但是不复制引用的对象，所以原始的对象和它的副本都引用同一个对象。这就是浅复制——被复制的对象的变量都与原来对象有相同的值，而所有的其他对象的引用都依然指向原来的对象。</p>
<p>　　也就是说如果我在报名信息里添加了地址信息，地址是一个单独的类，在复制报名信息的同时也要复制报名信息所引用的地址对象，使得报名信息对象的副本引用的是原国籍对象的副本。即让地址类也实现原型模式，实现Cloneable接口。</p>
<p>地址类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>{
<span class="keyword">private</span> String city;

<span class="keyword">public</span> String <span class="title">getCity</span>() {
    <span class="keyword">return</span> city;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span>(String city) {
    <span class="keyword">this</span>.city = city;
}
<span class="annotation">@Override</span>
<span class="keyword">protected</span> Object <span class="title">clone</span>() {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> <span class="keyword">super</span>.clone();
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

}
}
</code></pre><p>修改后报名信息类：</p>
<pre><code><span class="keyword">protected</span> Object <span class="title">clone</span>()  {
<span class="comment">//      try {</span>
<span class="comment">//          return super.clone();</span>
<span class="comment">//      } catch (CloneNotSupportedException e) {</span>
<span class="comment">//          return null;</span>
<span class="comment">//      }</span>
    RestrationInfo objInfo = <span class="keyword">new</span> RestrationInfo(<span class="keyword">this</span>.address);
    objInfo.name = <span class="keyword">this</span>.name;
    objInfo.ID = <span class="keyword">this</span>.ID;
    objInfo.birthday=<span class="keyword">this</span>.birthday;
    objInfo.school = <span class="keyword">this</span>.school;
    <span class="keyword">return</span> (Object)objInfo;
}

<span class="keyword">private</span> Address address;
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span>(Address address){
    <span class="keyword">this</span>.address = address;
}
<span class="comment">//just for clone private gouzao</span>
<span class="keyword">private</span> <span class="title">RestrationInfo</span>(Address address) {
    <span class="keyword">this</span>.address = address;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong></p>
<p><strong>原型模式</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。就是依托一个已经实例化的对象去创建另外一个可以进行定制的对象，而不需要知道创建过程的具体细节。本质特点：在]]>
    </summary>
    
      <category term="Design pattern" scheme="http://silencewt.github.io/tags/Design-pattern/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://silencewt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式----单例模式]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://silencewt.github.io/2014/12/25/设计模式-单例模式/</id>
    <published>2014-12-25T12:38:02.000Z</published>
    <updated>2014-12-25T12:45:46.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong></p>
<p>　　单例模式是某个类只需要一个实例，保证一个类有且只有一个实例，并提供一个访问他的全局访问点。比如对于一个统一的数据库的访问，在整个项目中只使用同一个实例。对于这种情况有个比较好的例子，就是一夫一妻制。</p>
<p>　　比如某个男子需要娶个女子结婚，那么就有下面的程序：wife类，代表女子，husband类，代表男子　</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Wife {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"the girl show themself"</span>);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"the girl gets married"</span>);
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> Husband {
    <span class="keyword">private</span> Wife myWife = <span class="keyword">null</span>;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chooseGirl</span>() {
    myWife = <span class="keyword">new</span> Wife();
    myWife.show();
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMarry</span>() {
        myWife.marry();
    }
}
</code></pre><p>在主程序里就可以实例化husband类，然后依次调用chooseGirl()和getmarry（）方法，就可以正常运行。但是如果先调用getMarry（）呢？由于wife在choose里面实例化的，这是就会报错，将husband类修改如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chooseGirl</span>() {
    <span class="keyword">if</span> (myWife == <span class="keyword">null</span>) {
        myWife = <span class="keyword">new</span> Wife();
    }
    myWife.show();
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMarry</span>() {
    <span class="keyword">if</span> (myWife == <span class="keyword">null</span>) {
        myWife = <span class="keyword">new</span> Wife();
    }
    myWife.marry();
}
</code></pre><p>　　这样一来就可以保证一个丈夫只能有一个妻子了。而且两个函数没有调用的先后关系。</p>
<p><strong>问题一</strong>：如果婆婆想要看儿媳妇呢？那就会有一个婆婆类，婆婆类里面又需要实例化一个wife类，这个实例化的wife类和husband的里面实例化的wife类是不同的，出现了多个实例化的问题，也就是婆婆看到的和儿子娶的不是同一个姑娘，这怎么行呢？这就需要修改wife类的代码，保证只有一个实例出现。<br>wife类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Wife {
    <span class="keyword">public</span> <span class="keyword">static</span> Wife wife;  <span class="comment">//静态变量</span>
    <span class="keyword">private</span> <span class="title">Wife</span>(){          <span class="comment">//私有构造方法，是的外部无法访问</span>
    }
    <span class="keyword">public</span> <span class="keyword">static</span> Wife <span class="title">getInstance</span>(){  <span class="comment">//静态方法来实例化</span>
        <span class="keyword">if</span> (wife == <span class="keyword">null</span>) {
            wife = <span class="keyword">new</span> Wife();
        }
        <span class="keyword">return</span> wife;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"the girl show themself"</span>);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"the girl gets married"</span>);
    }
}
</code></pre><p>　　将构造函数设为私有，声明静态变量wife和静态方法getinstance来进行实例化。在需要实例化的地方用Wife wife=Wife.getInstance()来获得实例，就可以保证大家看到的是同一个姑娘。</p>
<p><strong>问题二</strong>：如果婚礼现场需要直播，怎么办？可以使用多线程技术，一个线程A作为实地的婚礼，在wife中调用marry方法，另一个线程B作为直播，同样在线程中调用marry的，那么怎么能确定getInstance得到的是同一个新娘呢？如果线程A先运行到此，这是wife为null，那么进入到分支实例化wife，在未完成实例化的时候，线程B也来到了分支内，此时wife依然为null，线程B又会进行一次实例化，最终还是产生了两个实例，就是两个不同的新娘。</p>
<p><strong>解决</strong>：引入<code>锁</code>的概念，lock的作用就是构造出一块临界区来控制线程对代码的访问，确保每次只有一个线程运行到临界区的代码，其他线程运行到临界区时，将会一直等待直到前面的线程运行出临界区为止。</p>
<p>在wife中修改代码：在if前加锁</p>
<pre><code><span class="keyword">lock</span>.<span class="keyword">lock</span>();
<span class="keyword">if</span> (wife == <span class="keyword">null</span>) {
    wife = <span class="keyword">new</span> Wife();
}
<span class="keyword">lock</span>.unlock();
</code></pre><p>这样就能保证在A实例化之前B不会进行null的判断。这样虽然满足了功能的要求，可是每次调用的getInstance的时候都要进行加锁工作，这将会影响程序的性能。所以对其进行改良。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> Wife <span class="title">getInstance</span>(){  <span class="comment">//静态方法来实例化</span>
    <span class="keyword">if</span> (wife == <span class="keyword">null</span>) {
        <span class="keyword">lock</span>.<span class="keyword">lock</span>();
        <span class="keyword">if</span> (wife == <span class="keyword">null</span>) {
            wife = <span class="keyword">new</span> Wife();
        }
        <span class="keyword">lock</span>.unlock();
    }
    <span class="keyword">return</span> wife;
}
</code></pre><p>在临界区内在进行一次null的判断，只有wife为null的时候才会进入初始化。<br><strong>单例模式本身的代码</strong>：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">public</span> <span class="keyword">static</span> Singleton singleton;  <span class="comment">//静态变量</span>
    <span class="keyword">private</span> <span class="title">Singleton</span>(){ 
               <span class="comment">//私有构造方法，是的外部无法访问  </span>
    }
    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(){  <span class="comment">//静态方法来实例化</span>
        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {
            singleton = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> singleton;
    }
}
</code></pre><p>客户端代码：</p>
<pre><code>Singleton <span class="variable">singleton1 =</span> Singleton.getInstance();
Singleton <span class="variable">singleton2 =</span> Singleton.getInstance();
<span class="keyword">if</span>(<span class="variable">singleton1 =</span>= singleton2){
    System.out.printle(<span class="string">"the teo object are the same one"</span>);
}
</code></pre><p>单例模式虽然很简单，但很实用，以下情况都适合实用：</p>
<p>1）当类只能有一个实例而且第三方可以从一个公共的访问点访问它时</p>
<p>2）当一个唯一的实例可以通过子类化来扩展，而且第三方需要在不更改代码的情况下就能实用一个扩展的实例时。</p>
<p>单例模式<strong>优点</strong>：</p>
<p>1）队唯一的实例做出访问控制</p>
<p>2）允许改变实例的个数，可以增加一个计数器来控制实例的个数，从而有双例模式，三利模式等。</p>
<p><strong>总结</strong></p>
<p>　　单例并不是上面写的这么简单，里面涉及到很多的知识点，多线程、加锁、私有构造函数，静态构造函数，静态字段，readonly和const的区别等等。</p>
<p>　　向这里给出的单例版本就涉及到线程安全的问题，当2个请求同时方式这个类的实例的时候，可以会在同一时间点上都创建一个实例，虽然一般不会出异常错误，但是起码不是我们谈论的只保证一个实例了。每一个设计模式都值得我们深入的研究下去，有时间一定回头看看。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong></p>
<p>　　单例模式是某个类只需要一个实例，保证一个类有且只有一个实例，并提供一个访问他的全局访问点。比如对于一个统一的数据库的访问，在整个项目中只使用同一个实例。对于这种情况有个比较好的例子，就是一夫一妻制。</p>
<]]>
    </summary>
    
      <category term="Design pattern" scheme="http://silencewt.github.io/tags/Design-pattern/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://silencewt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式---工厂模式]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://silencewt.github.io/2014/12/25/设计模式-工厂模式/</id>
    <published>2014-12-25T12:36:42.000Z</published>
    <updated>2014-12-25T12:37:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong>       </p>
<p>　　工厂方法模式属于类的创建行模式又被称为多态工厂模式。工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，核心工厂类将不在负责产品的创建，这昂核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口。</p>
<p>　　简单工厂模式又叫静态工厂模式，由一个工厂决定创建出哪一种商品的实例。只要输入想要的产品代号，就会实例化合适的对象。</p>
<p>　　这里举个简单的例子：<br>　　小张开了一家面包店，根据客人的不同需求提供不同的面包，这里就有不同的面包师傅做不同的面包，这些个面包师傅（HoneyBread、BlackBread）等又归一个总师傅管理BreadMaker，也就是这些师傅的手艺都是继承自该师傅，这个厨房后台呢，就相当于一个工厂（IFactory），不同的种类就由不同的工厂（HoneyFactory）生产，工厂会根据需求将不同的种类产品分给不同种类的总师傅（PizzaMaker、BreadMaker），在由师傅分配任务给不同的制作师。上诉流程就将整个工厂模型的思路理清了。</p>
<p>简单工厂类：</p>
<pre><code>package com.hust.SimpleFactory;
<span class="keyword">public</span> <span class="keyword">class</span> BreadFactory {
    <span class="keyword">public</span> <span class="keyword">static</span> BreadMaker <span class="title">MakeBread</span>(<span class="keyword">int</span> breadType){
         BreadMaker breadMaker = <span class="keyword">null</span>;
        <span class="keyword">switch</span> (breadType) {
        <span class="keyword">case</span> <span class="number">1</span>:
            breadMaker = <span class="keyword">new</span> BlackBread();
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">2</span>:
            breadMaker =  <span class="keyword">new</span> HoneyBread();
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">3</span>:
            breadMaker =  <span class="keyword">new</span> WhiteBread();
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="keyword">break</span>;
        }
        <span class="keyword">return</span> breadMaker;
    }
}
</code></pre><p>总师傅：</p>
<pre><code>package com.hust.SimpleFactory;
<span class="keyword">public</span> <span class="keyword">class</span> BreadMaker {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetBread</span>(){
    <span class="comment">//nothing</span>
    }
}
</code></pre><p>不同的面包师傅：</p>
<pre><code><span class="keyword">package</span> com.hust.SimpleFactory;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackBread</span> <span class="keyword">extends</span> <span class="title">BreadMaker</span> </span>{
    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">GetBread</span>() {
        System.out.println(<span class="string">"做出黑面包"</span>);;
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneyBread</span> <span class="keyword">extends</span> <span class="title">BreadMaker</span> </span>{
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetBread</span>() {
        System.out.println(<span class="string">"做出蜂蜜面包"</span>);
    }
}
</code></pre><p>商店前台：</p>
<pre><code>public static void main(String args[]) {
    B<span class="built_in">read</span>Maker breadMaker;
    System.out.println(<span class="string">"面包店开业！"</span>);
    System.out.println(<span class="string">"开始制作黑面包"</span>);
    breadMaker = B<span class="built_in">read</span>Factory.MakeB<span class="built_in">read</span>(<span class="number">1</span>);
    breadMaker.GetB<span class="built_in">read</span>();
    System.out.println(<span class="string">"开始制作蜂蜜面包"</span>);
    breadMaker = B<span class="built_in">read</span>Factory.MakeB<span class="built_in">read</span>(<span class="number">2</span>);
    breadMaker.GetB<span class="built_in">read</span>();
    System.out.println(<span class="string">"开始制作白面包"</span>);
    breadMaker = B<span class="built_in">read</span>Factory.MakeB<span class="built_in">read</span>(<span class="number">3</span>);
    breadMaker.GetB<span class="built_in">read</span>();
}
</code></pre><p>工厂模式：除了上诉内容外增加了一个总工厂负责类：</p>
<pre><code><span class="keyword">package</span> com.hust.Factory;
<span class="keyword">import</span> com.hust.AbstractFactory.PizzaMaker;
<span class="keyword">import</span> com.hust.SimpleFactory.BreadMaker; 
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>{
    BreadMaker createBread();
    PizzaMaker createPizza();
}
</code></pre><p>不同的工厂类：如果增加pizza这个产品，就在总工厂里增加一个函数负责pizza（这就是抽象工厂模式）</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneyFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> BreadMaker <span class="title">createBread</span>() {
        <span class="keyword">return</span> <span class="keyword">new</span> HoneyBread();
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> PizzaMaker <span class="title">createPizza</span>() {
        <span class="keyword">return</span> <span class="keyword">new</span> HoneyPizza();
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> BreadMaker <span class="title">createBread</span>() {
        <span class="keyword">return</span> <span class="keyword">new</span> BlackBread();
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> PizzaMaker <span class="title">createPizza</span>() {
        <span class="keyword">return</span> <span class="keyword">new</span> BlackPizza();
    }
 }
</code></pre><p>工厂模式时的柜台操作：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]) {
    BreadMaker breadMaker;
    System.<span class="keyword">out</span>.println(<span class="string">"面包店开业！"</span>);
    System.<span class="keyword">out</span>.println(<span class="string">"开始制作黑面包"</span>);
    IFactory breadFactory = <span class="keyword">new</span> BlackBreadFactory();
    breadMaker = breadFactory.createBread();
    breadMaker.GetBread();
    System.<span class="keyword">out</span>.println(<span class="string">"开始制作蜂蜜面包"</span>);
    breadFactory = <span class="keyword">new</span> HoneyBreadFactory();
    breadMaker = breadFactory.createBread();
    breadMaker.GetBread();
    system.<span class="keyword">out</span>.println(<span class="string">"开始制作蜂蜜pizza"</span>);
    breadFactory = <span class="keyword">new</span> HoneyBreadFactory();
    PizzaMaker pizzaMaker = breadFactory.createPizza();
    pizzaMaker.GetPizza();
}
</code></pre><p>不同的产品的师傅：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaMaker</span> </span>{
    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">GetPizza</span>() {
        <span class="comment">//nothing</span>
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneyPizza</span> <span class="keyword">extends</span> <span class="title">PizzaMaker</span> </span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPizza</span>() {
    <span class="comment">// TODO Auto-generated method stub</span>
    System.out.println(<span class="string">"做出蜂蜜披萨"</span>);
    }
}
</code></pre><p>　　问题：假设小张有很多分店，每个分店有不同的柜台，那天小张决定将黑巧克力面包改成抹牛油的，在修改了工厂之后，必须相应的修改柜台的代码，级每一个申明过breadMaker和pizzaMaker的地方都要修改，那么工作量将恨大。这就体现了抽象模式的缺点，便于交换产品的同时，也需要改动产品声明过的地方。如何避免呢？一种方法就是根据前台用户的输入，使用if switch语句进行判断，但随着产品的增长，分支会越来越多。那么客户端还是需要大量的修改。另一种方法就是——反射。对客户端代码修改如下：</p>
<pre><code><span class="keyword">try</span> {
    <span class="keyword">Class</span>&lt;?&gt; c = <span class="keyword">Class</span>.forName(<span class="string">"HoneyBreadFactory"</span>);
    <span class="keyword">try</span> {
        breadFactory = (IFactory) c.newInstance();
        pizzaMaker = breadFactory.createPizza();
        pizzaMaker.GetPizza();
    } <span class="keyword">catch</span> (Exception e) {
            <span class="comment">// TODO: handle exception</span>
    }
} <span class="keyword">catch</span> (ClassNotFoundException e) {
        <span class="comment">// TODO: handle exception</span>
}
</code></pre><p>这样就避免了分支的出现。<br>这里提到了三个工厂模式：<strong>简单工厂</strong>、<strong>工厂方法</strong>、<strong>抽象工厂</strong>。他们的优缺点如下：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/gcmsdb.jpg" alt="工厂模式"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong>       </p>
<p>　　工厂方法模式属于类的创建行模式又被称为多态工厂模式。工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，核心工厂类将不在负责产品的创建，这昂核心类成为一个抽象工厂角]]>
    </summary>
    
      <category term="Design pattern" scheme="http://silencewt.github.io/tags/Design-pattern/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://silencewt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式---设计原则]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://silencewt.github.io/2014/12/25/设计模式-设计原则/</id>
    <published>2014-12-25T09:42:49.000Z</published>
    <updated>2014-12-28T02:28:58.000Z</updated>
    <content type="html"><![CDATA[<p>　　设计模式是一种设计思想，一种解决方案，能够做到代码的可复用性。这段时间利用空余的时间，在复习java的同时，学习设计模式。记录过程的一点体会。<br>　　<br>1）<strong>单一职责原则</strong></p>
<p>　　<em>问题由来</em>：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p>
<p>　　<em>解决方案</em>：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p>
<p>　　如果一个类具有很多不同的功能，比如超人拥有很多的技能，当我们想对其中一种技能进行修改或者升级的时候就不得不停止超人其他的功能，而这期间如果有事情发生，超人是无法提供帮助的，那么是否可以让超人简单点呢？在维护世界和平的时候，也能够帮助人们除草呢？</p>
<p>　　这就是单一职责——对于一个类，应该只有一个引起她变化的原因。实际上，往往会碰到职责分块的问题，会遇到将职责A划分为职责A1和A2，这时就需要重新设计类，尽量降低类的复杂度，提高类的可读性。</p>
<p><em>遵循单一职责原的优点有</em>：</p>
<p>（1）可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</p>
<p>（2）提高类的可读性，提高系统的可维护性；</p>
<p>（3）变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<p>2）<strong>里氏代换原则</strong></p>
<p>　　<em>问题由来</em>：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p>　　<em>解决方案</em>：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>
<p>　　反映父类和子类的关系。B类继承A类，属于B的对象就具有A类的全部属性和方法。里氏代换的原则就是：子类型必须能够完全替换掉他们的父类型。即子类可以以父类的身份出现，并且不影响程序的功能时父类才能真正得到复用。所有引用基类的地方必须能透明地使用其子类的对象。通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>3）<strong>开放-封闭原则</strong></p>
<p>　　<em>问题由来</em>：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<p>　　<em>解决方案</em>：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>　　在面向对象编程时，如果要实现一个新的功能，添加一个新类来完成往往要比修改现有的类更加方便和安全。封装变化，降低耦合。OCP的原则是：程序的实体对象（模块、类、函数）应该可以进行扩张，但不应该可以修改。对于扩展是开放的，对于修改是封闭的。绝对的封闭很难做到，那么在面对需求变化时，设计人员就应该对自己设计的模块决定选择哪种变化封闭，保证无需对原码进行修改。</p>
<p>　　具体的实现就是<code>面向抽象编程</code>，继承抽象父类，通过重写其方法来改变固有行为，从实现新的扩展方法。</p>
<p>4）<strong>依赖倒转原则</strong></p>
<p>　　<em>问题由来</em>：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
<p> 　　<em>解决方案</em>：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<p>　　定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。核心思想是面向接口编程。</p>
<p>　　程序的高层模块不应该依赖于低层模块，但两者都应依赖于抽象：抽象不应该依赖于具体细节，而细节应该依赖于抽象，简而言之就是针对接口编程，不应该是针对实现编程。即通过抽象（接口或抽象类）是各个类或模块的实现彼此独立，不互相影响。程序的依赖关系终止于接口或抽象。</p>
<p>5）<strong>合成聚合复用原则</strong></p>
<p>　　尽量不使用类继承，而尽量使用合成/聚合。聚合是一种比较弱的拥有关系，具体表现是甲对象中可以包括乙对象，但乙对象不是甲对象的一部分；合成则是一种比较强的拥有关系，体现的是严格整体和部分的关系，并且整体和部分有相同的生命周期。如果两个类的关系是Has-a，则不应该设计成继承。这个原则有一个去缺点，就是系统中会有很多对象需要管理。</p>
<p>6）<strong>迪米特法则</strong></p>
<p>　　也叫做最少知识原则，一个对象尽可能少的了解其他对象，不和陌生人说话。每个类要尽可能的减少对其他类的依赖，不希望类之间建立直接的接触，如果需要接触则希望通过友元类（第三方）来传达（转发调用），这样会导致系统中存在大量的友元类。</p>
<p>　　<em>问题由来</em>：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>　　<em>解决方案</em>：尽量降低类与类之间的耦合。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　设计模式是一种设计思想，一种解决方案，能够做到代码的可复用性。这段时间利用空余的时间，在复习java的同时，学习设计模式。记录过程的一点体会。<br>　　<br>1）<strong>单一职责原则</strong></p>
<p>　　<em>问题由来</em>：类T负责两]]>
    </summary>
    
      <category term="Design pattern" scheme="http://silencewt.github.io/tags/Design-pattern/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://silencewt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JUnit单元测试--小试牛刀]]></title>
    <link href="http://silencewt.github.io/2014/12/25/JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://silencewt.github.io/2014/12/25/JUnit单元测试-小试牛刀/</id>
    <published>2014-12-25T07:51:46.000Z</published>
    <updated>2014-12-25T14:03:37.000Z</updated>
    <content type="html"><![CDATA[<p>单元测试更多的是在开发阶段完成，开发人员每写一个函数的时候都会写相应的单元测试。对于java代码，普遍使用的是jUnit，根据jUnit可以自己相应的开发一套自动化测试框架。这个的前提是要学会junit，先知道怎么用，才能知道怎么为我所用。</p>
<p>学习JUnit的操作很简单，JUnit是一个敏捷编程的开发框架，他的设计很值得学习。这也是我学习JUnit的原因。</p>
<p>JUnit最大的特点就是：各个方法之间是独立的，一个方法的失败不会影响另一个方法的执行。</p>
<p>JUnit 3：是基于反射机制的方法，有命名的约束，必须以test开头。每一个类都继承了TestCase类，而TestCase的父类是Assert类。即所有测试类都是TestCase类的子类。</p>
<p>JUnit 4：引入了注解(annotation)，通过解析注解就可以为测试提供相应的信息。@Test表明这是要执行的测试方法，不管测试方法的名字是什么，都会执行。每一个类可以不继承任何类，可以是一个普通类也可以去继承一个类或实现一个接口，要实现测试只需要在要测试的方法之前加@Test注释就可以了，但是仍然可以直接使用断言，静态导入import static org.junit.Assert.*；</p>
<p>为了更好地理解junit测试用例，我找了一个简单的例子来练习：</p>
<p>例如有这么一个类Greeting，根据每天不同的时间来返回不同的问候语：</p>
<pre><code><span class="keyword">package</span> com.test.one;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>{
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_MORNING = <span class="string">"Good Morning Sunshine!"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_AFTERNOON = <span class="string">"Just a few more hours before quiting time!"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_EVENING = <span class="string">"I am outta here"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HOUR_MORNING = <span class="number">12</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HOUR_AFTERNOON = <span class="number">17</span>;
  <span class="keyword">private</span> java.sql.Timestamp iGreetingTime = <span class="keyword">null</span>;
  <span class="keyword">public</span> <span class="title">Greeting</span>(){
    <span class="keyword">this</span>(System.currentTimeMillis());
  }
  <span class="keyword">public</span> <span class="title">Greeting</span>(<span class="keyword">long</span> greetingTime) {
    <span class="keyword">super</span>();
    iGreetingTime = <span class="keyword">new</span>  java.sql.Timestamp(greetingTime);
}
  <span class="keyword">public</span> String <span class="title">getGreeting</span>(){

    <span class="keyword">if</span>(iGreetingTime.getHours()&lt;MAX_HOUR_MORNING){
        <span class="keyword">return</span> GREETING_MORNING;
    }<span class="keyword">else</span> <span class="keyword">if</span> (iGreetingTime.getHours()&lt;MAX_HOUR_AFTERNOON) {
        <span class="keyword">return</span> GREETING_AFTERNOON;
    }<span class="keyword">else</span> {
        <span class="keyword">return</span> GREETING_EVENING;
    }
  }
}
</code></pre><p>我们需要测试这个类，看是否可以根据时间的不同，来呈现不同的问候语。创建junit的测试用例需要遵循一下几点：</p>
<p>1、Junit类需继承TestCase<br>2、setUp（）和setDown（）为每个方法准备或销毁测试装备<br>3、创建public的方法，方法名为test开头，如testMorningGreeting（），使用assert判断实际返回的值和期望。<br>4、super（testMethod）为每个测试方法生成实例。首先执行setUp()，然后执行testMethod ，最后执行tearDown（）。</p>
<pre><code><span class="keyword">package</span> com.test.test;

<span class="keyword">import</span> java.sql.Time;

<span class="keyword">import</span> com.test.one.Greeting;

<span class="keyword">import</span> junit.framework.TestCase;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>{

    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span>() <span class="keyword">throws</span> Exception {
        <span class="keyword">super</span>.setUp();
    }

    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span>() <span class="keyword">throws</span> Exception{
        <span class="keyword">super</span>.tearDown();
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMorningGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the morning greeting expected"</span>, Greeting.GREETING_MORNING, greeting.getGreeting());
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAfternoonGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the Afternoon greeting expected"</span>, Greeting.GREETING_AFTERNOON, greeting.getGreeting());
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEveningGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the Evening greeting expected"</span>, Greeting.GREETING_EVENING, greeting.getGreeting());
    }

    <span class="keyword">public</span> <span class="title">GreetingTest</span>(String testMethod){
        <span class="keyword">super</span>(testMethod);
    }
}
</code></pre><p>这个只是单个测试用例，junit也提供了测试套件组织想要执行的测试用例。</p>
<p>如果你已经有了两个测试用例，AddJobCmdImpTest、RemoveJobCmdImpTest等TestCase的子类别，如果想一次运行这两个测试，需要使用AllTest的类，代表一个测试套件。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> AllTest {
<span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span>(){
    TestSuite suite = <span class="keyword">new</span> TestSuite(<span class="string">"Test for XXXX"</span>);
    suite.addTest(<span class="keyword">new</span> TestSuite(AddJobCmdImpTest.class));
    suite.addTest(<span class="keyword">new</span> TestSuite(RemoveJobCmdImpTest.class));
    <span class="keyword">return</span> suite;
}
}
</code></pre><p>以下是JUnit4的代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>{

<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span>() <span class="keyword">throws</span> Exception {
    <span class="keyword">super</span>.setUp();

}
<span class="annotation">@After</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span>() <span class="keyword">throws</span> Exception{
    <span class="keyword">super</span>.tearDown();
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ttrestMorningGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the morning greeting expected"</span>, Greeting.GREETING_MORNING, greeting.getGreeting());
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAfternoonGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the Afternoon greeting expected"</span>, Greeting.GREETING_AFTERNOON, greeting.getGreeting());
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEveningGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the Evening greeting expected"</span>, Greeting.GREETING_EVENING, greeting.getGreeting());
}
}
</code></pre><p>关于JUnit4的一些知识点：<br>1）、<strong>注释</strong></p>
<p>@Before    ：用于方法注释，表示该方法在每个测试方法执行前执行一次，可用于一些初始工作<br>@BeforeClass    ：用于方法注释，该方法在所有测试方法运行前运行，且只运行一次，添加该注释的方法必须修饰为 public static void 且没有参数。<br>@Test    ：方法注释，表示测试方法。该方法有两个属性 </p>
<ul>
<li>expected :该属性表示测试方法必须抛出一个异常，且异常的类型必须是该属性要求的类型，否则表示测试方法失败。也叫做异常测试。 例如：@Test(expected=IndexOutOfBoundsException.class) </li>
<li>b:timeout 用于超时测试，表示该测试方法的执行时间如果超过了要求的时间则失败 单位为毫秒<br>例如：@Test(timeout=100)</li>
</ul>
<p>@Ignore    ：方法注释，表示会被忽略的测试方法<br>@After    ：方法注释，被注释的方法会在每个测试方法执行完成之后执行一次，如果其它的方法抛出了异常，该方法同样会被执行。主要用于释放在@Before：方法中初始化的资源。<br>@AfterClass    ：方法注释，功能同@After，只不过是该方法释放的是@BeforeClass ：初始化的资源。且在所有的测试方法执行完成之后，只执行一次。</p>
<p>一个JUnit 4 的单元测试用例执行顺序为：<br>@BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass </p>
<p>2）、<strong>failure 和error</strong><br>　　failure：是由于预期的结果和实际运行结果不同而导致的，例如当使用assertEqual（）或其它assertXXX（）方法断言失败时，就会报出failure，如果发现failure，你就要去检查你的测试方法或者是被测试方法中的填写的逻辑是否有误。简单点，就是预想到的。</p>
<p>　　error：是填写程序是没有考虑到的问题，在执行测试的断言之前，程序就因为某种类型的意外而停止，比如说我们在操作数组的时候，因为存取超出索引就会引发ArrayIndexOutOfBoundsException，这时程序就会报error，程序将无法运行下去，提前结束，这个时候就要检查被测试方法中是否由欠缺考虑的地方。简单点，就是预想不到的，没有执行到断言。</p>
<p>　　JUnit4是JUnit框架有史以来的最大改进，其主要目标便是利用Java5的Annotation特性简化测试用例的编写。Annotation翻译成元数据。元数据是什么？元数据就是描述数据的数据。也就是说，这个东西在Java里面可以用来和public、static等关键字一样来修饰类名、方法名、变量名。修饰的作用描述这个数据是做什么用的，差不多和public描述这个数据是公有的一样。</p>
<p>@Test(expected=*.class)<br>　　在JUnit4.0之前，对错误的测试，我们只能通过fail来产生一个错误，并在try块里面assertTrue（true）来测试。现在，通过@Test元数据中的expected属性。expected属性的值是一个异常的类型</p>
<p>@Test(timeout=xxx):<br>　　该元数据传入了一个时间（毫秒）给测试方法，如果测试方法在制定的时间之内没有运行完，则测试也失败。</p>
<p>@ignore：<br>　　该元数据标记的测试方法在测试中会被忽略。当测试的方法还没有实现，或者测试的方法已经过时，或者在某种条件下才能测试该方法（比如需要一个数据库联接，而在本地测试的时候，数据库并没有连接），那么使用该标签来标示这个方法。同时，你可以为该标签传递一个String的参数，来表明为什么会忽略这个测试方法。比如：@lgnore(“该方法还没有实现”)，在执行的时候，仅会报告该方法没有实现，而不会运行测试方法。</p>
<p>@RunWith(Parameterized.class) 参数化测试。<br>　　你可能遇到过这样的函数，它的参数有许多特殊值，或者说他的参数分为很多个区域。比如，一个对考试分数进行评价的函数，返回值分别为“优秀，良好，一般，及格，不及格”，因此你在编写测试的时候，至少要写5个测试，把这5中情况都包含了，这确实是一件很麻烦的事情。只写一个测试函数，把这若干种情况作为参数传递进去，一次性的完成测试。</p>
<pre><code>@RunWith(Parameterized.class)
public class SquareTest <span class="keyword">...</span>{
    private static Calculator calculator = new Calculator();
    private int param;
    private int result;    
    @Parameters   
    public static Collection data() <span class="keyword">...</span>{
       <span class="keyword">return</span> Arrays.asList(new Object[][]<span class="keyword">...</span>{
            <span class="keyword">...</span>{<span class="number">2</span>, <span class="number">4</span>},
            <span class="keyword">...</span>{<span class="number">0</span>, <span class="number">0</span>},
            <span class="keyword">...</span>{－<span class="number">3</span>, <span class="number">9</span>},
        });
    }
    //构造函数，对变量进行初始化
    public SquareTest(int param, int result) <span class="keyword">...</span>{
        this.param = param;
        this.result = result;
    }
    @Test   
    public void square() <span class="keyword">...</span>{
      　calculator.square(param);
        assertEquals(result, calculator.getResult());
    }
}
</code></pre><p>　　下面我们对上述代码进行分析。<br>　　首先，你要为这种测试专门生成一个新的类，而不能与其他测试共用同一个类，此例中我们定义了一个SquareTest类。然后，你要为这个类指定一个Runner，而不能使用默认的Runner了，因为特殊的功能要用特殊的Runner嘛。@RunWith(Parameterized.class)这条语句就是为这个类指定了一个ParameterizedRunner。<br>　　第二步，定义一个待测试的类，并且定义两个变量，一个用于存放参数，一个用于存放期待的结果。接下来，定义测试数据的集合，也就是上述的data()方法，该方法可以任意命名，但是必须使用@Parameters标注进行修饰。这个方法的框架就不予解释了，大家只需要注意其中的数据，是一个二维数组，数据两两一组，每组中的这两个数据，一个是参数，一个是你预期的结果。比如我们的第一组{2,4}，2就是参数，4就是预期的结果。这两个数据的顺序无所谓，谁前谁后都可以。之后是构造函数，其功能就是对先前定义的两个参数进行初始化。在这里你可要注意一下参数的顺序了，要和上面的数据集合的顺序保持一致。如果前面的顺序是{参数，期待的结果}，那么你构造函数的顺序也要是“构造函数(参数， 期待的结果)”，反之亦然。</p>
<h4 id="打包测试">打包测试</h4>
<p>在一个项目中，只写一个测试类是不可能的，我们会写出很多很多个测试类。可是这些测试类必须一个一个的执行，也是比较麻烦的事情。鉴于此，JUnit提供了打包测试的功能，将所有需要运行的测试类集中起来，一次性的运行完毕，大大的方便了我们的测试工作。具体代码如下：</p>
<pre><code>@RunWith(Suite.class)
@Suite.SuiteClasses(<span class="keyword">...</span>{CalculatorTest.class, SquareTest.class})
public class AllCalculatorTests <span class="keyword">...</span>{}
</code></pre><p>　　大家可以看到，这个功能也需要使用一个特殊的Runner，因此我们需要向@RunWith标注传递一个参数Suite.class。同时，我们还需要另外一个标注@Suite.SuiteClasses，来表明这个类是一个打包测试类。我们把需要打包的类作为参数传递给该标注就可以了。有了这两个标注之后，就已经完整的表达了所有的含义，因此下面的类已经无关紧要，随便起一个类名，内容全部为空既可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>单元测试更多的是在开发阶段完成，开发人员每写一个函数的时候都会写相应的单元测试。对于java代码，普遍使用的是jUnit，根据jUnit可以自己相应的开发一套自动化测试框架。这个的前提是要学会junit，先知道怎么用，才能知道怎么为我所用。</p>
<p>学习JUnit的操]]>
    </summary>
    
      <category term="JUnit" scheme="http://silencewt.github.io/tags/JUnit/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[功能测试用例编写]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99/"/>
    <id>http://silencewt.github.io/2014/12/25/功能测试用例编写/</id>
    <published>2014-12-25T07:42:30.000Z</published>
    <updated>2014-12-25T14:03:44.000Z</updated>
    <content type="html"><![CDATA[<p>由于还不熟悉怎么用markdown来展现表格的内容，若想查看请移步我的博客园：<br><a href="http://www.cnblogs.com/silence-hust/p/4112055.html" target="_blank" rel="external">http://www.cnblogs.com/silence-hust/p/4112055.html</a></p>
<p>感谢大家的关注，我会继续努力的……</p>
<p>下面是幅我很喜欢的图片：人为什么要怎么努力，分享给大家<br>一定要看到最后哦！<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/人为什么要努力1.jpg" alt="人为什么要怎么努力"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于还不熟悉怎么用markdown来展现表格的内容，若想查看请移步我的博客园：<br><a href="http://www.cnblogs.com/silence-hust/p/4112055.html" target="_blank" rel="external">ht]]>
    </summary>
    
      <category term="测试用例" scheme="http://silencewt.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试用例" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[web前端性能测试小点]]></title>
    <link href="http://silencewt.github.io/2014/12/25/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%82%B9/"/>
    <id>http://silencewt.github.io/2014/12/25/web前端性能测试小点/</id>
    <published>2014-12-25T06:57:34.000Z</published>
    <updated>2014-12-25T14:03:35.000Z</updated>
    <content type="html"><![CDATA[<p>关于前端性能的文章：<br> <a href="http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html</a></p>
<p>　　web应用的前端性能响应时间指浏览器的页面加载时间。浏览器的页面加载时间包括对html的解析，对页面图片及css等文件的获取和加载、客户端脚本的执行时间以及对你页面进行展现所花费的时间。这个与并发用户量的大小并没有直接的关系，主要关注：如何提高浏览器下载和执行资源的并发性，如何让浏览器尽快开始渲染页面，如何让浏览器尽可能充分的利用缓存。在yahoo中，到少50个团队通过纯粹的前端性能相关的技巧，将最终用户的响应时间减少了25%以上。<br>　　<br>在了解web前端性能时，我们应该知道http协议。</p>
<p>　　http协议采用请求/响应模型，客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本等信息，服务器以一个状态行作为响应，响应的内容包括消息协议的版本、成功或者错误编码加上包含服务器的信息、实体元信息等内容。该协议是一种非面向连接的协议，每个http请求都是独立的。<br>　　<code>请求报文的格式</code>：请求行 | 通用信息头 | 请求头 | 实体头 | 报文主体   Method     Request-URI  HTTP-versionCRIF<br>　　<code>响应报文的格式</code>：状态行 | 通用信息头 | 响应头 | 实体头 | 报文主体</p>
<p>响应报文的状态码如下：</p>
<blockquote>
<p>1XX：信息响应类，表示接收到请求并继续处<br>2XX：处理成功响应类，表示动作被成功接收、理解和接收<br>3XX：重定向响应类，表示为了完成指定的动作，必须接收进一步处理<br>4XX：客户端错误，表示客户请求包含语法错误或不能正确的执行<br>5XX：服务端错误，表示服务器不能正确执行一个正确的请求</p>
</blockquote>
<p>与前端性能相关的头信息：</p>
<p> 1、accept-encoding：告诉服务器所接受的页面的编码方式，gzip使用gzip压缩，deflate不压缩，压缩可以减少下载所需的时间。</p>
<p>2、connection：因为HTTP是费面向连接的，无状态的协议，每一个HTTP请求都会经过“建立连接—请求页面或资源—获得资源—断开连接”的过程。对于小的资源可能建立连接的时间都会超过对资源的处理时间，为了减少时间引入了持久连接。当浏览器和服务器约定好后，当某个资源传输完成后并不立即断开连接，而是等待一段时间，在这段时间内若传输其他的资源就复用该连接，否则就关闭。当值为keep-alive时有持久连接。</p>
<p>3、expires：用于只是返回数据的到期时间。到期时间之前都是从缓存处直接获取相应的资源，之后才会向服务器发送请求获取。</p>
<p>提高前端性能的方法：</p>
<blockquote>
<p>1、减少页面加载的时间，<br>2、减少网络时间：CDN技术，DNS缓存技术，减少文件的尺寸<br>3、减少发送的请求量：利用浏览器缓存<br>4、让页面尽早的开始显示</p>
</blockquote>
<h4 id="对于前段性能测试的理解：">对于前段性能测试的理解：</h4>
<p>　　由于自己之前有两三个月的时间接触了前端，对于前端的知识点比较熟悉，在这方面理解起来不是很困难，对于http协议，用户响应请求的过程都熟悉，但是那个时候并没有详细的考虑到页面的加载时间问题，只是想着将页面呈现出来，而忽略了对于响应时间的要求。由于自己都是在本机上实现的，所以每次想看结果的时候都要等很久，这就是没有使用性能的思想，去减少页面的加载时间，没有考虑周全。现在对于这方面有了更深的理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于前端性能的文章：<br> <a href="http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html" target="_blank" rel="external">http://www.cnblogs.co]]>
    </summary>
    
      <category term="性能测试" scheme="http://silencewt.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能测试之需求开发]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91/"/>
    <id>http://silencewt.github.io/2014/12/25/性能测试之需求开发/</id>
    <published>2014-12-25T06:54:52.000Z</published>
    <updated>2014-12-25T14:03:42.000Z</updated>
    <content type="html"><![CDATA[<p>以下内容大多来自jackei的博客，只是整理了下，增加了自己的理解。</p>
<h4 id="一个实际的例子：">一个实际的例子：</h4>
<p> 某证券行业系统中某个业务的实际需求<br>1、系统总容量达到日委托6000万笔，成交9000万笔<br>2、 系统处理速度每秒7300笔，峰值处理能力达到每秒10000笔<br>3、实际股东帐号数3000万</p>
<p>从上面例子中可以看出几个明确的需求：<br>1、最佳并发用户数需求：每秒7300笔<br>2、最大并发用户数需求：峰值处理能力达到每秒10000笔<br>3、基础数据容量：实际股东帐号数3000万<br>4、业务数据容量：日委托6000万笔，成交9000万笔——可以根据这个推算出每周、每月、每年系统容量的增长模型</p>
<h4 id="什么是“有效的”性能需求？">什么是“有效的”性能需求？</h4>
<p>　　要想获得有效的性能需求，就要先了解什么样的需求是“有效的”。有效的性能需求应该符合以下三个条件。</p>
<p>1、 明确的数字，而不是模糊的语句。</p>
<p>　　结合上面的例子来看，相信这个应该不难理解。但是有的时候有了数字未必就不模糊。例如常见的一种需求是“系统需要支持5000用户”，或者“最大在线用户数为8000”。这些有数字的需求仍然不够明确，因为还需要考虑区分系统中不同业务模块的负载，以及区分在线用户和并发用户的区别。</p>
<p>2、有凭有据，合理，有实际意义。</p>
<p>　　通常来说，性能需求要么由客户提出，要么由开发方提出。对于第一种情况，要保证需求是合理的，有现实意义的，不能由着客户使劲往高处说，要让客户明白性能是有成本的。对于第二种情况，性能需求不能简单的来源于项目组成员、PM或者测试工程师的估计或者猜测，要保证性能需求的提出是有根据的，所使用的数据和计算公式是有出处的。</p>
<p>3、相关人员达成一致。</p>
<p>　　如果相关人不能对性能需求达成一致，可能测了也白测——特别是在客户没有提出明确的性能需求而由开发方提出时。这里要注意“相关人员”的识别，通常项目型的项目的需要与客户方的项目经理或负责人进行确认，产品型的项目需要与直属领导或者市场部进行确认。如果实在不知道该找谁确认，那就把这个责任交给你的直属领导。</p>
<h4 id="如何获得有效的性能需求：">如何获得有效的性能需求：</h4>
<p>1、 客户方提出<br>　　这是最理想的一种方式，通常电信、金融、保险、证券以及一些其他运营商级系统的客户——特别是国外的客户都会提出比较明确的性能需求。<br>　　<br>2、根据历史数据来分析<br>　　根据客户以往的业务情况来分析客户的业务量以及每年、每月、每周、每天的峰值业务量。如果客户有旧的系统，可以根据已有系统的访问日志，数据库记录，业务报表来分析。要特别注意的是，不同行业、不同应用、不同的业务是有各自的特点的。例如，购物网站在平时的负载主要集中在晚上，但是节假日时访问量和交易量会是平时的数倍；而地铁的售票系统面临的高峰除了周末，还有周一到周五的一早一晚上下班时间。<br>　　<br>3、参考历史项目的数据<br>　　如果该产品已有其他客户使用，并且规模类似的，可以参考其他客户的需求。例如在线购物网站，或者超市管理系统，各行业的进销存系统。<br>　　<br>4、参考其他同行类似项目的数据<br>　　如果本企业没有做过类似的项目，那么可以参考其他同行企业的公布出来的数据——通常在企业公布的新闻或者成功解决方案中会提到，包括系统容量，系统所能承受的负载以及系统响应能力等。<br>　　<br>5、参考其他类似行业应用的数据<br>　　如果无法找打其他同行的数据，也可以参考类似的应用的需求。例如做IPTV或者DVB计费系统的测试，可以参考电信计费系统的需求——虽然不能完全照搬数据，但是可以通过其他行业成熟的需求来了解需要测试的项目有哪些，应该考虑到的情况有哪些种。<br>　　<br>6、参考新闻或其他资料中的数据<br>　　最后的一招，特别是对于一些当前比较引人关注的行业，涉及到所谓的“政绩”的行业，通常可以通过各种新闻媒体找到一些可供参考的数据，但是需要耐心的寻找。例如我们在IPTV和DVB系统的测试中，可以根据新闻中公布的各省、各市，以及国外各大运营商的用户发展情况和用户使用习惯来估算系统容量和系统各个模块的并发量。</p>
<h4 id="性能测试点选取：">性能测试点选取：</h4>
<ul>
<li>发生频率非常高的（例如：某邮箱核心业务系统中的登录、收发邮件等业务，它们在每天的业务总量中占到90%以上）</li>
<li>关键程度非常高的（产品经理认为绝对不能出现问题的，如登录等）</li>
<li>资源占用非常严重的（导致磁盘I/O非常大的，例如某个业务进行结果提交时需要向数十个表存取数据，或者一个查询提交请求时会检索出大量的数据记录）</li>
</ul>
<h4 id="需求获取的小例子：">需求获取的小例子：</h4>
<p>　　去年全年处理“WEB登录”交易约 100 万笔，考虑到 3 年后交易量递增到每年 200万笔。假设每年交易量集中在 8 个月，每个月 20 个工作日，每个工作日 8 小时，试采用 80～20 原理估算系统服务器高峰期“WEB登录”的交易吞吐量应达到怎样的一个处理能力　<br>200万/8=25万/月<br>25万/20=1.25万/日<br>1.25万<em>80%/(8</em>20%*3600)=1.74TPS</p>
<h4 id="关于性能需求的一点补充：">关于性能需求的一点补充：</h4>
<p>　　在软件开发过程中，需求管理要远远简单于需求开发，CMMI中也体现了这一点，并且实际工作中也常常需要我们为客户来开发这部分的性能需求。考虑一下，如何根据客户的实际使用或粗线条的性能要求来开发满足客户需要的性能需求来。就拿例子来说，客户告诉我们“系统总容量达到日委托6000万笔，成交9000万笔；系统处理速度每秒7300笔，峰值处理能力达到每秒10000笔”，那我们将客户的这个要求管理起来并实现了这一点，这叫需求管理；而如果我们根据以下2个假设：<br>　　<br>1、采用2/8比例，即80%的业务在20%的峰值时间内完成，20%的业务在80%的非峰值时间内完成，那么我们可以得到峰值处理业务量1.5亿的80%为1.2亿，非峰值处理业务量1.5亿的20%为3000万；<br>2、1天系统运行时间为20小时，另4小时为非营业的后台处理时间，那么峰值时间20小时的20%为4小时，非峰值时间20小时的80%为16小时。</p>
<p>我们可以计算到：</p>
<p>3、 平均峰值处理速度1.2亿/4*3600秒接近9000个/秒；<br>4、平均非峰值处理速度3000万/16*3600秒约500个/秒；</p>
<p>　　考虑到特殊情况的发生，我们建议实际峰值处理速度要能达到理论计算的平均峰值处理速度的1.5到2倍，所以最终确定下来的建议峰值处理速度为9000个/ 秒*2=18000个/秒。我们拿这个结果向客户说明，告诉他们原来的需求很可能在发生特殊情况时无法有效处理，客户最终接受了我们的说法并调整了他们的需求。<br>　　<br>　　这叫需求开发，通过分析修正了客户的不合理需求，满足了他们最根本的需要”系统总容量达到日委托6000万笔，成交9000万笔”，而处理速度是他们根据自己的需要估算出来的，并不准确。<br>　　<strong>所谓需求开发，也就是根绝客户的核心需求，为客户设计完整的需求体系，甚至根据客户的业务发展需要，为客户设计核心需求和需求体系。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下内容大多来自jackei的博客，只是整理了下，增加了自己的理解。</p>
<h4 id="一个实际的例子：">一个实际的例子：</h4>
<p> 某证券行业系统中某个业务的实际需求<br>1、系统总容量达到日委托6000万笔，成交9000万笔<br>2、 系统处理速度每]]>
    </summary>
    
      <category term="性能测试" scheme="http://silencewt.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
