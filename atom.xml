<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silence 婷婷 Blog]]></title>
  <subtitle><![CDATA[既然选择远方，便风雨兼程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://silencewt.github.io/"/>
  <updated>2015-01-13T08:03:19.989Z</updated>
  <id>http://silencewt.github.io/</id>
  
  <author>
    <name><![CDATA[Wangt]]></name>
    <email><![CDATA[wangt_hust@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[testNG小试牛刀]]></title>
    <link href="http://silencewt.github.io/2015/01/12/testNG%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://silencewt.github.io/2015/01/12/testNG小试牛刀/</id>
    <published>2015-01-12T13:28:22.000Z</published>
    <updated>2015-01-12T13:37:18.000Z</updated>
    <content type="html"><![CDATA[<p>　　testNG是一个测试框架，其灵感来自JUnit和NUnit的，但引入了一些新的功能，使其功能更强大，使用更方便。</p>
<p>　　testNG是一个开源自动化测试框架；testNG表示下一代。 testNG是类似于JUnit（特别是JUnit 4），但它不是一个JUnit扩展。它的灵感来源于JUnit。它的目的是优于JUnit的，尤其是当测试集成的类。 testNG的创造者是Cedric Beust（塞德里克·博伊斯特）</p>
<p>　　testNG消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。 因为它在很大程度上借鉴了Java注解annotation（JDK5.0引入的）来定义的测试，它也可以告诉你如何使用这个新功能在真实的Java语言生产环境中。</p>
<h3 id="testNG的特点：">testNG的特点：</h3>
<ul>
<li>注解</li>
<li>testNG使用Java和面向对象的功能</li>
<li>支持综合类测试（例如，默认情况下，没有必要创建一个新的测试每个测试方法的类的实例）</li>
<li>独立的编译时间测试代码运行时配置/数据信息</li>
<li>灵活的运行时配置</li>
<li>主要介绍“测试组”。当编译测试，只要问testNG运行所有的“前端”的测试，或“快”，“慢”，“数据库”等</li>
<li>支持依赖测试方法，并行测试，负载测试，局部故障</li>
<li>灵活的插件API</li>
<li>支持多线程测试</li>
</ul>
<hr>
<p>　　testNG.xml文件记录了一些非常简单的术语。xml是一个以XML记录所有测试的文件口这个文件能够很容易地在一个文件中描述所有测试套件和它们的参数，可以将它签人到代码库中，或通过电子邮件发送给其他组员。也可以很容易地提取测试的子集，或分成几种运行时配置。这个文件并不是运行testNG所必须的。</p>
<p>　　</p>
<blockquote>
<p>一个suite(套件)由一个或多个测试组成。</p>
<p>一个test(测试)由一个或多个类组成。</p>
<p>一个class(类)由一个或多个方法组成。</p>
</blockquote>
<hr>
<p><strong>testNG相对于junit的一些优点</strong>：</p>
<p>　　1. testNG是一个设计用来简化广泛的测试需求的测试框架，从单元测试到集成测试这个是testNG设计的出发点，不仅仅是单元测试，而且可以用于集成测试。设计目标的不同，对比junit的只适合用于单元测试，testNG无疑走的更远。可以用于集成测试，这个特性是我选择testNG的最重要的原因。</p>
<p>　　2. 测试的过程的三个典型步骤，注意和junit(4.0)相比，多了一个将测试信息添加到testng.xml文件或者build.xml测试信息尤其是测试数据不再写死在测试代码中，好处就是修改测试数据时不需要修改代码/编译了，从而有助于将测试人员引入单元测试/集成测试。</p>
<p>　　3. 基本概念，相比junit的TestCase/TestSuite，TestNG有suite/test/test method三个级别，即将test/test method明确区分开了。</p>
<hr>
<h3 id="基本使用：">基本使用：</h3>
<p><strong>1、异常处理</strong></p>
<p>　　testNG可以简单方便的检测异常的发生，通过@ExpectedExceptions标注预期捕获的异常，当确实发生预期的异常，testNG认为测试通过。也可以指定标注多个异常。</p>
<p><strong>2、失败处理</strong><br>　　当testNG运行的case有失败的时候，会在test-output目录下生成一个testng-failed.xml文件，这对于批量执行测试定位问题很有帮助，testng可以单独执行这些失败的测试。</p>
<p><strong>3、使用参数</strong></p>
<p>　　testNG传参数的两种方式（xml文件，@DataProvider）</p>
<p><strong>使用testng.xml设置参数</strong></p>
<p> 　　参数在xml文件中可以在suite级别定义，也可以在test级别定义；testNG会尝试先在包含当前类的test标签中寻找参数，如果没找到则在上层的suite标签中查找。即在test标签中相同的参数对当前类当前方法的优先级比较高。 testNG支持这种传参方式的类型如下：String、 int/Integer、boolean/Boolean、 byte/Byte、 char/Character、 double/Double、 float/Float、 long/Long、 short/Short。对于非上述类型TestNG无法通过这种方式进行传参，可以通过@DataProvider方式传参</p>
<p> <strong>DataProvider方式传参</strong></p>
<p>　　只提供了一个字符串属性：名称，供测试方法作为传递参数的annotation使用两种DataProvider，一种是返回一个二维数组对象，如上面的例子；另外一种DataProvider是返回一个Iterator，DataProvider可以向测试方法传递任意类型任意数目的参数，利用DataProvider提供不同的参数集合对一个测试方法进行多次调用。</p>
<p><strong>4、Annotation</strong></p>
<p>　　快速预览，这些可以在官方的文档上找到更详细的资料。</p>
<p>　</p>
<blockquote>
<p>@BeforeSuite:        被注释的方法将在所有测试运行前运行 　　<br>@AfterSuite:    　被注释的方法将在所有测试运行后运行<br>@BeforeTest: 　被注释的方法将在测试运行前运行 　　<br>@AfterTest: 　被注释的方法将在测试运行后运行 　　<br>@BeforeGroups:       被配置的方法将在列表中的gourp前运行。这个方法保证在第一个属于这些组的测试方法调用前立即执行。<br>@AfterGroups:     被配置的方法将在列表中的gourp后运行。这个方法保证在最后一个属于这些组的测试方法调用后立即执行。 　　<br>@BeforeClass:    被注释的方法将在当前类的第一个测试方法调用前运行。 　　<br>@AfterClass:       被注释的方法将在当前类的所有测试方法调用后运行<br>@BeforeMethod:        被注释的方法将在每一个测试方法调用前运行。<br>@AfterMethod:        被注释的方法将在每一个测试方法调用后运行。</p>
</blockquote>
<p><strong>5、分组</strong></p>
<p>　　testNG的annotation有分组的功能，这些分组的名称和编号完全由我们自己来决定。@Test（groups={“fast”,”database”}）定义了分组之后可以在排除或者运行某个组。testNG容许执行复杂的测试方法分组。不仅可以申明方法属于组，而且可以指定分组包含其他分组。然后TestNG可以被调用，并被要求包含某些分组和排除其他的分组。这将提供怎样划分测试的最大弹性，并且如果想运行两个不同的测试装置不需要重新编译。</p>
<p><strong>6、依赖</strong></p>
<p>　　有些时候，需要测试方法按照一个特定的顺序被调用。这非常有用，比如：
　　</p>
<ul>
<li><p>在运行更多测试方法前确认特定数量的测试方法调用完成并且成功</p>
</li>
<li><p>初始化测试并希望这个初始化方法也作为测试方法（被标记为@Before/After的方法将不作为最终报告的一部分）</p>
</li>
</ul>
<p>为了做到这点，需要使用@Test注解的dependsOnMethods属性或者dependsOnGroups属性。</p>
<p>这里有两种依赖：</p>
<ul>
<li>强依赖。在运行你的测试方法前所有依赖方法必须运行并且成功。哪怕有一个依赖方法失败，测试方法都不会被调用，在报告中将被标记为SKIP。</li>
<li>软依赖。测试方法在依赖方法运行后总是会被运行，即使某些依赖方法失败。对于只想确认测试方法是按照特定顺序运行，而测试方法并不真正依赖其他方法是否成功的情况下非常有用。软依赖通过在@Test注解中增加”alwaysRun=true”来实现。</li>
</ul>
<hr>
<p>　　除了上面基本的使用之外还有，testNG在并发测试、异步测试和多线程测试方面的应用等等。</p>
<p>关于testng的使用可以参考官方文档：<a href="http://testng.org/doc/documentation-main.html" target="_blank" rel="external">http://testng.org/doc/documentation-main.html</a></p>
<p>这是看了《java测试新技术—testng》这本书的一点记录，虽没有全部理解，但是对于很多部分还是了解理解了。知道有这么个东西。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　testNG是一个测试框架，其灵感来自JUnit和NUnit的，但引入了一些新的功能，使其功能更强大，使用更方便。</p>
<p>　　testNG是一个开源自动化测试框架；testNG表示下一代。 testNG是类似于JUnit（特别是JUnit 4），但它不是一个JU]]>
    </summary>
    
      <category term="testNG" scheme="http://silencewt.github.io/tags/testNG/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(三)--web模块]]></title>
    <link href="http://silencewt.github.io/2015/01/12/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%B8%89-web%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/12/maven小项目注册服务-三-web模块/</id>
    <published>2015-01-12T02:29:10.000Z</published>
    <updated>2015-01-12T03:26:01.000Z</updated>
    <content type="html"><![CDATA[<p>　　java的web应用打包方式一般为war它和jar的区别就是包含了更多的资源和文件，如JSP文件，静态资源文件，servlet等等。war包的核心就WEB-INF文件夹下必须有一个web.xml 的配置文件，子目录classes包含所有该项目的类，子目录lib包含所有的依赖，这两个目录都会在运行的时候添加到classpath下。</p>
<p>　　maven对于web项目有统一的格式。项目代码和资源还是放在src/main/java和src/main/resources下，web资源目录在src/main/webapp/。webapp下就包含WEB-INF，css, js, jsp,等等文件夹。</p>
<p>　　这里account-service模块是综合之前三个模块，提供总的服务，直接看代码。</p>
<h3 id="service模块：">service模块：</h3>
<p> SignUpRequest对应表单的信息：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> SignUpRequest {
<span class="keyword">private</span> String id;

<span class="keyword">private</span> String email;

<span class="keyword">private</span> String name;

<span class="keyword">private</span> String password;

<span class="keyword">private</span> String confirmPassword;

<span class="keyword">private</span> String captchaKey;

<span class="keyword">private</span> String captchaValue;

<span class="keyword">private</span> String activateServiceUrl;

<span class="keyword">public</span> String <span class="title">getId</span>() {
    <span class="keyword">return</span> id;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span>(String id) {
    <span class="keyword">this</span>.id = id;
}

<span class="keyword">public</span> String <span class="title">getEmail</span>() {
    <span class="keyword">return</span> email;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span>(String email) {
    <span class="keyword">this</span>.email = email;
}

<span class="keyword">public</span> String <span class="title">getName</span>() {
    <span class="keyword">return</span> name;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
    <span class="keyword">this</span>.name = name;
}

<span class="keyword">public</span> String <span class="title">getPassword</span>() {
    <span class="keyword">return</span> password;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span>(String password) {
    <span class="keyword">this</span>.password = password;
}

<span class="keyword">public</span> String <span class="title">getConfirmPassword</span>() {
    <span class="keyword">return</span> confirmPassword;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfirmPassword</span>(String confirmPassword) {
    <span class="keyword">this</span>.confirmPassword = confirmPassword;
}

<span class="keyword">public</span> String <span class="title">getCaptchaKey</span>() {
    <span class="keyword">return</span> captchaKey;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaptchaKey</span>(String captchaKey) {
    <span class="keyword">this</span>.captchaKey = captchaKey;
}

<span class="keyword">public</span> String <span class="title">getCaptchaValue</span>() {
    <span class="keyword">return</span> captchaValue;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaptchaValue</span>(String captchaValue) {
    <span class="keyword">this</span>.captchaValue = captchaValue;
}

<span class="keyword">public</span> String <span class="title">getActivateServiceUrl</span>() {
    <span class="keyword">return</span> activateServiceUrl;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActivateServiceUrl</span>(String activateServiceUrl) {
    <span class="keyword">this</span>.activateServiceUrl = activateServiceUrl;
}
}
</code></pre><p>　　<br>接口实现：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>{
String generateCaptchaKey() <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">byte</span>[] generateCaptchaImage(String captchaKey)
    <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> signUp(SignUpRequest signUpRequest) <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> activate(String activationNumber) <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> login(String id, String password) <span class="keyword">throws</span> AccountServiceException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>{
<span class="keyword">private</span> AccountPersistService accountPersist;
<span class="keyword">private</span> AccountEmailService accountEmail;
<span class="keyword">private</span> AccountCaptchaService accountCaptcha;
<span class="keyword">private</span> Map&lt;String, String&gt; activationMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();

<span class="keyword">public</span> AccountPersistService <span class="title">getAccountPersist</span>() {
    <span class="keyword">return</span> accountPersist;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountPersist</span>(AccountPersistService accountPersist) {
    <span class="keyword">this</span>.accountPersist = accountPersist;
}
<span class="keyword">public</span> AccountEmailService <span class="title">getAccountEmail</span>() {
    <span class="keyword">return</span> accountEmail;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountEmail</span>(AccountEmailService accountEmail) {
    <span class="keyword">this</span>.accountEmail = accountEmail;
}
<span class="keyword">public</span> AccountCaptchaService <span class="title">getAccountCaptcha</span>() {
    <span class="keyword">return</span> accountCaptcha;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountCaptcha</span>(AccountCaptchaService accountCaptcha) {
    <span class="keyword">this</span>.accountCaptcha = accountCaptcha;
}
<span class="keyword">public</span> String <span class="title">generateCaptchaKey</span>() <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> accountCaptcha.generateCaptchaKey();
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to generate captcha key"</span>,e);
    }

}
<span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">generateCaptchaImage</span>(String captchaKey)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> accountCaptcha.generateCaptchaImage(captchaKey);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to generate captcha image"</span>,e);
    }

}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signUp</span>(SignUpRequest signUpRequest)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> 
    {
        <span class="keyword">if</span> (!signUpRequest.getPassword().equals(signUpRequest.getConfirmPassword())) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"password donnot match"</span>);
        }

        <span class="keyword">if</span> (!accountCaptcha.validateCaptcha(signUpRequest.getCaptchaKey(), 
                signUpRequest.getCaptchaValue())) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captcha not match"</span>);
        }
        Account account = <span class="keyword">new</span> Account();
        account.setId(signUpRequest.getId());
        account.setEmail(signUpRequest.getEmail());
        account.setName(signUpRequest.getName());
        account.setPassword(signUpRequest.getPassword());
        account.setActivated(<span class="keyword">false</span>);

        accountPersist.createAccount(account);

        String activationId = RandomGenerator.getRandomString();
        activationMap.put(activationId, account.getId());
        String link = signUpRequest.getActivateServiceUrl().endsWith(<span class="string">"/"</span>) ? 
                signUpRequest.getActivateServiceUrl()+activationId : signUpRequest.getActivateServiceUrl()+
                <span class="string">"?key="</span>+activationId;
        accountEmail.sendMail(account.getEmail(), <span class="string">"please activate Your email"</span>, link);

    } <span class="keyword">catch</span> (AccountCaptchaException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to validate captcha"</span>, e);
    } <span class="keyword">catch</span> (AccountEmailException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to send email"</span>, e);
    } <span class="keyword">catch</span> (AccountPersistException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to create account"</span>, e);
    }
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span>(String activationId)
        <span class="keyword">throws</span> AccountServiceException {
    String accountId = activationMap.get(activationId);

    <span class="keyword">if</span> (accountId == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"invalid account activated id"</span>);
    }
    <span class="keyword">try</span> {
        Account account = accountPersist.readAccount(accountId);
        account.setActivated(<span class="keyword">true</span>);
        accountPersist.updateAccount(account);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to activate"</span>);
    }

}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span>(String id, String password)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        Account account = accountPersist.readAccount(id);
        <span class="keyword">if</span> (account == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"account donnot exits"</span>);
        }
        <span class="keyword">if</span> (!account.isActivated()) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"account not activate"</span>);
        }
        <span class="keyword">if</span> (!account.getPassword().equals(password)) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"password is error"</span>);
        }
    } <span class="keyword">catch</span> (AccountPersistException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to logging"</span>, e);
    }
}
}
</code></pre><p>　　注意service的配置文件中pom必须将email、captcha、persist这三个模块包含进去，依赖关系：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-email<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-captcha<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.icegreen<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>greenmail<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${greenmail.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><hr>
<h3 id="account-web模块：">account-web模块：</h3>
<p>pom需要依赖servlet，service模块，其他的配置和一般的maven项目一样。</p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-service<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>

<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><p>  <br>web.xml：定义了一些servlet，具体的servlet实现代码在src/main/java 下。</p>
<pre><code><span class="tag">&lt;<span class="title">web-app</span>&gt;</span>
<span class="tag">&lt;<span class="title">display-name</span>&gt;</span>Sample Maven Project: Account Service<span class="tag">&lt;/<span class="title">display-name</span>&gt;</span>
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
<span class="tag">&lt;<span class="title">context-param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>
        classpath:/account-persist.xml
        classpath:/account-captcha.xml
        classpath:/account-email.xml
        classpath:/account-service.xml
    <span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">context-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>SignUpServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.SignUpServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ActivateServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.ActivateServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.LoginServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/captcha_image<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>SignUpServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/signup<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ActivateServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/activate<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
</code></pre><p><br>　　这个给出其中一个servlet的代码：对用户login的处理。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span>
<span class="keyword">extends</span> <span class="title">HttpServlet</span>
</span>{
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">929160785365121624</span>L;

<span class="keyword">private</span> ApplicationContext context;

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>()
    <span class="keyword">throws</span> ServletException
{
    <span class="keyword">super</span>.init();
    context = WebApplicationContextUtils.getWebApplicationContext( getServletContext() );
}

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span>( HttpServletRequest req, HttpServletResponse resp )
    <span class="keyword">throws</span> ServletException,
        IOException
{
    String id = req.getParameter( <span class="string">"id"</span> );
    String password = req.getParameter( <span class="string">"password"</span> );

    <span class="keyword">if</span> ( id == <span class="keyword">null</span> || id.length() == <span class="number">0</span> || password == <span class="keyword">null</span> || password.length() == <span class="number">0</span> )
    {
        resp.sendError( <span class="number">400</span>, <span class="string">"incomplete parameter"</span> );
        <span class="keyword">return</span>;
    }

    AccountService service = (AccountService) context.getBean( <span class="string">"accountService"</span> );

    <span class="keyword">try</span>
    {
        service.login( id, password );
        resp.getWriter().print( <span class="string">"Login Successful!"</span> );
    }
    <span class="keyword">catch</span> ( AccountServiceException e )
    {
        resp.sendError( <span class="number">400</span>, e.getMessage() );
    }
}
}
</code></pre><p>　　关于jsp界面只有两个：login.jsp和signup.jsp这个对于接触过web 的而言很简单了。</p>
<p>　　基本上这些内容大概就可以说明maven的好处和使用方法了，经过书上的讲解和自己的实际操练，对maven的使用会更加熟悉，当然自己用到的只是maven的皮毛，它的功能可 不仅仅只有这些，这些只是它的核心功能。如果能在实际项目中运用，并去学习的话会对maven有更深的了解，鉴于时间关系，我只能先了解个大概，之后若需要的时候能够快速的使用起来，也希望能在实验室项目中好好的使用这个工具。（有机会和时间的话，尝试重构实验室之前的web项目代码）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　java的web应用打包方式一般为war它和jar的区别就是包含了更多的资源和文件，如JSP文件，静态资源文件，servlet等等。war包的核心就WEB-INF文件夹下必须有一个web.xml 的配置文件，子目录classes包含所有该项目的类，子目录lib包含所有的]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用maven进行测试]]></title>
    <link href="http://silencewt.github.io/2015/01/12/%E7%94%A8maven%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/"/>
    <id>http://silencewt.github.io/2015/01/12/用maven进行测试/</id>
    <published>2015-01-12T02:26:31.000Z</published>
    <updated>2015-01-12T02:28:14.000Z</updated>
    <content type="html"><![CDATA[<p>　　maven的重要职责之一就是自动运行单元测试，它通过maven-surefire-plugin与主流的单元测试框架junit和testng集成，并且能够自动生成丰富的结果报表。</p>
<p>　　maven并不是一个单元测试框架，他只是在构建执行打特定的生命周期阶段的时候，通过插件来执行JUnit或testNG的测试用例，这个插件就是maven-surefire-plugin，也叫做测试运行器。maven-surefire-plugin会自动执行测试源码路劲下（src/test/java）的所有符合以下命名模式的测试用例
　　</p>
<blockquote>
<p>*<em>/Test</em>.java：任何子目录下的所有命名以Test开头的java类</p>
<p>　　*<em>/*</em>Test.java：任何子目录下的所有命名以Test结尾的java类</p>
<p>　　*<em>/*</em>TestCase.java：任何子目录下的所有命名以TestCase结尾的java类</p>
</blockquote>
<p>　　只要将测试类按上述模式命名，maven就能自动运行它们，用户也就不再需要定义测试集合（testsuite）来聚合测试用例了。</p>
<p>　　当然也可以自定义来包含一些不符合上述命名规则的测试类，以下定义以Tests结尾的用例：</p>
<pre><code><span class="variable">&lt;plugin&gt;</span>
  <span class="variable">&lt;groupId&gt;</span>org.apache.maven.plugin<span class="variable">&lt;/groupId&gt;</span>
  <span class="variable">&lt;artifactId&gt;</span>maven-surefire-plugin<span class="variable">&lt;/artifactId&gt;</span>
  <span class="variable">&lt;version&gt;</span>2.5<span class="variable">&lt;version&gt;</span>
  <span class="variable">&lt;configuration&gt;</span>
<span class="variable">&lt;includes&gt;</span>
   <span class="variable">&lt;include&gt;</span><span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>Tests.java<span class="variable">&lt;/include&gt;</span>
<span class="variable">&lt;/includes&gt;</span>
  <span class="variable">&lt;/configuration&gt;</span>
<span class="variable">&lt;/plugin&gt;</span>
</code></pre><p>　　日常工作中，软件开发人员总有很多理由来跳过单元测试，“我敢保证这次改动不会导致任何测试失败，测试运行太耗时了，暂时跳过一，有持续集成服务跑所有测试呢，我本地就不执行啦。在大部分情况下，这想法都是不对的。任何改动都要交给测试去验证，测试运行耗时过长应该考虑优化测试，更不要完全依赖持续集成服务来报告错误，测试错误应该尽早在尽小范围内发现，并及时修复。</p>
<p>　　maven同时也可以通过设置skipTest来跳过测试。</p>
<p><strong>测试报告</strong>：</p>
<p>　　surefire会在target-report下生成两种格式的错误与报告，简单文本格式和支持JUnit的XML格式。</p>
<p><strong>测试覆盖率报告</strong>：</p>
<p>　　cobertura是一个开源的测试覆盖率统计工具，使用时添加插件cobertura-maven-plugin</p>
<p><strong>testng</strong>：</p>
<p>　　可以使用testing.xml的文件，来配置想要运行的测试集合。然后再pom文件里在配置使用该文件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　maven的重要职责之一就是自动运行单元测试，它通过maven-surefire-plugin与主流的单元测试框架junit和testng集成，并且能够自动生成丰富的结果报表。</p>
<p>　　maven并不是一个单元测试框架，他只是在构建执行打特定的生命周期阶段的时]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(二)--captcha模块]]></title>
    <link href="http://silencewt.github.io/2015/01/12/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%BA%8C-captcha%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/12/maven小项目注册服务-二-captcha模块/</id>
    <published>2015-01-12T02:12:05.000Z</published>
    <updated>2015-01-12T02:15:58.000Z</updated>
    <content type="html"><![CDATA[<p>　　验证码生成模块，配置信息基本和前面的模块一样。account-captcha需要提供的服务是生成随机的验证码主键，然后用户可以使用这个主键要求服务生成一个验证码图片，这个图片对应的值应该是随机的，最后用户用肉眼读取图片的值，并将验证码的主键与这个值交给服务进行验证。这一服务对应的接口可以定义如下：</p>
<h3 id="具体代码：">具体代码：</h3>
<pre><code><span class="keyword">public</span> <span class="interface"><span class="keyword">interface</span> AccountCaptchaService </span>{
<span class="comment">//生成主见</span>
    <span class="built_in">String</span> generateCaptchaKey() throws AccountCaptchaException;
    byte[] generateCaptchaImage(<span class="built_in">String</span> captchaKey) throws AccountCaptchaException;
<span class="comment">//验证主键和值</span>
    <span class="built_in">boolean</span> validateCaptcha(<span class="built_in">String</span> captchaKey, <span class="built_in">String</span> captchaValue)throws AccountCaptchaException;
    List&lt;<span class="built_in">String</span>&gt; getPreDefinedTexts();
    <span class="built_in">void</span> setPreDefinedTexts(List&lt;<span class="built_in">String</span>&gt; preDefinedTexts);
}
</code></pre><p>　　额外定义的getPreDefinedText和set方法可以预定义验证码图片的值，提高程序的可预测性。</p>
<p> 　　为你了能够生成随机的验证码主键，定义一个类RandomGenerator如下：</p>
<pre><code>public class <span class="type">RandomGenerator</span> {

private <span class="keyword">static</span> <span class="type">String</span> rangeString = <span class="string">"0123456789qwertyuiopasdfghjklzxcvbnm"</span>;
public <span class="keyword">static</span> synchronized <span class="type">String</span> getRandomString(){
<span class="type">Random</span> random = new <span class="type">Random</span>();
<span class="type">StringBuffer</span> <span class="literal">result</span> = new <span class="type">StringBuffer</span>();
<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
    <span class="literal">result</span>.append(rangeString.charAt(random.nextInt(rangeString.length())));
}
<span class="keyword">return</span> <span class="literal">result</span>.toString();
}
}
</code></pre><p>　　该方法提供了一个线程安全且静态的方法，nextInt（）会放回一个大于等于0且小于n的整数。</p>
<h3 id="接口实现：">接口实现：</h3>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountCaptchaServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountCaptchaService</span>,<span class="title">InitializingBean</span> </span>{

    <span class="keyword">private</span> DefaultKaptcha producer;
    <span class="keyword">private</span> Map&lt;String,String&gt; captchaMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();
    <span class="keyword">private</span> List&lt;String&gt; preDefinedTexts;
    <span class="keyword">private</span> <span class="keyword">int</span> textCount = <span class="number">0</span>;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span>() <span class="keyword">throws</span> Exception {
        producer = <span class="keyword">new</span> DefaultKaptcha();
        producer.setConfig(<span class="keyword">new</span> Config(<span class="keyword">new</span> Properties()));
}

    <span class="keyword">public</span> String <span class="title">generateCaptchaKey</span>() <span class="keyword">throws</span> AccountCaptchaException {
        String key = RandomGenerator.getRandomString();
        String value = getCaptchaText();
        captchaMap.put(key, value);
        <span class="keyword">return</span> key;
    }

    <span class="keyword">private</span> String <span class="title">getCaptchaText</span>() {
        <span class="keyword">if</span>(preDefinedTexts != <span class="keyword">null</span> &amp;&amp; !preDefinedTexts.isEmpty()){
            String text = preDefinedTexts.get(textCount);
            textCount = (textCount+<span class="number">1</span>)%preDefinedTexts.size();
            <span class="keyword">return</span> text;
        }
        <span class="keyword">else</span> {
            <span class="keyword">return</span> producer.createText();
        }

    }

<span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">generateCaptchaImage</span>(String captchaKey)
        <span class="keyword">throws</span> AccountCaptchaException {
    String text = captchaMap.get(captchaKey);
    <span class="keyword">if</span> (text == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captaha key"</span>+captchaKey+<span class="string">"not found"</span>);
    }
    BufferedImage image = producer.createImage(text);
    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();
    <span class="keyword">try</span> {
        ImageIO.write(image,<span class="string">"jpg"</span> , out);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"failed to write image"</span>);
    }
    <span class="keyword">return</span> out.toByteArray();
}

<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateCaptcha</span>(String captchaKey, String captchaValue)
        <span class="keyword">throws</span> AccountCaptchaException {
    String text = captchaMap.get(captchaKey);
    <span class="keyword">if</span> (text == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captaha key"</span>+captchaKey+<span class="string">"not found"</span>);
    }
    <span class="keyword">if</span> (text.equals(captchaValue)) {
        captchaMap.remove(captchaKey);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }<span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

}

<span class="keyword">public</span> List&lt;String&gt; <span class="title">getPreDefinedTexts</span>() {

    <span class="keyword">return</span> preDefinedTexts;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPreDefinedTexts</span>(List&lt;String&gt; preDefinedTexts) {
    <span class="keyword">this</span>.preDefinedTexts = preDefinedTexts;

}

}
</code></pre><p>　　afterPropertiesSet会在framework初始化的时候调用，这个方法初始化验证码生成器，并提供默认配置。</p>
<p>   　generateCaptchaKey()首先生成一个随机的验证码主键，每个主键将和一个验证码字符串相关联，然后这组关联会被存储到中captchaMap以备将来验证。主键的目的仅仅是标识验证码图片，其本身没有实际的意义。getCaptchaText()用来生成验证码字符串，当preDefinedTexts存在或者为空的时候，就是用验证码图片生成器producer创建一个随机的字符串。当preDefinedTexts，不为空的时候，就顺序地循环该字符串列表读取值。preDefinedTexts有其对应的一组get和stet方法，这样就能让用户预定义验证码字符串的值。generateCaptchaImage方法就能通过producer来生成一个Bufferedlmage ,随后的代码将这个图片对象转换成jpg格式的字节数组并返回。有了该字节数组，用户就能随意地将其保存成文件，或者在网页上显示。</p>
<p>　　用户得到了验证码图片以及主键后。就会识别图片中所包含的字符串信息，然后将此验证码的值与主键一起反馈给 validateCaptcha方法以进行验证。</p>
<h3 id="测试代码：">测试代码：</h3>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountCaptchaServiceTest</span> </span>{
<span class="keyword">private</span> AccountCaptchaService service;
<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span>() <span class="keyword">throws</span> Exception{
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_captcha.xml"</span>);
    service = (AccountCaptchaService) ctx.getBean(<span class="string">"accountCaptchaService"</span>);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenerateCaptcha</span>() <span class="keyword">throws</span> Exception{
    String captchaKey = service.generateCaptchaKey();
    assertNotNull(captchaKey);

    <span class="keyword">byte</span>[] captchaImage = service.generateCaptchaImage(captchaKey);
    assertTrue(captchaImage.length&gt;<span class="number">0</span>);

    File image = <span class="keyword">new</span> File(<span class="string">"target"</span>+captchaKey +<span class="string">".jpg"</span>);
    OutputStream output = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        output = <span class="keyword">new</span> FileOutputStream(image);
        output.write(captchaImage);
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span> (output != <span class="keyword">null</span>) {
            output.close();
        }
    }
    assertTrue(image.exists() &amp;&amp; image.length()&gt;<span class="number">0</span>);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValidateCaptchaCorrect</span>() <span class="keyword">throws</span> Exception{
    List&lt;String&gt; preDefinedTexts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    preDefinedTexts.add(<span class="string">"12345"</span>);
    preDefinedTexts.add(<span class="string">"abcde"</span>);
    service.setPreDefinedTexts(preDefinedTexts);
    String captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertTrue(service.validateCaptcha(captchaKey, <span class="string">"12345"</span>));
    captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertTrue(service.validateCaptcha(captchaKey, <span class="string">"abcde"</span>));
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValidateCaptchaIncorrect</span>()
        <span class="keyword">throws</span> Exception
{
    List&lt;String&gt; preDefinedTexts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    preDefinedTexts.add(<span class="string">"12345"</span>);
    service.setPreDefinedTexts(preDefinedTexts);
    String captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertFalse(service.validateCaptcha(captchaKey, <span class="string">"67809"</span>));
}
}
</code></pre><p>　　</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomGeneratorTest</span> </span>{
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetRandomTest</span>() <span class="keyword">throws</span> Exception{
    Set&lt;String&gt; randoms = <span class="keyword">new</span> HashSet&lt;String&gt;(<span class="number">100</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
        String random = RandomGenerator.getRandomString();
        assertFalse(randoms.contains(random));
        randoms.add(random);
    }

}
}
</code></pre><p>　　这个测试代码比较容易看懂。运行测试后可以在项目的target目录下看到生成的验证码图片。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　验证码生成模块，配置信息基本和前面的模块一样。account-captcha需要提供的服务是生成随机的验证码主键，然后用户可以使用这个主键要求服务生成一个验证码图片，这个图片对应的值应该是随机的，最后用户用肉眼读取图片的值，并将验证码的主键与这个值交给服务进行验证。这一]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(一)--email和persist模块]]></title>
    <link href="http://silencewt.github.io/2015/01/11/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%B8%80-email%E5%92%8Cpersist%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/11/maven小项目注册服务-一-email和persist模块/</id>
    <published>2015-01-11T01:32:06.000Z</published>
    <updated>2015-01-11T01:38:29.000Z</updated>
    <content type="html"><![CDATA[<p>跟着书里的讲解，跟着做了一遍该项目：</p>
<p>首先明白注册账户的需求：</p>
<p>　　账号的lD和Email地址都可以用来唯一地标识某个用户，而显示名称则用来显示在页面下，方便浏览。注册的时候用户还需要输入两次密码，以确保没有输错，系统则需要负责检查ID和email的唯一性，验证两次输入的密码是否一致，验证码是由系统随机生成的只能由肉眼识别其内容的图片，若输入正确的验证码信息，系统则会进行检查，如果验证码错误。系统会生成并返回新的验证码。所有检查都没问题了，系统就会生成一个激活链接，并发送到用户的邮箱。单击激活链接后，账户就被激活了，这时账户注册完成，用户可以进行登录。对于一个账户注册服务，还需要考虑一些安全因素，例如，需要在服务器端密文地保存密码，检查密码的强弱程度，更进一步则需要考虑验证码的失效时间，激活链接的失效时间等等。</p>
<p><strong>需求用例</strong>：</p>
<p><strong>主要场景</strong>：</p>
<p>1、用户访问注册页面</p>
<p>2、系统随机生成验证码图片</p>
<p>3、用户输入ID、Email等注册信息</p>
<p>4、输入验证码</p>
<p>5、提交注册请求</p>
<p>6、系统检查验证码、检查ID的唯一性，检查邮箱是否已被注册、密码和确认密码是否一致</p>
<p>7、系统保存未激活的账户信息</p>
<p>8、系统生成激活连接，发送给用户邮箱</p>
<p>9、用户打开邮箱，访问激活链接</p>
<p>10、系统解析激活连接，激活相关用户</p>
<p>11、用户使用ID和密码登陆</p>
<p><strong>扩展场景：</strong></p>
<p>4a：用户无法看清验证码，请求重新生成    1、跳转到2</p>
<p>6a：系统检测到用户输入的验证码有误        1、提示验证码有错，2、跳转到2</p>
<p>6b：检测到 ID已被注册，邮箱，密码有误    1、提示错误信息，2、跳转到2</p>
<p>从上面可以看出该服务有几个接口：生成验证码图片、处理注册请求、激活账户以及处理登陆请求。</p>
<p><strong>接口结构：</strong></p>
<p>acountService类：<br>generateCaptchaKey()<br>generateCaptchaImage(captchakey:string)<br>signUp(signUpRequest:SignUpRequest)：接收对象，进行验证。如果验证正确。则创建一个末被激活的账户，同时在后台也需要发送一封带有激活链接的邮件。<br>activate(activationNumber:string)：方法接收一个激活码，查找时应的账户进行激活<br>login(id:string,password:string)<br>signUpRequest：包含用户的注册信息，表单信息：id、Email、displayName、password、comfirmpassword、captchaKey、captchaValue。<br>generateCaptchaKey()的简单解释就是验证码，每个captcha都需要有一个key ,根据这个key ,系统才能得到对应的验证码图片以及实际值。因此，generateCaptchaImage会生成一个captchakey使用这个key再调用generateCaptchaImage方法就能得到验证码图片。验证码的key以及验证码图片被传送到客户端，用户通过肉眼识别再输人验证码的值，伴随着key再传送到服务器端验证，服务器端就可以通过这个key查到正确的验证码值，井与客户端传过来的值进行比对验证。</p>
<p><strong>模块划分：</strong></p>
<p>com.hust.silence.accout.service：系统的核心，它封装了所有下层细节，对外暴露简单的接日，这实际上是一个Facade模式。<br>com.hust.silence.accout.web：该模块包含所有与web相关的内容，包括jsp等，直接依赖于service模块<br>com.hust.silence.accout.persist：处理账户信息的持久化，包括增、删、改、查等，根据实现，可以基于数据库或者文件<br>com.hust.silence.accout.captcha：处理验证码的key生成、图片生成以及验证等<br>com.hust.silence.accout.email： 处理邮件服务的配置，激活邮件的编写和发送等</p>
<p><strong>配置pom.xml</strong><br>加入需要的各种spring framework的模块，Greenmail是开源的邮件服务套件，Javax.mail为实现发送的一个类库。从上面的信息我们可以知道，该项目时是com.hust.silence的一个account项目，项目里有一个模块为account-email。</p>
<hr>
<h4 id="实现Email模块："><strong>实现Email模块</strong>：</h4>
<p>account-email只有一个很简单的接口。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountEmailService</span> </span>{
        <span class="keyword">void</span> sendMail(String to, String subject, String htmlText) <span class="keyword">throws</span> AccountEmailException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountEmailService</span></span>{
<span class="keyword">private</span> JavaMailSender javaMailSender;
<span class="keyword">private</span> String systemEmail;

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span>(String to, String subject, String htmlText)
        <span class="keyword">throws</span> AccountEmailException {
    <span class="comment">// TODO Auto-generated method stub</span>
    <span class="keyword">try</span> {
        MimeMessage msg = javaMailSender.createMimeMessage();
        MimeMessageHelper msgHelper = <span class="keyword">new</span> MimeMessageHelper(msg);
        msgHelper.setFrom(systemEmail);
        msgHelper.setTo(to);
        msgHelper.setSubject(subject);
        msgHelper.setText(htmlText);
        javaMailSender.send(msg);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="comment">// TODO: handle exception</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountEmailException(<span class="string">"fail to send mail"</span>,e);
    }
}
<span class="comment">//实现依赖注入</span>
<span class="keyword">public</span> JavaMailSender <span class="title">getJavaMailSender</span>(){
    <span class="keyword">return</span> javaMailSender;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJavaMailSender</span>(JavaMailSender javaMailSender){
    <span class="keyword">this</span>.javaMailSender = javaMailSender;
}
<span class="keyword">public</span> String <span class="title">getSystemEmail</span>(){
    <span class="keyword">return</span> systemEmail;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystememail</span>(String systemEmail){
    <span class="keyword">this</span>.systemEmail = systemEmail;
}
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>{
<span class="javadoc">/**
 *
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6514881539290222459</span>L;
<span class="keyword">public</span> <span class="title">AccountEmailException</span>(String message) {
    <span class="keyword">super</span>(message);
}
<span class="keyword">public</span> <span class="title">AccountEmailException</span>(String message, Throwable throwable){
    <span class="keyword">super</span>(message, throwable);
}
}
</code></pre><p><strong>配置文件</strong>：<br><strong>id=”propertyConfigurer”</strong>：这是springframework用来帮助载入properties文件的组件，代码中表示从classpath的根目录下载入名为account-email.properties文件中的属性。<br><strong>id=”javaMailSender”</strong>：定义邮件服务器的一些配置.包括协议、端口、主机，用户名、密码，是否需要认证等属性。这段配置还使用了propertyConfigurer的属性引用，比如host的值为$ { email.host }。之前定义的propertyConfigurer作用就在于此、可以将邮件服务器相关的配置分离到外部的properties文件中，比如可以定义这样一个properties文件。配置javaMailSender使用163：</p>
<p>account-email.properties（在src/test/resources文件夹里）：<br>email.protocol=smtp<br>email.host=smtp.163.com<br>email.port=25<br>email.username=test@163.com<br>email.password=password<br>email.auth=true<br>email.systemEmail=test@163.com</p>
<p><strong>测试</strong>：</p>
<p>只需要测试一个sendMail（）接口，这个就需要准备properties文件，配置并启用一个测试使用的邮件服务器，准备好后，就调用该接口实现邮件发送，然后检查是否发送成功，关闭测试邮件服务器。具体代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailServiceTest</span> </span>{
<span class="keyword">private</span> GreenMail greenMail;

<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMailServer</span>() <span class="keyword">throws</span> Exception{
    greenMail = <span class="keyword">new</span> GreenMail(ServerSetup.SMTP);
    greenMail.setUser(<span class="string">"1219611916@qq.com"</span>, <span class="string">"silence"</span>);
    greenMail.start();
}

<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMail</span>() <span class="keyword">throws</span> Exception{
    <span class="comment">//根据account。xml创建一个spring framework的ApplicationContext</span>
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_email.xml"</span>);
    <span class="comment">//从ctx中获取需要测试的ID为accountEmailService的bean并转换成AccountEmailService接口，</span>
    <span class="comment">//针对接口的测试是最好的单元测试的实现</span>
    AccountEmailService accout = (AccountEmailService)ctx.getBean(<span class="string">"accountEmailService"</span>);
    String subject = <span class="string">"Test Subject"</span>;
    String htmlText = <span class="string">"&lt;h3&gt;test&lt;/h3&gt;"</span>;
    accout.sendMail(<span class="string">"1219611916@qq.com"</span>, subject, htmlText);
    greenMail.waitForIncomingEmail(<span class="number">2000</span>, <span class="number">1</span>);
    Message[] mags = greenMail.getReceivedMessages();
    assertEquals(<span class="number">1</span>,mags.length);
    assertEquals(subject, mags[<span class="number">0</span>].getSubject());
    assertEquals(htmlText, GreenMailUtil.getBody(mags[<span class="number">0</span>]).trim());
}

<span class="annotation">@After</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMailServer</span>() <span class="keyword">throws</span> Exception{
    greenMail.stop();
}
}
</code></pre><hr>
<h4 id="实现persist模块：">实现persist模块：</h4>
<p>该模块负责账户数据的持久化，以XML文件的形式保存账户数据，井支持账户的创建、读取、更新、删除等操作。</p>
<p>配置代码：</p>
<pre><code>  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.hust.silence.account<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
 <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">name</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="title">url</span>&gt;</span>

  <span class="tag">&lt;<span class="title">properties</span>&gt;</span>
<span class="tag">&lt;<span class="title">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="title">project.build.sourceEncoding</span>&gt;</span>
<span class="tag">&lt;<span class="title">dom4j.version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">dom4j.version</span>&gt;</span>
<span class="tag">&lt;<span class="title">springframework.version</span>&gt;</span>2.5.6<span class="tag">&lt;/<span class="title">springframework.version</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">properties</span>&gt;</span>

  <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">test</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${dom4j.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>

  <span class="tag">&lt;<span class="title">build</span>&gt;</span>
<span class="tag">&lt;<span class="title">testResources</span>&gt;</span>
    <span class="tag">&lt;<span class="title">testResource</span>&gt;</span>
        <span class="tag">&lt;<span class="title">directory</span>&gt;</span>src/test/resources<span class="tag">&lt;/<span class="title">directory</span>&gt;</span>
        <span class="tag">&lt;<span class="title">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="title">filtering</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">testResource</span>&gt;</span>
<span class="tag">&lt;/<span class="title">testResources</span>&gt;</span>
<span class="tag">&lt;<span class="title">plugins</span>&gt;</span>
    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
            <span class="tag">&lt;<span class="title">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="title">encoding</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span>
<span class="tag">&lt;/<span class="title">plugins</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">build</span>&gt;</span>
<span class="tag">&lt;/<span class="title">project</span>&gt;</span> 　
</code></pre><p>dom4j是支持XML操作的，build元素包含testresource是开启资源过滤的，在单元测试中用到。</p>
<p>具体代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountPersistService</span> </span>{
Account createAccount(Account account) <span class="keyword">throws</span> AccountPersistException;
Account readAccount(String id) <span class="keyword">throws</span> AccountPersistException;
Account updateAccount(Account account) <span class="keyword">throws</span> AccountPersistException;
<span class="keyword">void</span> deleteAccount(String id) <span class="keyword">throws</span> AccountPersistException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountPersistServiceImpl</span>
<span class="keyword">implements</span> <span class="title">AccountPersistService</span>
</span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ROOT = <span class="string">"account-persist"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNTS = <span class="string">"accounts"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT = <span class="string">"account"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_ID = <span class="string">"id"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_NAME = <span class="string">"name"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_EMAIL = <span class="string">"email"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_PASSWORD = <span class="string">"password"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_ACTIVATED = <span class="string">"activated"</span>;

    <span class="keyword">private</span> String file;

    <span class="keyword">private</span> SAXReader reader = <span class="keyword">new</span> SAXReader();

    <span class="keyword">public</span> String <span class="title">getFile</span>()
    {
        <span class="keyword">return</span> file;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFile</span>( String file )
    {
        <span class="keyword">this</span>.file = file;
    }

    <span class="keyword">public</span> Account <span class="title">createAccount</span>( Account account )
        <span class="keyword">throws</span> AccountPersistException
    {
        Document doc = readDocument();

        Element accountsEle = doc.getRootElement().element(ELEMENT_ACCOUNTS);

        accountsEle.add( buildAccountElement( account ) );

        writeDocument( doc );

        <span class="keyword">return</span> account;
    }

<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span>( String id )
    <span class="keyword">throws</span> AccountPersistException
{
    Document doc = readDocument();

    Element accountsEle = doc.getRootElement().element( ELEMENT_ACCOUNTS );

    <span class="keyword">for</span> ( Element accountEle : (List&lt;Element&gt;) accountsEle.elements() )
    {
        <span class="keyword">if</span> ( accountEle.elementText( ELEMENT_ACCOUNT_ID ).equals( id ) )
        {
            accountEle.detach();

            writeDocument( doc );

            <span class="keyword">return</span>;
        }
    }
}

<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
<span class="keyword">public</span> Account <span class="title">readAccount</span>( String id )
    <span class="keyword">throws</span> AccountPersistException
{
    Document doc = readDocument();

    Element accountsEle = doc.getRootElement().element( ELEMENT_ACCOUNTS );

    <span class="keyword">for</span> ( Element accountEle : (List&lt;Element&gt;) accountsEle.elements() )
    {
        <span class="keyword">if</span> ( accountEle.elementText( ELEMENT_ACCOUNT_ID ).equals( id ) )
        {
            <span class="keyword">return</span> buildAccount( accountEle );
        }
    }

    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">public</span> Account <span class="title">updateAccount</span>( Account account )
    <span class="keyword">throws</span> AccountPersistException
{
    <span class="keyword">if</span> ( readAccount( account.getId() ) != <span class="keyword">null</span> )
    {
        deleteAccount( account.getId() );

        <span class="keyword">return</span> createAccount ( account );
    }

    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">private</span> Account <span class="title">buildAccount</span>( Element element )
{
    Account account = <span class="keyword">new</span> Account();

    account.setId( element.elementText( ELEMENT_ACCOUNT_ID ) );
    account.setName( element.elementText( ELEMENT_ACCOUNT_NAME ) );
    account.setEmail( element.elementText( ELEMENT_ACCOUNT_EMAIL ) );
    account.setPassword( element.elementText( ELEMENT_ACCOUNT_PASSWORD ) );
    account.setActivated( ( <span class="string">"true"</span>.equals( element.elementText( ELEMENT_ACCOUNT_ACTIVATED ) ) ? <span class="keyword">true</span> : <span class="keyword">false</span> ) );

    <span class="keyword">return</span> account;
}

<span class="keyword">private</span> Element <span class="title">buildAccountElement</span>( Account account )
{
    Element element = DocumentFactory.getInstance().createElement( ELEMENT_ACCOUNT );

    element.addElement( ELEMENT_ACCOUNT_ID ).setText( account.getId() );
    element.addElement( ELEMENT_ACCOUNT_NAME ).setText( account.getName() );
    element.addElement( ELEMENT_ACCOUNT_EMAIL ).setText( account.getEmail() );
    element.addElement( ELEMENT_ACCOUNT_PASSWORD ).setText( account.getPassword() );
    element.addElement( ELEMENT_ACCOUNT_ACTIVATED ).setText( account.isActivated() ? <span class="string">"true"</span> : <span class="string">"false"</span> );

    <span class="keyword">return</span> element;
}

<span class="keyword">private</span> Document <span class="title">readDocument</span>()
    <span class="keyword">throws</span> AccountPersistException
{
    File dataFile = <span class="keyword">new</span> File( file );

    <span class="keyword">if</span>( !dataFile.exists() )
    {
        dataFile.getParentFile().mkdirs();

        Document doc = DocumentFactory.getInstance().createDocument();

        Element rootEle = doc.addElement( ELEMENT_ROOT );

        rootEle.addElement( ELEMENT_ACCOUNTS );

        writeDocument( doc );
    }

    <span class="keyword">try</span>
    {
        <span class="keyword">return</span> reader.read( <span class="keyword">new</span> File( file ) );
    }
    <span class="keyword">catch</span> ( DocumentException e )
    {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to read persist data xml"</span>, e );
    }
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeDocument</span>( Document doc )
    <span class="keyword">throws</span> AccountPersistException
{
    Writer out = <span class="keyword">null</span>;

    <span class="keyword">try</span>
    {
        out = <span class="keyword">new</span> OutputStreamWriter( <span class="keyword">new</span> FileOutputStream( file ), <span class="string">"utf-8"</span> );

        XMLWriter writer = <span class="keyword">new</span> XMLWriter( out, OutputFormat.createPrettyPrint() );

        writer.write( doc );
    }
    <span class="keyword">catch</span> ( IOException e )
    {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to write persist data xml"</span>, e );
    }
    <span class="keyword">finally</span>
    {
        <span class="keyword">try</span>
        {
            <span class="keyword">if</span> ( out != <span class="keyword">null</span>)
            {
                out.close();
            }
        }
        <span class="keyword">catch</span> ( IOException e )
        {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to close persist data xml writer"</span>, e );
        }
    }
}
}
</code></pre><p>Account是一个简单的类：对变量的读取和设置</p>
<p>private String id;<br>private String name;<br>private String email;<br>private String password;<br>private boolean activated;　</p>
<p>　　该测试用例遵守了测试接口而不测试实现这一原则:也就是说，测试代码不能引用实现类，由于测试是从接口用户的角度编写的，这样就能保证接口的用户无须知晓接口的实现细节，既保证了代码的解藕，也促进了代码的设计。</p>
<p> 测试代码：这里只给出了读取readAccount的test</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountPersistServiceTest</span> </span>{
<span class="keyword">private</span> AccountPersistService service;
<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span>() <span class="keyword">throws</span> Exception{
    File persistDataFile = <span class="keyword">new</span> File(<span class="string">"target/persist-classes/persist_data.xml"</span>);
    <span class="keyword">if</span>(persistDataFile.exists()){
        persistDataFile.delete();
    }
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_persist.xml"</span>);
    service = (AccountPersistService) ctx.getBean(<span class="string">"accountPersistService"</span>);
    Account account = <span class="keyword">new</span> Account();
    account.setId(<span class="string">"ww"</span>);
    account.setName(<span class="string">"wwss"</span>);
    account.setEmail(<span class="string">"16@qq.com"</span>);
    account.setPassword(<span class="string">"####"</span>);
    account.setActivated(<span class="keyword">true</span>);
    service.createAccount(account);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadAccount</span>() <span class="keyword">throws</span> Exception{
    Account account = service.readAccount(<span class="string">"ww"</span>);
    assertEquals(<span class="string">"ww"</span>,account.getId());
    assertEquals(<span class="string">"wwss"</span>,account.getName());
    assertEquals(<span class="string">"126@qq.com"</span>,account.getEmail());
    assertEquals(<span class="string">"####"</span>,account.getPassword());
    assertTrue(account.isActivated());
}
}
</code></pre><p>　　想要将上面的代码单个模块运行成功，还需要给出相应的配置文件，xml文件放在src/main/resources下，properties文件放在src/test/resources。尤其是这里只给出了相应的两个模块的代码，有兴趣的可以继续写完成。<br>account_email.properties:<br>email.protocol=smtp<br>email.host=”127.0.0.1”<br>email.port=”25”<br>email.username=16@qq.com<br>email.password=####<br>email.auth=true<br>email.systemEmail=16@qq.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>跟着书里的讲解，跟着做了一遍该项目：</p>
<p>首先明白注册账户的需求：</p>
<p>　　账号的lD和Email地址都可以用来唯一地标识某个用户，而显示名称则用来显示在页面下，方便浏览。注册的时候用户还需要输入两次密码，以确保没有输错，系统则需要负责检查ID和emai]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014图灵技术图书最受欢迎TOP15]]></title>
    <link href="http://silencewt.github.io/2015/01/09/2014%E5%9B%BE%E7%81%B5%E6%8A%80%E6%9C%AF%E5%9B%BE%E4%B9%A6%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8ETOP15/"/>
    <id>http://silencewt.github.io/2015/01/09/2014图灵技术图书最受欢迎TOP15/</id>
    <published>2015-01-09T01:12:34.000Z</published>
    <updated>2015-01-09T01:22:26.000Z</updated>
    <content type="html"><![CDATA[<p>来自：图灵社区昨晚给我发的邮件，感觉不错，和大家分享，mark下。</p>
<p>【小编语】 回首2014，感谢小伙伴们一路相随。让我们2015一起更快乐地玩耍。今天小编为大家盘点一下过去2014年表现最给力的技术图书，它们受到了小伙伴们的一致认可。大家一起阅读下吧~</p>
<p><strong>1、Python基础教程（第2版·修订版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook1.jpg" alt="tulin1"></p>
<p>Python入门第一书</p>
<p>全面详尽，10个项目引人入胜</p>
<p><strong>2、iOS开发指南：从零基础到App Store上架（第2版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook2.jpg" alt="图林2"></p>
<p>数百个项目案例 + 两个真实项目开发全过程</p>
<p>iOS开发者推荐图书，免费视频学习更轻松</p>
<p><strong>3、JavaScript高级程序设计（第3版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook3.jpg" alt="图林3"></p>
<p>JavaScript进阶首选</p>
<p>全能前端人员必读经典</p>
<p><strong>4、深入浅出Node.js</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook4.jpg" alt="图林4"></p>
<p>阿里巴巴一线Node开发者朴灵巨献</p>
<p>深度讲解Node.js</p>
<p><strong>5、啊哈！算法</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook5.jpg" alt="图林5"></p>
<p>萌系算法第一书</p>
<p>充满趣味和智慧，人人都能看懂</p>
<p><strong>6、机器学习实战</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook6.jpg" alt="图林6"></p>
<p>使用Python阐述机器学习第一书</p>
<p>实例经典，循序渐进</p>
<p><strong>7、CCNA学习指南：路由和交换认证（100-101，200-101，200-120）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook7.jpg" alt="图林7"></p>
<p>首屈一指的CCNA应试宝典</p>
<p>针对思科认证最新考纲编写</p>
<p><strong>8、Objective-C基础教程（第2版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook8.jpg" alt="图林8"></p>
<p>全面系统讲述Objective-C基础知识和面向对象编程</p>
<p>作者均为苹果顶级开发高手</p>
<p><strong>9、R语言实战</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook9.jpg" alt="图林9"> </p>
<p>全面详尽的R语言指南</p>
<p>畅销多年，广受好评</p>
<p><strong>10、Android编程权威指南</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook10.jpg" alt="图林10"><br>原版亚马逊Android畅销第一书</p>
<p>国际知名移动训练营Big Nerd Ranch出品</p>
<p><strong>11、第一行代码——Android</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook11.jpg" alt="图林11"></p>
<p>国内最受欢迎的Android入门书</p>
<p>CSDN超人气博主郭霖力作</p>
<p><strong>12、图解HTTP</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook12.jpg" alt="图林12"></p>
<p>最简单易读的HTTP入门书</p>
<p>涵盖基础知识、最新动向<br><strong>13、图解TCP/IP（第5版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook13.jpg" alt="图林13"></p>
<p>原版畅销36万册</p>
<p>TCP/IP圣经级教材<br><strong>14、大数据：互联网大规模数据挖掘与分布式处理</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook14.jpg" alt="图林14"></p>
<p>全球著名数据库技术专家力作</p>
<p>理论与实际算法实现并重</p>
<p><strong>15、Java性能优化权威指南</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook16.jpg" alt="图林15"></p>
<p>Java性能优化圣经</p>
<p>Java之父重磅推荐</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来自：图灵社区昨晚给我发的邮件，感觉不错，和大家分享，mark下。</p>
<p>【小编语】 回首2014，感谢小伙伴们一路相随。让我们2015一起更快乐地玩耍。今天小编为大家盘点一下过去2014年表现最给力的技术图书，它们受到了小伙伴们的一致认可。大家一起阅读下吧~</p]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://silencewt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小试牛刀]]></title>
    <link href="http://silencewt.github.io/2015/01/09/maven%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://silencewt.github.io/2015/01/09/maven小试牛刀/</id>
    <published>2015-01-09T01:07:34.000Z</published>
    <updated>2015-01-09T01:27:43.000Z</updated>
    <content type="html"><![CDATA[<p>　　Maven是一个采用纯Java编写的开源项目管理工具。Maven采用了一种被称之为project object model (POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，构建，测试，发布，报告等等。目前Apache下绝大多数项目都已经采用Maven进行管理。而Maven本身还支持多种插件，可以方便更灵活的控制项目。
　　</p>
<hr>
<h3 id="构建">构建</h3>
<p>　　理解maven的第一步我们需要知道构建是什么？《maven实战》这本书里写的很清楚，早上我们会从代码库里签出最新的代码，然后进行单元测试，如果发现bug就会找同事一起解决，之后回到自己的工作上，编写单元测试或者产品代码，然后测试，午饭后可能会需要开个会，汇报工作进度，查看测试报告那么就需要用IDE使用相关的工具集成，生成报告给经理查看，也可能QA发来了几个bug,于是熟练地用IDE生成了一个WAR包，部署到Web容器下，启动容器。看到熟悉的界面了，遵循bug报告，一步步重现了bug。。。修改好bug，提交代码，通知QA，下班。就会发现，在一天的工作中，我们出了编写代码就是在编译，运行生成文档，打包和部署等烦琐且不起眼的工作上，这就是构建。如果手工这样做，那成本也太高了，于是有人用软件的方法让这一系列工作完全自动化，使得软件的构建可以像全自动流水线一样，只需要一条简单的命令，所有烦琐的步骤都能够自动完成，很快就能得到最终结果。</p>
<p>　　Maven的用途之一是服务于构建，它是一个异常强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。我们要做的是使用Maven配置好项目，然后输入简单的命令(如mvn clean install)，Maven会帮我们处理那些烦琐的任务。Maven是跨平台的，无论是在Windows上，还是在Linux或者Mac上，都可以使用同样的命令。maven 能最大化的消除重复的构建，我们不需要去定义繁琐的构建过程，只要在maven里配置好相关的信息就好。最简单的例子是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编写好测试用例，当我们运行构建的时候，这些测试便会自动运行。maven可以帮助标准化构建过程，有了Maven之后，所有项目的构建命令都是简单一致的，这极大地避免了不必要的学习成本，而且有利于促进项目团队的标准化。Maven作为一个构建工具，不仅能帮我们自动化构建，还能够抽象构建过程，提供构建任务实现；它跨平台，对外提供了一致的操作接口，这一切足以使它成为优秀的、流行的构建工具。</p>
<p>　　maven不仅仅是一个构建工具，他还是一个依赖管理工具和项目信息管理工具，它提供了中央仓库，可以帮我们自动的下载构件。比如在使用javaweb开发是，会用到各种的第三方的库或者框架，这些类库都可以通过依赖的方式注入到项目中，随着依赖的增多，版本的不一致，版本的兼容性，臃肿的问题就会出现。每次手工的解决这些问题会很烦躁，maven就提供了一个优秀的解决方案，它通过一个坐标系统准确地定位每一个构件（artifact），也就是通过一组坐标Maven能够找到任何一个Java类库（如jar文件）。Maven给这个类库世界引入了经纬，让它们变得有秩序，于是我们可以借助它来有序地管理依赖，轻松地解决那些繁杂的依赖问题。</p>
<p>　　Maven还能帮助我们管理原本分散在项目中各个角落的项目信息，包括项目描述、开发者列表、版本控制系统地址、许可证、缺陷管理系统地址等。这些微小的变化看起来很琐碎，并不起眼，但却在不知不觉中为我们节省了大量寻找信息的时间。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，我们还能够轻松获得项目文档、测试报告、静态分析报告、源码版本日志报告等非常具有价值的项目信息。</p>
<h4 id="maven与IDE的比较：">maven与IDE的比较：</h4>
<p>　　IDE虽然提高了编码的效率，但IDE依赖大量的手工操作。编译、测试、代码生成等工作都是相互独立的，很难一键完成所有工作。手工劳动往往意味着低效，意味着容易出错。</p>
<p>　　很难在项目中统一所有的IDE配置，每个人都有自己的喜好。也正是由于这个原因，一个在机器A上可以成功运行的任务，到了机器B的IDE中可能就会失败。</p>
<p>　　我们应该合理利用IDE，而不是过多地依赖它。对于构建这样的任务，在IDE中一次次地点击鼠标是愚蠢的行为。Maven是这方面的专家，而且主流IDE都集成了Maven，我们可以在IDE中方便地运行Maven执行构建。</p>
<h4 id="maven于ant的区别：">maven于ant的区别：</h4>
<p>　　ant意指“另一个整洁的工具”（Another Neat Tool），它最早用来构建著名的Tomcat。可以将Ant看成是一个Java版本的Make，也正因为使用了Java，Ant是跨平台的。此外，Ant使用XML定义构建脚本build.xml。Ant是没有依赖管理的，所以很长一段时间Ant用户都不得不手工管理依赖，现在可以借助Ivy管理依赖。而Maven内置了依赖管理。
　　</p>
<hr>
<h4 id="使用maven的情况：">使用maven的情况：</h4>
<p>　　比如你是一个小软件公司的程序员，他所在的公司要开发一个新的Web项目。经过协商，决定使用Spring、iBatis和Tapstry。jar包去哪里找呢？公司里估计没有人能把Spring、iBatis和Tapstry所使用的jar包一个不少地找出来。大家的做法是，先到Spring的站点上去找一个spring.with.dependencies，然后去iBatis的网站上把所有列出来的jar包下载下来，对Tapstry、Apache commons等执行同样的操作。项目还没有开始，WEB.INF/lib下已经有近百个jar包了，带版本号的、不带版本号的、有用的、没用的、相冲突的，怎一个“乱”字了得！  在项目开发过程中，不时地会发现版本错误和版本冲突问题，这时只能硬着头皮逐一解决。项目开发到一半，经理发现最终部署的应用的体积实在太大了，要求去掉一些没用的jar包，于是只能加班加点地一个个删…… 这时就会想，要是能有一个系统或者框架来管理这些依赖就好了， 这时maven就发挥到作用了。</p>
<p>　　<em>书籍看到这里，让我想起大四的时候进来实验室时的一个项目，就是基于SSH框架的某公司管理系统，当时，在搭建环境的时候就需要一天的时候（网络卡），到不同的网站去下不同的jar包，和安装不同的框架，期间出错了几次，为了避免在次出错自己就手动的备份了所有资料，单独列了一个清单，记录各个依赖的版本。现在回过头来看，如果当时师兄师姐使用这个来构建项目的话，会有多轻松啊。实验室所学到的东西确实是有限的，很多新技术没有跟不上社会的变化。</em></p>
<hr>
<h3 id="maven与极限编程">maven与极限编程</h3>
<p>　　maven能很好的使用极限编程XP的一些实践当中去测试驱动开发（TDD）。TDD强调测试先行，所有产品都应该由测试用例覆盖。而测试是Maven生命周期的最重要的组成部分之一，并且Maven有现成的成熟插件支持业界流行的测试框架，如JUnit和TestNG。</p>
<p>　　<strong>十分钟构建</strong>。十分钟构建强调我们能够随时快速地从源码构建出最终的产品。这正是Maven所擅长的，只需要一些配置，之后用一条简单的命令就能让Maven帮你清理、编译、测试、打包、部署，然后得到最终的产品。</p>
<p>　　<strong>持续集成（CI）</strong>。CI强调项目以很短的周期（如15分钟）集成最新的代码。实际上,CI的前提是源码管理系统和构建系统。</p>
<p>　　在传统的瀑布模型开发中，项目依次要经历需求开发、分析、设计、编码、测试和集成发布阶段。从设计和编码阶段开始，就可以使用Maven来建立项目的构建系统。在设计阶段，也完全可以针对设计开发测试用例，然后再编写代码来满足这些测试用例。然而，有了自动化构建系统，我们可以节省很多手动的测试时间。此外，尽早地使用构建系统集成团队的代码，对项目也是百利而无一害。最后，Maven还能帮助我们快速地发布项目。</p>
<hr>
<h3 id="maven安装：">maven安装：</h3>
<p>　　最新的eclipse中集成的是3.2.1的maven，为了和命令行一起使用，我在插件里面使用3.2.5的，本机上安装的也是3.2.5，这个只要在eclipse里面设置一下就好了。当然也可以设置回去的。
　　</p>
<hr>
<h3 id="maven使用">maven使用</h3>
<h4 id="（一）_生成pom">（一） 生成pom</h4>
<p> 　　pom.xml文件是maven对一个项目的核心配置，这个文件将包含你希望如何构建项目的大多数配置信息，用于描述项目如何构建，声明项目依赖，等等。虽然很难列出一张非常全面的表，但在此可先列出最普通的默认的生命周期阶段：</p>
<p>　　<strong>validate</strong>：验证工程是否正确，所有需要的资源是否可用。<br>　　<strong>compile</strong>：编译项目的源代码。<br>　　<strong>test</strong>：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。<br>　　<strong>Package</strong>：把已编译的代码打包成可发布的格式，比如jar。<br>　　<strong>integration-test</strong>：如有需要，将包处理和发布到一个能够进行集成测试的环境。<br>　　<strong>verify</strong>：运行所有检查，验证包是否有效且达到质量标准。<br>　　<strong>install</strong>：把包安装在本地的repository中，可以被其他工程作为依赖来使用。<br>　　<strong>Deploy</strong>：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。<br>　　<strong>clean</strong>：清除先前构建的artifacts（在maven中，把由项目生成的包都叫作artifact）。<br>　　<strong>site</strong>：为项目生成文档站点。</p>
<p>　　首先创建一个空文件夹，在改文件夹里新建一个文佳pom.xml，配置文件，具体内容为：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span>
     <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
           <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.silence<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">name</span>&gt;</span>Maven Hello World Project<span class="tag">&lt;/<span class="title">name</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">project</span>&gt;</span>  
</code></pre><p>　　第二行：project元素，这是pom.xml的根元素，声明pom相关的命名空间，这里面的属性可以让我们的IDE跟快速的编辑pom第一行：制定了该xml文档的版本和编码方式。<br>　　第六行：根元素下的第一个子元素modelVersion指定了当前POM模型的版本，对于Maven2及Maven 3来说，它只能是4.0.0。<br>　　第7行到9行是最重要的代码段，groupId，artifactId和version这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者war都是以基于这些基本的坐标进行区分的。<br>　　<br>　　<strong>groupId</strong>定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联，譬如你在googlecode上建立了一个名为myapp的项目，那么groupId就应该是com.googlecode.myapp，如果你的公司是mycom，有一个项目为myapp，那么groupId就应该是com.mycom.myapp。<br>　　<br>　　<strong>artifactId</strong>定义了当前Maven项目在组中唯一的ID，我们为这个Hello World项目定义artifactId为hello-world，本书其他章节代码会被分配其他的artifactId。而在前面的groupId为com.googlecode.myapp的例子中，你可能会为不同的子项目（模块）分配artifactId，如：myapp-util、myapp-domain、myapp-web等等。</p>
<p>　　<strong>version</strong>指定了Hello World项目当前的版本——1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。随着项目的发展，version会不断更新，如升级为1.0、1.1-SNAPSHOT、1.1、2.0等等。</p>
<p>　　第十行：name元素声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但我还是推荐为每个POM声明name，以方便信息交流。</p>
<h4 id="（二）编写主代码">（二）编写主代码</h4>
<p> 　　项目主代码和测试代码不同，项目的主代码会被打包到最终的构件中（比如jar），而测试代码只在运行测试时用到，不会被打包。默认情况下，Maven假设项目主代码位于src/main/java目录，我们遵循Maven的约定，创建该目录，然后在该目录下创建文件com/juvenxu/mvnbook/helloworld/HelloWorld.java，<br> 　　写好这个之后，可以回到项目根目录下，运行mvn clean compile就可以生成编译java文件，生成对应的class文件</p>
<h4 id="（三）测试代码">（三）测试代码</h4>
<p>　　Maven项目中默认的测试代码目录是src/test/java。com/juvenxu/mvnbook/helloworld/testHelloWorld.java要有测试代码得为Hello World项目添加一个JUnit依赖，即在pom.xml中添加<dependencies>元素；</dependencies></p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span> 
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</code></pre><p>　　</p>
<p>　　第6行：scope为依赖范围，若依赖范围为test则表示该依赖只对测试有效，换句话说，测试代码中的import JUnit代码是没有问题的，但是如果我们在主代码中用import JUnit代码，就会造成编译错误。如果不声明依赖范围，那么默认值就是compile，表示该依赖对主代码和测试代码都有效。有了这段声明，Maven就能够自动从中央仓库（<a href="http://repo1.maven.org/maven2/）里下载junit-4.7.jar。" target="_blank" rel="external">http://repo1.maven.org/maven2/）里下载junit-4.7.jar。</a></p>
<h4 id="（四）执行">（四）执行</h4>
<p>　　mvn clean compile、mvn clean test（测试）、mvn clean package（打包）、mvn clean install（安装）。执行test之前是会先执行compile的，执行package之前是会先执行test的，而类似地，install之前会执行package。</p>
<p> 　　命令行输入的是mvn clean test，而maven实际执行的可不止这两个任务，还有clean:clean、resources:resources、compiler:compile、resources:testResources以及compiler:testCompile。暂时我们需要了解的是，在Maven执行测试（test）之前，它会先自动执行项目主资源处理，主代码编译，测试资源处理，测试代码编译等工作，这是Maven生命周期的一个特性。</p>
<h4 id="（五）简单的原型Archetype">（五）简单的原型Archetype</h4>
<p>　　可以快速的生成项目骨架，避免每次都一个个的创建文件夹，可以执行mvn archetype:generate，也可以在eclipse中选择。当然也可以根据自己的需要开发使用自定义的archetype来快速生成项目骨架。</p>
<hr>
<h3 id="maven坐标">maven坐标</h3>
<p>　　为了能自动的解析任何一个java构件，maven就将他们用坐标唯一标识，坐标元素包括:groupId,artifactId,version,packaging,classifier，只要设置这几个元素就可以很轻松地从中央仓库那儿获得对应的构件。前三天上面有介绍过，这里说说packaging：定义maven的打包方式，一般为jar（默认），当然也可以是war行的，最终会生成war的文件。classifier：帮助定义构建输出的一些附属构件。如某项目的主构件是nexus-index-2.0.0.jar，可能还会有nexus-index-2.0.0-Javadoc.jar和nexus-index-2.0.0-sources.jar这样一些附属构件（java文档和源代码），这里javadoc和sources就是这两个附属构件的classifier,这样附属的构件也会有自己唯一的坐标。</p>
<hr>
<h3 id="maven依赖">maven依赖</h3>
<p>　　每个依赖包含的元素有：groupId、artifactId、version还有type：<br>　　<strong>scope</strong>：依赖范围。用来控制依赖与这三种classpath的关系（编译classpath、运行classpath、测试classpath），如果没有指定依赖范围则默认使用compile，在编译、运行和测试的时候都需要用到该依赖。test则只对测试classpath有效，在编译主代码和运行项目的时候不会包含进去。runtime运行时的依赖，对测试运行有效，在编译主代码时无效。其实，还有provided和system两种。</p>
<p>　　<strong>optional</strong>：标记依赖是否可选，比如项目A依赖于项目B，B依赖于X和Y（XY可选的），根基依赖传递性，ＸＹ会是A的传递性依赖，但是由于XY是可选的，那么依赖不会传递，XY对A不会有影响。也就是说XY只对B起作用，不会被传递，如果A中需要XY则需要显示的声明。这个并不推荐，最好的方式就是排除依赖。可以使用maven命令分析依赖关系：mvn dependency:analyze</p>
<p>　　<strong>exclusions</strong>：用来排除传递性依赖maven引人的传递性依赖机制。一方面大大简化和方便了依赖声明。另一方面，大部分情况下我们只需要关心项目的直接依赖是什么，而不用考虑这些直接依赖会引人什么传递性依赖。但有时候，当传递性依赖造成问题的时候，我们就需要清楚地知道该传递性依赖是从哪条依赖路径引人的。这个可以以后遇到了在了解。</p>
<hr>
<h4 id="依赖范围">依赖范围</h4>
<p>　　就是用来控制依赖与这三种classpath(编译classpath、测试classpath、运行classpath)的关系，Maven有以下几种依赖范围：</p>
<p>　　<strong>compile</strong>: 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。</p>
<p>　　<strong>test</strong>:测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子就是JUnit，它只有在编译测试代码及运行测试的时候才需要。</p>
<p>　　<strong>provided:</strong> 已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。</p>
<p>　　<strong>runtime:</strong> 运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</p>
<p>　　<strong>system:</strong> 系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量</p>
<hr>
<h3 id="maven仓库">maven仓库</h3>
<p>　　简单来说就是，maven依赖构件存放的地方，所有的依赖构件都从仓库里下载，除了本地的项目依赖。maven有提供一个中央仓库，里面有各种开源的构件，可很方便的从上面获得。当然，这个仓库是远程的，也可以在本地设置一个私服，Nexus就是一个流行的开源maven仓库管理软件。现在我只需要使用仓库里的就可以了，没必要去建立私服。此处略过。</p>
<hr>
<h3 id="maven生命周期和插件：">maven生命周期和插件：</h3>
<p> 　　maven的生命周期就是为了对所有的构建过程进行抽象和统一，从大量项目和构建工具中学习和反思，然后总结了一套高度完善的、易扩展的生命周期。这个生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。也就是说，几乎所有项目的构建，都能映射到这样一个生命周期上。</p>
<p> 　　在maven的设计中，实际的任务(如编译源代码)都交由插件来完成。这种思想与设计模式中的模板方法非常相似。模板方法模式在父类中定义算法的整体结构，子类可以通过实现或者重写父类的方法来控制实际的行为，这样既保证了算法有足够的可扩展性，又能够严格控制算法的整体结构。</p>
<p>　　这本书里写的很清楚：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> AbstractBuild{
<span class="keyword">public</span> <span class="keyword">void</span> Build（）{
    initialize（）；
    compile（）；
    test（）；
    packagee（）；
    integrate（）；
    deploy（）；
}
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> initialize（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> compile（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> test（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> packagee（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> integrate（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> deploy（）；
}
</code></pre><p>　　生命周期抽象了构建的各个步骤，定义它们的次序，但没有提供具体实现，那么谁来实现这些步骤呢？不能有用户为了编译而写一堆代码。为测试又写一堆代码，那么就在重复发明轮子了?maven考虑了，因此设计插件机制。每个构建步骤都可以绑定一个或者多个插件行为，而maven为大多数构建步骤编写并绑定了默认插件。插件完成具体的任务，是实现着。maven有自动绑定的插件，当然也可以自定义绑定，在pom中设置build plugins plugin属性。 </p>
<p>　　maven有三套独立的生命周期：clean（清理项目）、default（构建项目）、site（建立项目站点）。每个生命周期都有几个阶段，这些阶段是有顺序的，调用后面的阶段时，必须先调用前面的阶段。我们从命令行执行maven命令就是在调用其生命周期阶段，比如：mvn clean：就是执行pre-clean和clean阶段。mvn test：执行default周期的validate、initialize……直到test阶段。mvn clean install：就是clean阶段加上default周期的直到install阶段。</p>
<hr>
<h3 id="maven聚合和继承">maven聚合和继承</h3>
<p>　　我们通常会将不一个项目分成不同的模块向，注册服务会分成persist，service等模块，maven的聚合特性能够把项日的各个模块聚合在一起构建，而maven继承特性则能帮助抽取各模块相同的依赖和插件等配置。在众多模块中，不可能对每个项目都进行构建，执行maven命令，会想用一个命令就运行几个模块的内容，为了能够一条命令就构建两个模块，需要在额外的创建一个account-aggregato模块，然后通过该模块构建整个项目的所有模块。对于聚合模块来说，pom.xml中的打包方式必须为pom,否则就无法构建。各个模块可以放在聚合模块目录下，即和pom同一个目录，聚合模块是项目目录的最顶层，其他莫快则作为其子目录存在。这个并不是唯一的，子模块也可以和聚合模块平行。</p>
<p>　　多模块项目中，各模块中会有很多相同的groupID和version，相同的spring依赖，和plugin配置。这就是重复，重复往往以为着更</p>
<p>　　更多的劳动和更多的潜在的问题。在面向对象世界中，程序员可以使用类继承在一定程度上消除重复，在maven的世界中，也有类似的机制能让我们抽取出重复的配置，这就是POM的继承。需要创建POM的斧子结构，然后在父POM中声明一些配置供子POM继承。以实现一处声明，多处使用的目的。</p>
<p>　　<strong>聚合的目的：快速构建项目</strong><br>　　<strong>继承的目的：消除重复配置</strong></p>
<hr>
<p>参考书籍：《maven实战》 <a href="http://hzbook.group.iteye.com/group/wiki/2872-Maven-in-action" target="_blank" rel="external">http://hzbook.group.iteye.com/group/wiki/2872-Maven-in-action</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　Maven是一个采用纯Java编写的开源项目管理工具。Maven采用了一种被称之为project object model (POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合文章系列汇总]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E6%96%87%E7%AB%A0%E7%B3%BB%E5%88%97%E6%B1%87%E6%80%BB/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合文章系列汇总/</id>
    <published>2014-12-30T06:41:27.000Z</published>
    <updated>2014-12-30T06:51:58.000Z</updated>
    <content type="html"><![CDATA[<p>　　这是实验室项目的资料汇总，一方面便于自己整理，理清思路，另一方面让大家对图像融合有个大概的了解。以后项目还没有完结，以后还会有所补充。</p>
<p>图像融合文章系列汇总：</p>
<p><a href="http://silencewt.github.io/2014/12/29/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E6%A6%82%E8%BF%B0/" target="_blank" rel="external">图像融合（一）— 概述</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E7%AE%80%E5%8D%95%E5%8A%A0%E6%9D%83%E8%9E%8D%E5%90%88/" target="_blank" rel="external">图像融合（二）— 简单加权融合</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（三）— 拉普拉斯金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%AF%B9%E6%AF%94%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（四）— 对比度金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89-%E6%A2%AF%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（五）— 梯度金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89-%E5%B0%8F%E6%B3%A2%E8%9E%8D%E5%90%88/" target="_blank" rel="external">图像融合（六）— 小波融合</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这是实验室项目的资料汇总，一方面便于自己整理，理清思路，另一方面让大家对图像融合有个大概的了解。以后项目还没有完结，以后还会有所补充。</p>
<p>图像融合文章系列汇总：</p>
<p><a href="http://silencewt.github.io/2014/]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（六）-- 小波融合]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89-%E5%B0%8F%E6%B3%A2%E8%9E%8D%E5%90%88/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（六）-小波融合/</id>
    <published>2014-12-30T05:47:21.000Z</published>
    <updated>2014-12-30T06:35:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="基于小波的融合（wavelet）">基于小波的融合（wavelet）</h3>
<p>　　小波变换的固有特性使其在图像处理中有如下优点：完善的重构能力，保证信号在分解过程中没有信息损失和冗余信息；把图像分解成平均图像和细节图像的组合，分别代表了图像的不同结构，因此容易提取原始图像的结构信息和细节信息；小波分析提供了与人类视觉系统方向相吻合的选择性图像。</p>
<p>　　离散小波变换(Discrete Wavelet Transform, DWT)。DWT的函数基由一个称为母小波或分析小波的单一函数通过膨胀和平移获得。因而，DWT同时具有时域和频域分析能力，与一般的金字塔分解相比，DWT图像分解具有以下优势：</p>
<ol>
<li>具有方向性，在提取图像低频信息的同时，还可获得了水平、垂直和对角三个方向的高频信息；</li>
<li>通过合理的选择母小波，可使DWT在压缩噪声的同时更有效的提取纹理、边缘等显著信息；</li>
<li>金字塔分解各尺度之间具有信息的相关性，而DWT在不同尺度上具有更高的独立性。</li>
</ol>
<p>DWT融合算法基本思想与金字塔算法一致，即：首先对源图像进行小波变换，然后按照一定规则对变换系数进行合并；最后对合并后的系数进行小波逆变换得到融合图像。由于不具有移不变性，基于DWT的标准小波融合算法获取的融合图像通常会存在“振铃”干扰;特别在处理连续的图像序列时，融合结果会出现明显的闪烁和抖动现象。</p>
<h4 id="1、原理阐述">1、原理阐述</h4>
<p>　　（1）小波的简单计算原理</p>
<p>　　 [x0，x1，x2，x3]=[90，70，100，70] 为达到压缩 我们可取 (x0+x1)/2  (x0-x1)/2 来代表 x0,x1  这样 [90,70] 可表示为 [80,10] 80即平均数 10是小范围波动数（可想象出一种波的形状） [90,70] —〉[80,10] , [100,70] —〉 [85,15] 可以想象80 和85 都是局部的平均值反映大的总体的状态，是变化相对缓慢的值，可以认为他们是低频部分的值。 而10、15是小范围波动的值局部变换较快，可以认为他们是高频部分的值。</p>
<p>　　1、 FIRST：把[90,70,100,70] 写成 [80,85,10,15] 即把低频部分写在一起（记频率L） 高频部分写在一起（H) </p>
<p>　　2、 SECOND：而[80,85] 又可经同样的变换—&gt; [82.5, -2.5] 这样 82.5表示更低频的信息(记频率LL) -2.5则表示了频率L上的波动 </p>
<p>　　3、最后[90,70,100,70] —〉[82.5, -2.5, 10, 15] 这样信息就可被压缩了（数字范围小了）</p>
<p>　　现在再来扩展一下  [90,70]—-&gt; [80,10] 写成矩阵 [90,70] * [1/2, 1/2]<br>[1/2 ,-1/2] 矩阵[1,1；1,-1]/2为haar转换矩阵。</p>
<p>　　如果是[90,70,100,70]第一步就可以写成矩阵M1：[0.5,0,0.5,0; 0.5,0,-0.5,0; 0,0.5,0,0.5;0,0.5,0,-0.5]，第二步只对低频L操作，高频不变可写成M2：[1/2,  1/2, 0, 0; 1/2, -1/2, 0, 0; 0,  0,  1, 0 ;0,  0,  0, 1]。另M= M1<em>M2，可得到4</em>4的点阵操作。</p>
<p>　　第一步运算后原图像缩小至左边一半了，右边的是对应波动信息；</p>
<p>　　第二步运算后图像又缩小至左边一半了，对应波动信息。</p>
<p>　　对一幅图像先进行行变化，在进行列变化，那么就是小波变化了。</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.1.png" alt="wave1"></p>
<p>　　LL：水平低频，垂直低频</p>
<p>　　LH：水平低频，垂直高频</p>
<p>　　HL：水平高频，垂直低频</p>
<p>　　HH：水平高频，垂直高频</p>
<p>　　其中，L表示低频，H表示高频，下标1、2表示一级或二级分解。在每一分解层上，图像均被分解为LL，LH，HH和HL四个频带，下一层的分解仅对低频分量LL进行分解。这四个子图像中的每一个都是由原图与一个小波基函数的内积后，再经过在x和y方向都进行2倍的间隔采样而生成的。这是正变换，也就是图像的分解；逆变换，也就是图像的重建。是通过图像的增频采样和卷积来实现的。这里有个问题进过处理后，数据或超出255或者出现负数，需要将其归一化到0-255之间，方可显示图像。这里介绍的只是简单的小波计算，小波计算的而不同就在于选取不同的小波系数，一般有haar小波，sym2小波等。</p>
<p>资料：<a href="http://www.blogbus.com/shijuanfeng-logs/221385402.html" target="_blank" rel="external">http://www.blogbus.com/shijuanfeng-logs/221385402.html</a></p>
<h4 id="2、融合规则">2、融合规则</h4>
<p><strong>规则一</strong>：系数绝对值较大法</p>
<p>　　该融合规则适合高频成分比较丰富，亮度、对比度比较高的源图像，否则在融合图像中只保留一幅源图像的特征，其他的特征被覆盖。小波变换的实际作用是对信号解相关，并将信号的全部信息集中到一部分具有大幅值的小波系数中。这些大的小波系数含有的能量远比小系数含有的能量大，从而在信号的重构中，大的系数比小的系数更重要。</p>
<p><strong>规则二</strong>：加权平均法</p>
<p>　　权重系数可调，适用范围广，可消除部分噪声，源图像信息损失较少，但会造成图像对比度的下降，需要增强图像灰度。</p>
<p><strong>规则三</strong>：局部方差准则</p>
<p>　　设A(x,y)和B(x,y)分别为高频子图像数据值，F(x,y)为相应高频子图像融合值，将A(x,y)和B(x,y)分成若干个M×N子块图像。对每个子块图像进行数值分布统计，计算其方差。确定A和B图像每个子块图像加权系数K1和K2。如果A图像子块方差大于B图像子块方差,则K1≥K2，否则K1&lt;K2。确定每个子块图像的数据融合数值为：F(i,j)=K1A(i,j)+K2B(i,j)。</p>
<h4 id="3、融合应用">3、融合应用</h4>
<p>　　若对二维图像进行N层的小波分解,最终将有(3N+1)个高低频带，其中包含3N个高频带和一个低频带。图像融合的基本步骤如下。</p>
<p>　　1）对每一源图像分别进行小波分解，建立图像的小波金字塔分解。</p>
<p>　　2）对各分解层分别进行融合处理，采用不同的融合算子对各分解层的不同频率分量进行融合处理，最终得到融合后的小波金字塔。低频：加权平均，高频：绝对值取大。</p>
<p>　　3）对融合后所得的小波金字塔进行小波逆变换，所得到的重构图像即为融合后的图像。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.2.png" alt="wave2"></p>
<p>　　图像的低频部表现的是图像的概貌和平均特性；图像的高频反应的是图像的细节特性，如图像的边缘、区域边界等。</p>
<p>　　融合规则：</p>
<p>　　基于局部方差的融合规则：在邻域W中，图像I在以（i ，j)为中心点的局部方差定义：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.3.png" alt="wave3"></p>
<p>　　式中为图像I 的均值，M，N 分别为局部区域的行数和列数，这里取局部区域为3*3，基于局部方差的融合方式常用的方法是选择法，即通常说的局部方差取大法。方差选择法的融合规则<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.4.png" alt="wave4"></p>
<p>　　L为分解尺度， 表示图像小波系数，<img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.5.png" alt="wave5"> 表示图像小波系数， =d=H,V,D分别表示的是水平、垂直、对角高频分量。如果两幅图片直接使用局部方差法进行融合，局部方差相差较大时，采用局部方差取大法能够比较完整的存储图像的微小细节。一旦局部方差相差很小时，局部方差取大法会使图像细节失真。</p>
<p>　　图像融合有一个重要的目的，即将图像的边缘、细节等都包含到融合图像中。一种方法是将图像的边缘提取出来，将它应用到相应的融合算法中。图像边缘检测的最好的算子是 canny 算子，将canny算子和局部方差的融合规则的算法相结合，提出了一种新的改进融合方法。融合步骤如下：</p>
<p>　　（1）小波分解。对于图像 A，B 分别进行 3 层小波分解，得到低频分量AA、AB和高频分量DLH，DLV，DLD。</p>
<p>　　（2）低频融合。对低频分量AA 和AB 所有的像素点计算其局部方差Var(i ,j)AA和 Var(i ,j)BA，然后进行归一化：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.6.png" alt="wave6"></p>
<p>　　然后，利用归一化的局部方差，按照如下：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.7.png" alt="wave7"></p>
<p>　　（3）高频融合。在图像 A 和 B 的每一个高频分DLA，DLB中，对每一个高频分量用 canny 算子进行边缘提取，再对边缘图像的每一个元素计算局部方差：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.8.png" alt="wave8"></p>
<p>　　其中 <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.9.png" alt="wave9"><br>表示源图像的第l层经 canny 算子处理的高频系数 <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.10.png" alt="wave10">为源图像的第l层经 canny 算子提取后的均值。<img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.11.png" alt="wave11"> 是对源图像的第l层高频分量进行边缘提取后求得的局部方差。<br> <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.12.png" alt="wave12"></p>
<p>　　（4）小波重构。对融合后的系数进行小波重构，得到融合后的图像。</p>
<p>　　附：这里介绍的小波是最简单的形式，融合规则也比较常用，很多红外和可见的融合也都用到了这里的规则，所以，实现这里面的算法来适用我们的应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="基于小波的融合（wavelet）">基于小波的融合（wavelet）</h3>
<p>　　小波变换的固有特性使其在图像处理中有如下优点：完善的重构能力，保证信号在分解过程中没有信息损失和冗余信息；把图像分解成平均图像和细节图像的组合，分别代表了图像的不同结构，因此]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（五）-- 梯度金字塔]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89-%E6%A2%AF%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（五）-梯度金字塔/</id>
    <published>2014-12-30T05:14:35.000Z</published>
    <updated>2014-12-30T05:34:53.000Z</updated>
    <content type="html"><![CDATA[<p>　　基于梯度金字塔(Gradient Pyramid,GP)分解的图像融合算法。GP 也是一种基于高斯金字塔的多尺度分解算法。通过对高斯金字塔每层图像进行梯度算子运算，便可获得图像的 GP表示。GP 每层分解图像都包含水平、垂直和两个对角线四个方向的细节信息，能更好地提取出图像的边缘信息，提高了稳定性和抗噪性。具有方向性的梯度塔形分解能够很好地提供图像的方向边缘和细节信息。</p>
<p>1、<strong>原理阐述</strong><br>（1）得到高斯金字塔（如上）</p>
<p>（2）对图像高斯金字塔的各分解层（最高层除外）分别进行梯度方向滤波，便可得到梯度塔形分解：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.1.png" alt="Gradius1"></p>
<p>　　这里•为卷积运算，DL K表示第L层第k方向梯度塔形图像，GL 为图像的高斯金字塔的第L层图像，dK表示第k方向梯度滤波算子，定义为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.2.png" alt="gradius2"></p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.3.png" alt="gradius3"></p>
<p>　　经过 d1、d2、d3、d4对高斯金字塔各层进行方向梯度滤波，在每一分解层上（最高层除外）均可得到包含水平、垂直以及两个对角线方向细节信息的4个分解图像。可见图像的梯度塔形分解不仅是多尺度、多分辨率分解，而且每一分解层（最高层除外）又由分别包含 4个方向细节信息的图像组成。</p>
<p>　　这里跟上面不同的就是每一层是独立的，不需要涉及到上一层的上采样结果。对应层的Gl与3*3的核做卷积，在加上Gl的值之后取相应方向的值，就可以生成对应方向的系数了。</p>
<p>   （3）重构</p>
<p>　　对金字塔图像每一层各方向分别融合后，就需要由梯度金字塔重构原图像，须引入FSD 拉普拉斯金字塔作为中间结果，即将梯度金字塔转换为拉普拉斯金字塔，再由拉普拉斯金字塔重构原图像，其构建过程如下：</p>
<p>　　1、将方向梯度金字塔转换为方向拉普拉斯金字塔（FSD型）filter-subtract-decimate。设 FSD型金字塔的第L层图像为LL，<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.4.png" alt="gradius4"></p>
<p>　　2、将FSD 拉普拉斯金字塔图像变换为拉普拉斯金字塔图像。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.5.png" alt="gradiu5"></p>
<p>　　注意I不是单位矩阵，只是中间一个元素为1。（不懂）</p>
<p>　　3、由拉普拉斯金字塔重构原图像将GL内插值进行放大，使放大后的图像尺寸与GL - 1的尺寸相同。这里就和前面的一样（pyrup）。</p>
<p>2、融合应用</p>
<p>　　采用基于区域的融合规则，基于区域的融合方法的基本思想是：在对某一分解层图像进行融合处理时，为了确定融合后图像的像素，不仅要考虑参加融合的源图像中对应的各像素，而且要考虑参加融合的像素的局部领域。即比较源图像的某方面特征，从而动态地选这方面特征突出的源图像组成融合结果。</p>
<p>　　梯度是一个矢量，指向边缘法线方向上取得局部的最大值的方向，和图像的边缘方向总 是正交（垂直）的。所以基于梯度的滤波器，又称边缘算子。图像经梯度滤波器滤波后，突出了相邻点间灰度级的变化，达到增强边缘的目的。以区域各点灰度值之和为特征量，进行源图像分解层的融合时，来自哪个区域的特征的值大，就将该区域中心像素点的灰度值作为融合后图像分解层上该位置的像素灰度值。这样就能很好的提取图像的边缘信息。<br>　　<img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.6.png" alt="gradius6"></p>
<p>2、<strong>融合的基本步骤</strong></p>
<p>2.1、对每一源图像分别进行梯度塔形分建立图像的梯度金字塔。</p>
<p>2.2、对图像梯度金字塔的各分解层分别进行融合处理；不同的分解层、不同方向细节图像采用不同的融合算子进行融合处理，最终得到融合后图像的梯度金字塔。</p>
<p>2.3、对融合后所得梯度金字塔进行逆塔形变换（即进行图像重构），所得到的重构图像即融合图像对于融合规则可以选用基于区域信息的，也可以简单的取最大值的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　基于梯度金字塔(Gradient Pyramid,GP)分解的图像融合算法。GP 也是一种基于高斯金字塔的多尺度分解算法。通过对高斯金字塔每层图像进行梯度算子运算，便可获得图像的 GP表示。GP 每层分解图像都包含水平、垂直和两个对角线四个方向的细节信息，能更好地提取出]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（四）-- 对比度金字塔]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%AF%B9%E6%AF%94%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（四）-对比度金字塔/</id>
    <published>2014-12-30T04:59:55.000Z</published>
    <updated>2014-12-30T05:10:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="对比度金字塔融合">对比度金字塔融合</h3>
<p>　　在考虑人类视觉系统对局部对比度敏感这一视觉特性的基础上，提出了基于对比度金字塔(Contrast Pyramid，CP)分解的图像融合算法。CP 分解类似于 LP 分解，但它的每一层图像是高斯金字塔相邻两层图像的比率。 CP 融合算法应用于合成孔径雷达和前视红外图像融合。</p>
<h4 id="1、原理阐述">1、原理阐述</h4>
<p>　　<strong>（1）得到高斯金字塔（如上篇）</strong></p>
<p>　　<strong>（2）对比度金字塔</strong></p>
<p>　　用高斯金字塔得到上采样并高斯卷积之后的预测图像<em>Gl，</em>Gl的尺寸和Cl-1相同，即经过放大算子的处理（pyrup）。图像的对比度通常定义为：C = (g -gb)/gb= g/gb-I，这里g为图象某位置处的灰度值、gb为该位置处的背景灰度值、I表示单位灰度值图像。因窗口函数w(m，n)具低通滤波特性，所以G*l+1可以看作是Gl的背景，故可定义图像的对比度金字塔为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-cp1.1.jpg" alt="contrast1"></p>
<p>　　就是0层的G0除以G1上采样的得到的*G1再减去1，得到的就是对比度金字塔。</p>
<p>　　<strong>（3）重构</strong><br>　　<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-cp1.2.png" alt="contrast2"></p>
<p>　　从对比度金字塔(CN、CN-1、、、C0)的顶层CN开始、依次令l = N、N-1、、、0逐层由上到下、可依次得到高斯金字塔的各层GN、GN-1、G0。最终精确重构原始图像（高斯金字塔的最底层G0即为原始图象）。</p>
<h4 id="2、融合应用">2、融合应用</h4>
<p>　　这里的应用和上面不同的就是融合规则的不同。</p>
<p>　　设A、B为两幅原始图像，F为融合后的图像。其融合的基本步骤如下：</p>
<p>　　1）对每一源图像分别进行对比度塔形分解，建立各图像的对比度金字塔；</p>
<p>　　2）对图像金字塔的各分解层分别进行融合处理，不同的分解层采用不同的融合算子进行融合处理，最终得到融合后图像的对比度金字塔；</p>
<p>　　3）对融合后所得对比度金字塔进行逆塔形变换（图像重构），所得到的重构图像即为融合图像。</p>
<p>　　其中<strong>一种融合规则</strong>为：采用像素取大的原则。因为对比度大的像素是图像中相对突出和比较重要的像素。即获得两个图像的对比度金字塔后，差值越大就代表处变化越大，存在明显的信息，那么对应的就取该处变化大的值，保留重要的变化信息。</p>
<p>　　<strong>另一种融合规则</strong>：基于区域特性量测的加权平均融合算子，该融合规则及融合算子的确定方法如下：</p>
<p>　　分别计算两幅图像相应分解层上对应局部区域的能量：ElA及ElB：<br>　　<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-cp1.3.png" alt="contrast3"></p>
<p>　　式中El(n,m)表示对比度金字塔第l层上，以(n,m)为中心位置的局部区域能量；Ll表示对比度金字塔的第l层图像；wl(n’ ,m’ )为与Ll对应的权系数；j、k定义了局部区域的大小(例如3<em>3、5</em>5或7*7等)；n’、m’的变化范围在j、k内。这里不知道w是怎么取值的。</p>
<p>　　这个算法有点麻烦，具体的见：<br>　　<a href="http://www.docin.com/p735309332.html" target="_blank" rel="external">http://www.docin.com/p735309332.html</a></p>
<hr>
<p><strong>基于对比度塔形分解的图像融合方法的物理意义在于</strong>：</p>
<p>1）对比度塔形分解将原始图像分别分解到具有不同分辨率、不同空间频率的一系列分解层上（从底层到顶层，空间频率依次降低），同时，每一分解层均反映了相应空间频率上图像的对比度信息。</p>
<p>2）融合过程是在各空间频率层上分别进行的，这样就可能针对不同分解层的不同频带上的特征与细节，采用不同的融合算子，以达到突出特定频带上特征与细节的目的。基于对比度塔形分解的图像融合恰恰是在不同的空间频带上进行融合处理的，因而可能获得与人的视觉特性更为接近的融合效果。</p>
<p>​</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="对比度金字塔融合">对比度金字塔融合</h3>
<p>　　在考虑人类视觉系统对局部对比度敏感这一视觉特性的基础上，提出了基于对比度金字塔(Contrast Pyramid，CP)分解的图像融合算法。CP 分解类似于 LP 分解，但它的每一层图像是高斯金字塔相邻两层]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（三）-- 拉普拉斯金字塔]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（三）-拉普拉斯金字塔/</id>
    <published>2014-12-30T03:23:08.000Z</published>
    <updated>2014-12-30T04:56:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="2、拉普拉斯金字塔融合">2、拉普拉斯金字塔融合</h3>
<p>　　图像金字塔方法的原理是：将参加融合的的每幅图像分解为多尺度的金字塔图像序列，将低分辨率的图像在上层，高分辨率的图像在下层，上层图像的大小为前一层图像大小的1/4。层数为0,1,2……N。将所有图像的金字塔在相应层上以一定的规则融合，就可得到合成金字塔，再将该合成金字塔按照金字塔生成的逆过程进行重构，得到融合金字塔。这个总的思路就是一下所有基于金字塔融合的算法过程，不同点就在于分解构造的金字塔不同，每层的融合规则不一样，重构的方法不同而已。金字塔方法最先实现了这种思想，之后小波方法进一步完善和发展了这种多尺度融和的思想。</p>
<h4 id="2-1、原理阐述">2.1、原理阐述</h4>
<h5 id="（1）高斯金字塔"><strong>（1）高斯金字塔</strong></h5>
<p>　　高斯金字塔是最基本的图像塔。首先将原图像作为最底层图像G0（高斯金字塔的第0层），利用高斯核（5*5）对其进行卷积，然后对卷积后的图像进行下采样（去除偶数行和列）得到上一层图像G1，将此图像作为输入，重复卷积和下采样操作得到更上一层图像，反复迭代多次，形成一个金字塔形的图像数据结构，即高斯金字塔。</p>
<p>高斯金字塔的构建过程为：假设高斯金字塔的第L层图像为Gl：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.1.jpg" alt="Laplacian1"></p>
<p>式中N为高斯金字塔顶层层号，Rl和Cl分别为高斯金字塔第l层的行数和列数W（m，n）是一个二维可分离的5*5窗口函数，表达式为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.2.jpg" alt="Laplace2"></p>
<p>　　由G0，G1，，，GN，就构成了一个高斯金字塔，其中G0为高斯金字塔的底层（与原图像相同）GN为金字塔的顶层。由此可见高斯金字塔的当前层图像就是对其前一层图像首先进行高斯低通滤波，然后再进行隔行和隔列的降2采样而生成的。前一层图像大小依次为当前层图像大小的4倍。</p>
<p>　　Opencv中使用pyrdown函数就可以获得高斯金字塔。</p>
<h5 id="（2）拉普拉斯金字塔"><strong>（2）拉普拉斯金字塔</strong></h5>
<p>　　在高斯金字塔的运算过程中，图像经过卷积和下采样操作会丢失部分高频细节信息。为描述这些高频信息，人们定义了拉普拉斯金字塔(Laplacian Pyramid， LP)。用高斯金字塔的每一层图像减去其上一层图像上采样并高斯卷积之后的预测图像，得到一系列的差值图像即为 LP 分解图像。</p>
<p>　　将Gl内插方法得到放大图像<em>Gl，使</em>Gl的尺寸与*Gl-1的尺寸相同，即放大算子Expand<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.3.jpg" alt="Laplace3"></p>
<p>　　该式子实现两个步骤：在偶数行和列插入0，然后使用下采样中的高斯核进行滤波处理，得到和l-1层一样大小的图像。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.4.jpg" alt="Laplace4"></p>
<p>　　N为拉普拉斯金字塔顶层的层号LPl是拉普拉斯金字塔分解的第L层图像。由LP0，LP1、LP2…LPN构成的金字塔即为拉普拉斯金字塔。它的每一层L0图像是高斯金字塔本层G0图像与其高一层图像G1经内插放大后图像*G1的差，此过程相当于带通滤波，因此拉普拉斯金字塔又称为带通金字塔分解。</p>
<p>　　内插方法：opencv中有实现的函数pyrup。可以得到*G1。然后在两个函数作差，相减就可以得到拉普拉斯金字塔。</p>
<p>　　求得每个图像的拉普拉斯金字塔后需要对相应层次的图像进行融合，具体的融合规则有，取大、取小，等等。</p>
<h5 id="（3）重构"><strong>（3）重构</strong></h5>
<p>　　对融合后的拉普拉斯金字塔，从其顶层开始逐层从上至下按下式进行递推，可以恢复其对应的高斯金字塔，并最终可得到原图像G0。就是从最高层开始使用内插的方法。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.5.jpg" alt="Laplace5"></p>
<h4 id="2-2、融合应用">2.2、融合应用</h4>
<p>　　图像拉普拉斯金字塔分解的目的是将源图像分别分解到不同的空间频带上，融合过程是在各空间频率层上分别进行的，这样就可以针对不同分解层的不同频带上的特征与细节，采用不同的融合算子以达到突出特定频带上特征与细节的目的。即有可能将来自不同图像的特征与细节融合在一起。</p>
<h5 id="（1）顶层处理"><strong>（1）顶层处理</strong></h5>
<p>　　设LAl和LBl分别为源图像A,B经过拉普拉斯金字塔分解后得到的第l层图像，融合后的结果为LFl。当l=N时，LAN和LBN分别为源图像A，B经过拉普拉斯金字塔分解后得到的顶层图像。对于顶层图像的融合，首先计算以其各个像素为中心的区域大小为M*N(M、N取奇数且M &gt;= 3、N &gt;= 3)的区域平均梯度：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.6.jpg" alt="Laplace6"></p>
<p>其中，Ix与Iy分别为像素f(x,y)在x与y方向上的一阶差分，定义如下：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.7.jpg" alt="Laplace7"></p>
<p>　　因此对于顶层图像中的每一个像素LAN(i, j)和LBN(i, j)都可以得到与之相对应的区域平均梯度GA(i, j)和GB(i, j)。由于平均梯度反映了图像中的微小细节反差和纹理变化特征，同时也反映出图像的清晰度。一般来说平均梯度越大，图像层次也丰富，则图像越清晰。因此顶层图像的融合结果为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.8.jpg" alt="Laplace8"></p>
<h5 id="（2）各层次处理"><strong>（2）各层次处理</strong></h5>
<p>　　当0小于i小于N时，则对于经过拉普拉斯金字塔分解的第l层图像，首先计算其区域能量：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.9.jpg" alt="Laplace9"></p>
<p>则其他层次图像的融合结果为：</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.10.jpg" alt="Laplace410"></p>
<p>在得到金字塔各个层次的融合图像LF1、LF2、LFN后。通过前面的重构，便可得到最终的融合图像。</p>
<p>　　第二种融合规则：</p>
<p>　　采用最高层系数取平均，其余各层系数绝对值取大的融合策略进行融合。融合后图像的系数（灰度值）越接近较清晰图像的灰度值就说明融合效果好。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="2、拉普拉斯金字塔融合">2、拉普拉斯金字塔融合</h3>
<p>　　图像金字塔方法的原理是：将参加融合的的每幅图像分解为多尺度的金字塔图像序列，将低分辨率的图像在上层，高分辨率的图像在下层，上层图像的大小为前一层图像大小的1/4。层数为0,1,2……N。将所有图]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（二）-- 简单加权融合]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E7%AE%80%E5%8D%95%E5%8A%A0%E6%9D%83%E8%9E%8D%E5%90%88/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（一）-简单加权融合/</id>
    <published>2014-12-30T03:06:13.000Z</published>
    <updated>2014-12-30T03:09:43.000Z</updated>
    <content type="html"><![CDATA[<p>简单加权融合也叫做<strong>像素加权平均法</strong>（Weighted Averaging，WA）是最简单、直接的图像融合方法。它具有简单易实现、运算速度快的优点，并能提高融合图像的信噪比，但是这种方法削弱了图像中的细节信息，降低了图像的对比度，在一定程度上使得图像中的边缘变模糊，在多数应用场合难以取得满意的融合效果。</p>
<p>　　优化：<strong>主成分分析</strong>(Principal Component Analysis，PCA)就是一种常用的系数优化方法，利用主成分分析确定的权值可以得到一幅亮度方差最大的融合图像。PCA方法运用于高分辨率全色图像与低分辨率多光谱图像的融合时，通过用高分辨率全色图像替代由低分辨率多光谱图像提取出的第一主成分，得到同时具有高空间分辨率和高光谱分。</p>
<p>　　从性能上讲，主成分分析法更像是对源图像的选择而不是对源图像中显著信息的融和。局限性：以全局方差作为信息显著性度量通常会把较大的权值分配给方差较大的源图像。实际应用中，当某一传感器输出图像对比度较低时，这种权值分配方法效果会比较好，但就一般情况而言，这种分配方法并不科学。此外，主成分分析法对图像中的死点、噪声等干扰信息非常敏感，这些干扰信息会显著的提高图像的全局方差。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单加权融合也叫做<strong>像素加权平均法</strong>（Weighted Averaging，WA）是最简单、直接的图像融合方法。它具有简单易实现、运算速度快的优点，并能提高融合图像的信噪比，但是这种方法削弱了图像中的细节信息，降低了图像的对比度，在一定程度上使]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR系统系列文章汇总]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"/>
    <id>http://silencewt.github.io/2014/12/30/车牌识别LPR系统系列文章汇总/</id>
    <published>2014-12-30T02:50:35.000Z</published>
    <updated>2014-12-30T02:51:19.000Z</updated>
    <content type="html"><![CDATA[<p>　　这里的LPR的的几篇文章是之前项目的一些相关资料的整理，涉及实验室内部的资料就没有放上来，希望能对想了解这方面的同学，有所帮助，那怕了解个大概也好。知道整体的思路就好。当初就是一个人瞎摸索，走了很多的弯路，也算给其他人一点建议吧。</p>
<p>车牌识别LPR系统系列文章汇总：</p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%80%EF%BC%89-%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF/" target="_blank" rel="external">车牌识别LPR（一）— 研究背景</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BD%A6%E7%89%8C%E7%89%B9%E5%BE%81%E5%8F%8A%E9%9A%BE%E7%82%B9/" target="_blank" rel="external">车牌识别LPR（二）— 车牌特征及难点</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%89%EF%BC%89-LPR%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/" target="_blank" rel="external">车牌识别LPR（三）— LPR系统整体结构</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%9B%9B%EF%BC%89-%E8%BD%A6%E7%89%8C%E5%AE%9A%E4%BD%8D/" target="_blank" rel="external">车牌识别LPR（四）— 车牌定位</a> </p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%BA%94%EF%BC%89-%E4%B8%80%E7%A7%8D%E8%BD%A6%E7%89%8C%E5%AE%9A%E4%BD%8D%E6%B3%95/" target="_blank" rel="external">车牌识别LPR（五）— 一种车牌定位法</a> </p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AD%EF%BC%89-%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2/" target="_blank" rel="external">车牌识别LPR（六）— 字符分割</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%83%EF%BC%89-%E5%AD%97%E7%AC%A6%E7%89%B9%E5%BE%81/" target="_blank" rel="external">车牌识别LPR（七）— 字符特征</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AB%EF%BC%89-%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/" target="_blank" rel="external">车牌识别LPR（八）— 字符识别</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这里的LPR的的几篇文章是之前项目的一些相关资料的整理，涉及实验室内部的资料就没有放上来，希望能对想了解这方面的同学，有所帮助，那怕了解个大概也好。知道整体的思路就好。当初就是一个人瞎摸索，走了很多的弯路，也算给其他人一点建议吧。</p>
<p>车牌识别LPR系统系列文]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（一）-- 概述]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E6%A6%82%E8%BF%B0/"/>
    <id>http://silencewt.github.io/2014/12/29/图像融合（一）-概述/</id>
    <published>2014-12-29T12:28:00.000Z</published>
    <updated>2014-12-29T12:33:59.000Z</updated>
    <content type="html"><![CDATA[<p>　　这是2014年第二部分的内容。关于三光检测融合的一些资料整理，部分内容由于保密原因没有写出来，这里整理的内容都是网上或者文章里可以看到的。</p>
<h3 id="一、概述">一、概述</h3>
<p>　　图像融合是图像处理中重要部分，能够协同利用同一场景的多种传感器图像信息，输出一幅更适合于人类视觉感知或计算机进一步处理与分析的融合图像。它可明显的改善单一传感器的不足，提高结果图像的清晰度及信息包含量，有利于更为准确、更为可靠、更为全面地获取目标或场景的信息。</p>
<p>　　图像融合主要应用于军事国防上、遥感方面、医学图像处理、机器人、安全和监控、生物监测等领域。用于较多也较成熟的是红外和可见光的融合，在一副图像上显示多种信息，突出目标。</p>
<p>　　融合过程可以在不同的层次上进行，可分为：信号级、像素级、特征级，决策级。</p>
<h4 id="1-1、信号级">1.1、信号级</h4>
<p>　　在最低层对未经处理的传感器输出在信号域进行混合，产生一个融合后的信号。融合后的信号与源信号形式相同但品质更好，来自传感器的信号可建模为混有不同相关噪声的随机变量。此种情况下，融合可以考虑为一种估计过程，信号级图像融合在很大程度上是信号的最优集中或分布检测问题，对信号时间和空间上的配准要求最高。</p>
<h4 id="1-2、像素级">1.2、像素级</h4>
<p>　　像素级图像融合是三个层次中最基本的融合，经过像素级图像融合以后得到的图像具有更多的细节信息，如边缘、纹理的提取，有利于图像的进一步分析、处理与理解，还能够把潜在的目标暴露出来，利于判断识别潜在的目标像素点的操作，这种方法才可以尽可能多的保存源图像中的信息，使得融合后的图片不论是内容还是细节都有所增加，这个优点是独一无二的，仅存在于像素级融合中。但像素级图像融合的局限性也是不能忽视的，由于它是对像素点进行操作，所以计算机就要对大量的数据进行处理，处理时所消耗的时间会比较长，就不能够及时地将融合后图像显示出来，无法实现实时处理；另外在进行数据通信时，信息量较大，容易受到噪声的影响；还有如果没有将图片进行严格的配准就直接参加图像融合，会导致融合后的图像模糊，目标和细节不清楚、不精确。</p>
<h4 id="1-3、特征级">1.3、特征级</h4>
<p>　　特征级图像融合是从源图像中将特征信息提取出来，这些特征信息是观察者对源图像中目标或感兴趣的区域，如边缘、人物、建筑或车辆等信息，然后对这些特征信息进行分析、处理与整合从而得到融合后的图像特征。对融合后的特征进行目标识别的精确度明显的高于原始图像的精确度。特征级融合对图像信息进行了压缩，再用计算机分析与处理，所消耗的内存与时间与像素级相比都会减少，所需图像的实时性就会有所提高。特征级图像融合对图像匹配的精确度的要求没有第一层那么高，计算速度也比第一层快，可是它提取图像特征作为融合信息，所以会丢掉很多的细节性特征。</p>
<h4 id="1-4、决策级">1.4、决策级</h4>
<p>　　决策级图像融合是以认知为基础的方法，它不仅是最高层次的图像融合方法，抽象等级也是最高的。决策级图像融合是有针对性的，根据所提问题的具体要求，将来自特征级图像所得到的特征信息加以利用，然后根据一定的准则以及每个决策的可信度（目标存在的概率）直接作出最优决策。三个融合层级中，决策级图像融合的计算量是最小的，可是这种方法对前一个层级有很强的依赖性，得到的图像与前两种融合方法相比不是很清晰。将决策级图像融合实现起来比较困难，但图像传输时噪声对它的影响最小。</p>
<p>　　综合以上，<strong>研究和应用最多的是像数级图像融合</strong>，目前提出的绝大多数的图像融合算法均属于该层次上的融合。图像融合狭义上指的就是像数级图像融合。本文研究的也正是像素级图像融合算法。</p>
<p>　　<strong>红外和可见的融合很多文献都是从像素级入手，基于已有的融合算法，根据实际情况，来设立融合规则，得到适合实际应用场景的融合图像。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这是2014年第二部分的内容。关于三光检测融合的一些资料整理，部分内容由于保密原因没有写出来，这里整理的内容都是网上或者文章里可以看到的。</p>
<h3 id="一、概述">一、概述</h3>
<p>　　图像融合是图像处理中重要部分，能够协同利用同一场景的多种传感器图]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（八）-- 字符识别]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AB%EF%BC%89-%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（八）-字符识别/</id>
    <published>2014-12-29T08:35:10.000Z</published>
    <updated>2014-12-29T08:43:04.000Z</updated>
    <content type="html"><![CDATA[<p>​第八篇：字符识别</p>
<p>　　车牌定位、车牌倾斜校正、车牌字符分割都是为车牌字符识别做的前提工作，这些前提工作直接关系到车牌识别系统的性能。车牌字符识别是车牌识别系统的核心部分，车牌字符识别的准确率是衡量车牌识别系统的一个很重要的指标。</p>
<p>　　一般字符识别的方法就是采用模式识别方法，简单的来说模式识别就是先通过提取输入模板的特征，然后通过模板的特征对样本进行分类，从而识别出样本。模式识别主要包括：数据采集、预处理、特征提取、特征匹配，其结构框架如图：</p>
<p>　　字符识别是模式识别的一个重要应用，首先提取待识别字符的特征；然后对提取出来的特征跟字符模板的特征匹配；最后根据准则判定该字符所属的类别。不同的训练方法，不同的特征提取， 不同的匹配规则，就相应的有不同的字符识别方法，基本上很多就是在这些地方做改进，或者是采用新的规则。但是万变不离其宗。</p>
<p><strong>（1）模板匹配字符识别算法</strong></p>
<p>　　模板匹配字符识别算法是图像识别中的经典算法之一，该算法的核心思想是：通过比较待识别字符图像的字符特征和标准模板的字符特征，计算两者之间的相似性，相似性最大的标准模板的字符即为待识别的字符。该方法首先要建立标准模板库，其中标准模板库中的字符的大小是一样的；然后将待识别的字符规格化，其大小应该和模板库中的字符一样；最后将待识别的字符和标准模板库中的所有字符进行匹配，计算相似度。模板匹配字符识别算法适用于印刷字体、字体规范的字符等，但是对字符变形、弯曲、字符旋转等情况的抗干扰能力差。</p>
<p><strong>（2）神经网络字符识别算法</strong></p>
<p>　　主要思想是：通过神经网络学习大量字符样本，从而得到字符的样本特征。当对待识别的字符进行识别时，神经网络就会将待识别字符的特征和之前得到的样本特征匹配，从而识别出字符。该算法主要利用神经网络的学习和记忆功能。神经网络虽然有其优点，但是由于采用神经网络识别字符依赖于初始的样本的选择，并且容易陷入局部最优和收敛速度慢，因此采用神经网络识别字符的算法仍需要改进。</p>
<p><strong>（3）支持向量机</strong></p>
<p>　　主要思想：同上，都是先得到样本特征，进行训练，然后再分类。SVM应该算是用的的最多的分类方法，一般大多适合于二分类问题，在这里就需要使用多分类器来构造。</p>
<h3 id="字符识别步骤："><strong>字符识别步骤：</strong></h3>
<h4 id="1、归一化">1、归一化</h4>
<p>　　主要包括位置归一化和大小归一化。由于本文处理的车牌字符都是标准的印刷体字符，且都进行过倾斜校正，所以不需要对其进行位置归一化。但由于摄像距离大小不一样，导致拍摄到的车辆图像中的车牌字符大小不一，为了达到更好的识别效果，就需要对分割出来的单个车牌字符进行大小归一化。常用的归一化方法有两种：一种是将字符图像的外边框按比例线性放大或缩小到规定尺寸；另一种是根据水平和垂直两个方向像素的分布进行大小归一化。一般用第一种。当映射到原图像的点的坐标不是整数，即位于几个像素之间，这就需要利用插值算法来决定该像素的值。使用常见的双线性插值法。将图像归一化为32*64的。</p>
<h4 id="2、特征">2、特征</h4>
<p>　　根据上一篇的介绍，采用LBP特征来识别汉字，均匀网格特征来识别字母和数字。</p>
<h4 id="3、分类器">3、分类器</h4>
<p>　　SVM作为分类器。支持向量机的原理，其所涉及到的数学知识比较复杂，自己编程实现的话有一定难度。采用现成的支持 SVM 的工具箱，公认做的比较好的是台湾大学林智仁(Chih-Jen Lin)教授开发的 LibSVM，支持 SVM 的各种算法，可以解决回归和分类识别问题。LibSVM 不但提供了 Windows 系统的可执行文件，还提供了 C 语言的源代码，方便科研工作者根据自己的需要进行改进，而且还提供了Java、Matlab、C#、Ruthon 等语言的接口。当然可以直接调用opencv中的SVM工具。 </p>
<p>　　汉字的笔画很稠密，字符分辨率非常低:如果对车牌汉字字符进行二值化，将会丢失汉字的很多重要的结构信息，产生不必要的噪声，导致笔画断裂和笔画粘连等。</p>
<h4 id="4、二次识别">4、二次识别</h4>
<p>　　总的来说，单个字符的识别率比较高，容易识别错的主要是相近字符，解决这类问题的最佳办法就是二次识别。将相似字符中的一个识别出来后，便能确定其属于哪一类相近字符类别,利用区分相近字符的细节特征，将这个字符到专门识别这类相近字符的分类器中进行二次识别。车牌字符中相近字符主要有5类，分为为“0”、“D”、“Q”，“B”、“8”，“2”、”Z”，“5”、”S”和“A”、“4”。</p>
<p>　　(1) “0”、“D、“Q”</p>
<p>　　从字符图像中可以看出,它们的区分在左侧和右下角，其中“D”的左边为直线，黑色像素点较多，而“0”和“Q”的左边均为弧线,黑色像素点相对较少；字符“Q”的右下角的笔画丰富，黑色像素较多。具体局部特征如图：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.1.png" alt="0dq"></p>
<p> 　　(2)“B、8“</p>
<p>　　它们的区别在字符的左侧,“8”的左侧为弧线,而“B”的左侧为直线。具体局部<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.2.png" alt="b8"></p>
<p>　　(3) “2、Z”</p>
<p>　　它们的区别在字符的上方，“2”的上方为弧线，“Z”的上方为直线，具体局部特征。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.3.png" alt="2z"></p>
<p>　　(4)“5、S”</p>
<p>　　它们的区别在字符的上半部分，“5”的上半部分中，上方和左侧均为直线,而”S”的上半部分为弧线。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.4.png" alt="5s"></p>
<p> 　　(5)“A、4”</p>
<p>　　由于存在倾斜等情况,仅仅通过基本特征会出现误识别,它们的区别在左下角。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.5.png" alt="a4"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>​第八篇：字符识别</p>
<p>　　车牌定位、车牌倾斜校正、车牌字符分割都是为车牌字符识别做的前提工作，这些前提工作直接关系到车牌识别系统的性能。车牌字符识别是车牌识别系统的核心部分，车牌字符识别的准确率是衡量车牌识别系统的一个很重要的指标。</p>
<p>　　一般字符识]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（七）-- 字符特征]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%83%EF%BC%89-%E5%AD%97%E7%AC%A6%E7%89%B9%E5%BE%81/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（七）-字符特征/</id>
    <published>2014-12-29T08:23:42.000Z</published>
    <updated>2014-12-29T08:29:16.000Z</updated>
    <content type="html"><![CDATA[<p>第七篇：字符特征</p>
<p>选择的字符特征应该满足以下条件：</p>
<p>　　（1）选取的字符特征具有较强的鲁棒性，不受字符变形、弯曲等影响。</p>
<p>　　（2）两个字符的字符特征不能完全相同，但部分相同是允许的，即选择的字符特征是唯一的，但是不能重复。</p>
<p>　　（3）选取的字符特征要尽可能的提供字符的信息。</p>
<p>　　（4）选择的字符特征提取方法易于实现，能够减少计算时间。</p>
<p>　　一般采用<strong>纹理、边缘特征</strong>。纹理特征是表示图像的另一种重要的视觉特征，纹理结构反映图像亮度的空间变化情况，具有局部与整体的自相似性。纹理是有纹理基元按某种确定性的规律或某种统计规律排列组成的，在纹理区域内各部分具有大致相同的结构。</p>
<h4 id="提取特征的的方法：">提取特征的的方法：</h4>
<p>　　（1）逐像素特征提取是指对整幅二值图像进行扫描，若图像中的像素点为黑色像素点时，则令特征值为 1，否则特征值为 0。经过该方法提取的特征向量的维数与图像中的像素点的个数相同。</p>
<p>　　（2）骨架特征提取是先细化字符图像，然后从细化后的字符图像中逐像素地提取特征。此方法适用不同大小的字符。</p>
<p>　　（3）垂直方法数据统计特征提取是首先对字符图像进行水平投影，统计水平投影值，此处的水平投影值为黑色像素的数目；然后通过对字符图像进行垂直投影，统计垂直投影值，此处的垂直投影值仍为黑色像素的个数；最后将水平和垂直投影值作为字符的特征向量。</p>
<p>　　（4）13 点特征提取方法的总体思路是：首先把字符平均分成 8 份，统计每一份黑色</p>
<p>　　像素点的个数作为 8 个特征。分别统计这 8 个区域中的黑色像素的数目，就可以得到 8 个特征；然后统计水平方向中间两行和垂直方向中间两列的黑色像素点的个数作为 4 个特征；最后统计所有黑色像素点的个数作为 13 个特征。</p>
<h4 id="常用的特征求取：">常用的特征求取：</h4>
<p><strong>一、粗网格特征：</strong></p>
<p>　　将归一化后的字符图像等分成 8×8 网格，统计各网格内黑像素的数量，取得一个 64 维的网格特征。</p>
<p>　　外围特征：提取字符外围特征的步骤为：</p>
<p>　　① 把归一化后的点阵图形等分为 8 行。</p>
<p>　　② 计算每一行中点从图像左边缘至第一项由白变黑的长度（如果没有由白变黑的点，则默认为零）。</p>
<p>　　③ 再计算每一行中点从图像左边缘至第二项由白变黑的长度（如果没有由白变黑的点，则默认为零）。</p>
<p>　　④ 仿照上面 3 个步骤，提取其它 3 个边缘的特征。</p>
<p>　　采用上述方法可以提取另一个 4×2×8=64 维的外围特征。</p>
<p>　　通过采用基于像素数量的粗网格特征与外围特征相结合方法可以提取字符的128 维特征，用以字符识别。</p>
<p><strong>​二、PCA进行汉字识别，网格特征进行数字和字母的提取。</strong></p>
<p>　　网格特征是指通过把二值化后的字符分成M×N个网格，统计每一个网格中的字符像素数量，把各个网格中的像素数量组合起来作为字符的网格特征来识别字符。字母数字相对于汉字来说笔画简单，也极少出现字符轮廓模糊的现象。因此，字母数字的识别相对来说比较简单。但是，字母数字之间存在相似字符的比例较高，而且相似字符之间的差异又比较小，很容易识别错。对字母数字的识别论文采用了二次识别的思想。</p>
<p><strong>三、均匀网格特征</strong></p>
<p>　　统计黑像素点在每个网格中所占的比例，属于统计特征中局部特征的一种，体现了文字点阵的整体形状的分布。它将字符图像二值化以后，再把样本字符图像分成mxn个M格，并统计每个网格中属于文字点阵的像数量，记为i；统计整个图像巾屈于文字点阵的像素数量，记为j；计算各个网格中的文字点阵的像素数量整个像中文字点阵的像素数量之比P=i/j将每个网格统汁的百分比P組合起来作为字符的统计特征，用以实现对字符的识别。好个网格屮的文字点阵比例反映了文字笔画在二维平面空间的分布特征。</p>
<p>　　网格特征的统计是以网格为单位进行的,即使个别像素点的统计有误差也不会对识别结果造成很大的影响，该特征还具有较强的区分相似字符的能力。此特征提取算法比较简单，计算速率很快,且易于实现,但其对字符图像配准要求较高，故需要在提取字符图像的特征之前，对图像进行去边框等预处理操作。此算法更适合印刷体等较规则的字体，而不适用于手写体。</p>
<p><strong>四、LBP特征进行汉字识别</strong></p>
<p>　　预处理模块对图像进行归一化操作；第二个模块计算出图像中每个像素点的LBP值；第三个模块用于将图像平均分割为MxN个网格；最后一个模块用于计算各块的LBP特征。</p>
<p>　　1、传统的LBP算法是基于3 X 3的窗口的，对应于9个灰度值。将该窗口的8邻域的灰度值与中心像素的灰度值比较，小于中心灰度值的像素点的置为0，反之将其置为1；然后，通过逆吋针或者顺时针将这8个二进制数转化为一个二进制序列，并求出其对应的十进制值，作为这个3X3窗口的中心像素点的特征值。即各像素点的LBP值。</p>
<p>　　2、将每个像素点的LBP值齊代它的灰度值,得到LBP阁像。并将LBP图像分块，对每个分块进行直方图统计。如,将LBP图像分为4<em>8块，每块大小为8</em>8。在每个分块内，将0-255的LBP值量化为32级，并进行直方图统计。即每个分块的LBP特征为32维。</p>
<p>　　3、将各个小块的LBP特征连起来，获得(4<em>8)</em>32=1024维的一个矢量，该矢量即为字符图像的LBP特征。</p>
<p>　　<strong>改进的LBP特征：</strong></p>
<p>　　均匀模式：它们有一个共同点，即在LBP二值编码序列巾，最多有两个0到1或1到0的变化。LBP二值编码序列为11000001，从1到0的变化为1次,从0到1的变化为1次，即它的均匀性U(LBP)=2。满足U(LBP)&lt;=2的所有模式称为均匀模式。在8邻域中，满足U(LBP)&lt;=2的所有模式的个数为8*(8-1)+2，具体的LBP二值编码序列与i/(Z及TMH]对应图见图2-16。再进一步将它们旋转到最小值后，具有旋转不变性的均勾模式(Rotation Invariant Uniform Pattern)的个数则为8+1。</p>
<p>　　模式对应的LBP二进制中从0变化为1和从1变化为0的次数之和小于等于两次，则该模式就是均匀模式。再根据顺时针或逆时针方向读出8个二进制数作为一个二进制序列,计算其对应的十进制值，作为该3*3矩形的中心元的特征值。反之，则该模式就不是均匀模式，它们的LBP值均为8+1。</p>
<p>　　由于改进的LBP特征是用58种均匀模式和统一后的一种非均匀模式来表示的。即在每个分块内，将0-255的LBP倍转化为59级。将这59级量化到0-63、64-127、128-191、192-255这四个区间中，并进行直方图统计。即每个分块的LBP特征为4维。</p>
<p>　　将各个小块的LBP特征连起来，获得(4*8)*4=128维的一个矢量，矢量即为字符图像的LBP特征。均匀模式时的LBP特征向量维数=图像分块数*59，改进的LBP特征向量维数=图像分块数*4，大大地提高了识别速率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第七篇：字符特征</p>
<p>选择的字符特征应该满足以下条件：</p>
<p>　　（1）选取的字符特征具有较强的鲁棒性，不受字符变形、弯曲等影响。</p>
<p>　　（2）两个字符的字符特征不能完全相同，但部分相同是允许的，即选择的字符特征是唯一的，但是不能重复。</p>]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（六）-- 字符分割]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AD%EF%BC%89-%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（六）-字符分割/</id>
    <published>2014-12-29T07:56:00.000Z</published>
    <updated>2014-12-29T08:17:23.000Z</updated>
    <content type="html"><![CDATA[<p>第六篇：字符分割</p>
<p>　　在知道了车牌字符的规律之后，可以根据车牌的特点对字符进行分割。一般最容易想到的方法就是根据车牌投影、像素统计特征对车牌图像进行字符分割的方法。是一种最常用的、最基本的、最简单的车牌字符分割方法。它的精髓是对车牌图像进行逐列扫描，统计车牌字符的每列像素点个数，并得到投影图，根据车牌字符像素统计特点（投影图中的波峰或者波谷），把车牌分割成单个独立的字符。</p>
<p>　　图像的边缘信息一般都是高频信息，所以在水平、垂直方向上对车牌图像进行小波变换，对其高频信息进行重构，获得相应的高频信息方面的子图，在车牌垂直投影图像中找到每个车牌字符的边界所在位置，并记下边界位置的横坐标；同理在水平投影图像中找到相应的边界的纵坐标，再根据相应的字符坐标值将字符分割出来。</p>
<p>　　一般在进行分割之前需要对车牌进行预处理：倾斜校正和去噪处理。</p>
<p>　　在进行分割之后需要统一字符大小，对其进行归一化和去边框处理。</p>
<p><strong>（1）统一车牌底色：</strong></p>
<p>　　对不同类型的车牌灰度图像进行二位化以后，有的呈现的是黑底白字，而有的则是白底黑字，为了便于对字符进行分割，需首先将不同种类车牌的二值化结果进行景颜色和目标颜色的统一，然后再用相关字符分割的方法对车牌屮的字符进行切分和提収。统一车牌底色可以有两种方法：</p>
<p>　　基于颜色分量的判断，但由于我国车牌种类太多，这个方法并不能完全区分，但是区分两种车牌类型还是可以的，例如蓝底白字车牌中的R小于B，而黄底黑字中的B大于R，在考虑到光照影响和使用已久褪色车牌上这种方法就不好了。</p>
<p>　　基于二值图像中像素比例特征的车牌底色判断：一般情况下，二值化后的车牌图像中字符笔画的像素个数在整个车牌的像素数目中所占的比例要小于50%。因此，可以通过分别计算二值化后的车牌中两种像素值的像素个数的大小来判断是否需要反色，若目标像素的比例大于50%，则将图像进行反色，否则不进行处理。这种方法的优点是算法简单，适用各种底色类型的车牌。缺点是若车牌中含有的字符的笔画较粗或者是车牌上存在较多污点或者是有装饰物等因素影响时，往往不能准确的判断底色。</p>
<p><strong>（2）图像去噪</strong></p>
<p>　　采集的图像总是会受到各种噪声的影响。为了保证后续处理的精确度，需要抑制图像中的噪声。对二值化后的车牌图像进行中值滤波处理，它是一种常见的非线性滤波方法，是一种局部平均的图像平滑技术，也是一种低通滤波。经典的中值滤波算法步骤如下：</p>
<p>　　1、令一个 3*3模板沿行或者列方向的移动；</p>
<p>　　2、每次移动后，对模板覆盖区域的像素灰度值进行排序；</p>
<p>　　3、用排序得到的中值代替模板内中心位置的原始图像像素灰度值。</p>
<p>　　通过以上步骤可以看出，中值滤波的主要功能就是让与周围像素灰度值的绝对差较大的像素改为与周围像素灰度值接近的灰度值，去除那些相对于其领域像素更亮或更暗的灰度。一般来说，小于中值滤波器模板面积一半的亮或暗区域会被滤掉，而较大的物体则会几乎原封不动的保留下来。</p>
<p><strong>（3）倾斜校正</strong></p>
<p>　　通常车牌区域的上下沿是两条明显的平行直线，一般都采用Hough 变换，检测出这两条直线的倾斜角，然后对车牌进行校正。然而传统的 Hough变换是对整幅图像的每个像素进行计算，以求出图像中可能存在的直线。</p>
<p>　　要想使用 Hough 变换计算车牌的倾斜角度，必须先确定进行 Hough 变换所需要的数据，即车牌的边缘点。如果图像包含完整的车牌，一般采用检测车牌的上下边框边缘点来作为 Hough 变换的数据，但由于实际得到的车牌不一定含有边框或者只有极少量的边框，所以最常用的是直接检测车牌每个字符上下边缘点作为Hough 变换的数据来源，但是由于实际中得到的车牌含有噪声、污损等原因，用这种方法会产生大量的干扰点，影响校正效果。</p>
<p>　　方法：对车牌图像在垂直方向进行投影并用高斯滤波器进行平滑，定位投影曲线中的所有波谷点，然后在相应的二值图中，查找所有波谷点之间最高的连通区域，得到的各个区域大部分就是车牌中的各个字符，最终选取各个连通域中即字符的最高和最低点作为 Hough 变换的检测点。对图像进行旋转时采用双线性插值。 </p>
<p><strong>（4）去边框</strong></p>
<p>　　定位出来的车牌图像往往会包含车牌的部分或者全部边框，甚至还包含部分车身，为车牌字符分割带来了不利影响。因此就需要先对车牌图像进行去边框处理，其原理如下：采用水平投影得到上下边界。</p>
<p><strong>（5）字符分割</strong></p>
<p>　　采用一种基于相邻字符最大间隔宽度的方法来对车牌中的字符进行分割。由单行车牌的特点可以知道，在第二个字符和第三个字符之间存在一个圆形的间隔符，且该间隔符在每个单行车牌中有且仅有一个，还有一个重要的特点就是此间隔符所在的间隙约是其他相邻字符之间间隙的2.6倍，是整个车牌图像中相邻字符的最大间隙，根据这一先验知识首先确定了第二个字符右边缘和第三个字符左边缘的位置，然后由二值图像的垂直投影及单个字符的高宽比确定后5个和前2个字符的精确位置，因此，该方法的最为关键的部分是寻找图像中间隔符所在的空隙。</p>
<p>　　采用连通域和投影相结合的方法来对车牌图像进行字符分割，采用四连通标记法对车牌字符边界进行标记，形成连通域；然后判断各个区域的高宽是否基本等于车牌字符区域的高宽（去边框时已经求出），若相差较大时，就进行垂直投影，把宽小于车牌字符宽的相邻区域进行合并，把宽大于车牌字符宽的相邻区域进行进一步分割；最后对各个区域加矩形边框，提取单个车牌字符。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr6.jpg" alt="分割"></p>
<p>　　在理想的情况下，波谷的值应该为零，并且两个字符之间应该存在波谷，但是由于受到噪声的干扰，使得波谷的值为非零。常见的字符分割的问题有：字符粘连、字符断裂、数字“1”。字符粘连是指两个以上的字符连在一起，在垂直投影上的表现是原本应该为波谷的地方，现在却为非零的垂直投影值；字符断裂是一个字符分裂为几部分，在垂直投影上的表现为几段垂直投影；数字“1”的垂直投影值比较小，容易误判为噪声。可以结合车牌中字符的几何特征解决上述问题。设车牌中字符的宽度为 Width。</p>
<p>　　1）字符粘连</p>
<p>　　当 Width&lt; charWdith &lt; 1.5<em>Width，其中 charWidth 为粘连字符的宽度。此时为两个字符粘连的情形。可取 charWidth / 2 作为单个字符的宽度，以此来分割两个粘连的字符；若 1.5</em>Width&lt; charWidth&lt; 2*Width，此时为三个字符粘连的情况。通过单个字符具有固定的宽高比的先验知识，利用字符的高度求出字符的宽度。然后根据字符的宽度对粘连的字符进行分割。</p>
<p>　　2）字符断裂</p>
<p>　　若 charWidthi&lt; 0.5<em>Width 且 0.5</em>Width &gt; charWidthi+1。其中 charWidthi为当前字符的宽度，charWidthi+1为下一个字符的宽度。此时把当前字符和下一个字符合并。</p>
<p>　　3）数字“1”</p>
<p>　　当 charWidthi&lt; 0.5<em>Width 且 0.5</em>Width &lt; charWidthi+1时，统计区间宽度 charWidthi内的投影值大于 0.8*Height 的个数 nums，其中 Height 为车牌图像的高度。当符合条件 nums ≥ Thresh 时，其中 Thresh 为阈值，此时判定为数字“1”，否则为噪声。</p>
<p>　　<em>采用的车牌字符分割方法；对车牌图像进行灰度化处理，去除颜色信息，使后面的字符分割算法运行速度更快；对灰度车牌图像进行二值化处理（otsu），并统一车牌图像的背景和字符的颜色；对有一定倾斜角度的车牌图像进行倾斜校正处理，对车牌图像进行去边框处理；采用连通域与投影法相结合的方法对车牌图像进行字符分割，为后面的单个字符识别做准备。</em></p>
<p>​</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第六篇：字符分割</p>
<p>　　在知道了车牌字符的规律之后，可以根据车牌的特点对字符进行分割。一般最容易想到的方法就是根据车牌投影、像素统计特征对车牌图像进行字符分割的方法。是一种最常用的、最基本的、最简单的车牌字符分割方法。它的精髓是对车牌图像进行逐列扫描，统计车牌字]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（五）-- 一种车牌定位法]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%BA%94%EF%BC%89-%E4%B8%80%E7%A7%8D%E8%BD%A6%E7%89%8C%E5%AE%9A%E4%BD%8D%E6%B3%95/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（五）-一种车牌定位法/</id>
    <published>2014-12-29T07:52:14.000Z</published>
    <updated>2014-12-29T07:53:15.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em>该方法是某个文章中看到的，有点忘了是那一篇了，看的太多也太久了。</em></strong></p>
<p><strong>Step1、把采集到的RGB图像转换为HSI图像。</strong></p>
<p>　　HSI模型能反映人对色彩的感知和鉴别能力，非常适合基于色彩的图像的相似比较，故采用HSI模型。假设HSI颜色模型各分量为H、S、I ，RGB 彩色模型的各个分量为 R,  G ,B ，则 RGB 转换 HSI 的公式为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.1.jpg" alt="公式1"></p>
<p>　　其中H表示色调，如红色、绿色、蓝色等，色调的取值范围为[0,360]，其对应颜色轮的角度。S表示饱和度，其意义是颜色的鲜艳度，可以用百分比来表示，从0%到完全饱和100%。 I表示亮度，是指颜色的明亮程度，通常用百分比表示，从黑0%到白100%。</p>
<p>　　通过式把 RGB 彩色图像转换为 HSI 彩色模型的图像，HSI 彩色模型的图像，左侧为 RGB 彩色图像。从 HSI 颜色的图像中可以看出，高亮部分为车牌的蓝色区域。</p>
<p><strong>Step2、提取 HSI 图像中的 H、S 分量。</strong></p>
<p>（1）利用 H 分量进行图像颜色分割。由于蓝色的 H 分量值为 240 º，并且图像可能受到噪声污染，所以蓝色的 H 分量值有一定的波动。经过实验可得到蓝色分量 H 的最小值blue_MinH 为 220º，最大值 blue_MaxH 为 245º。假设二值图像为 Bw，Bw 和 HSI 图像具有相同的大小，Bw 中的所有元素都为 0。利用下式把满足蓝色区域条件的设为前景白色，即 Bw = 1；不满足条件的设为背景黑色，即Bw = 0。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.2.jpg" alt="公式2"></p>
<p>（2）利用S分量对图像处理。因为受到天气、光照等条件的影响，非牌照区域也会和牌照区域的色调特征相同，因此可以利用 S 分量去掉饱和度小且满足蓝色色调范围的区域。设饱和度的阈值为 threshS，利用去掉满足蓝色色调条件但非车牌的区域。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.3.jpg" alt="公式3"></p>
<p><strong>Step3、利用车牌的几何特征去除候选区域中的非牌照部分。</strong></p>
<p>　　由于天气、光线等因素导致采集到的图像受到噪声的干扰，所以即使经过 Step1、Step2 的处理，仍然可能存在多个车牌的候选区域。利用车牌的几何特征可以过滤掉部分不符合条件的候选区域。常用的车牌几何特征有：候选区域的面积、外接矩形的宽度和高度、外接矩形的长宽比，本文采用候选区域的高度。具体做法如下：通过对 Step2 得到的二值图像 Bw 水平投影，得到水平投影图，其中水平投影值是同一行中的像素点的个数。基于车牌区域存在一定的高度的事实，设定车牌高度的最小值为 Height_Min,最大值为 Height_Max,候选区域的高度为 Heigh。当满足 Height_Min ≤ Height ≤ Height_Max 时，从图像中提取出高度为 Height 的候选区域。</p>
<p><strong>Step4、为处理车辆和车牌颜色特征相同的情况，可以通过特征颜色边缘检测去除和车牌颜色特征相同的伪车牌区域。</strong></p>
<p>　　设图像 K(i,j)= (H(i,j),S(i,j), I(i,j))，其中 H(i,j),S(i,j), I(i,j)分别表示 K(i,j)的 H、S、I 分量。二维数组 K2(i,j)是边缘检测后的图像。采用以 K(i,j)为中心的 3×3窗口检测特定的颜色边缘。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.4.jpg" alt="公式4"></p>
<p>（1）在 HSI 彩色模型中，满足式前两式时判为蓝色；满足式（2.4）则为白色。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.5.jpg" alt="公式5"></p>
<p>（2）获取蓝白边缘图像。判断蓝白边缘的条件为：（a）K(i-1,j-1)、K(i,j-1)、K(i+1,j-1)都为蓝色像素点，K(i-1,j+1)、K(i,j+1)、K(i+1,j+1)均为白色像素点；（b）K(i-1,j-1)、K(i,j-1)、K(i+1,j-1)都为白色像素点，K(i-1,j+1)、K(i,j+1)、K(i+1,j+1)均为蓝色像素点。若满足（a）、（b）中的任意一个条件，则 K(i-1,j)、K(i,j)、K(i+1,j)为蓝白边缘点，令 K2(i-1,j)= K2(i,j) = K2(i+1,j) = 1，并将该窗口中的 K2 其它像素设为 0；若以上条件均不满足，则将该窗口位置的 K2 中的所有像素值置为 0。同时将窗口遍历整幅图像，得到蓝白边缘图。</p>
<p>（3）利用车牌的几何特征去掉不符合条件的候选区域。面积大小的计算定义为：蓝白边缘图像中白色的像素点的总数，即为 white_CountTotal。设车牌区域面积的最小值为 min_Area，最大值为 max_Area。当 min_Area ≤ white_CountTotal 并且 white_CountTotal ≤ max_Area,则认为是车牌区域。</p>
<p><strong>Step5、确定车牌区域的宽度。</strong></p>
<p>　　经过前面的步骤已得到车牌区域，确切的说应该是车牌的高度，所以还需得到车牌的宽度。本文采用垂直投影的方法确定车牌的宽度。对车牌区域进行垂直投影。垂直投影值定义为图像中同一列为白色像素点的个数，记为vertical_Count，令垂直投影值的阈值为 verticalValue_Thresh。</p>
<p>　　具体过程如下：</p>
<ul>
<li>首先从图像的最左边扫描图像的垂直投影值，当 vertical_Count ≥verticalValue_Thresh时，该位置即为车牌区域的起点 wide_Start ；</li>
<li>然后继续扫描直到vertical_Count ≤ verticalValue_Thresh 时，此位置则为车牌区域的终点 wide_End；</li>
<li>最后得到车牌区域的宽度 wide = wide_End – wide_Start。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong><em>该方法是某个文章中看到的，有点忘了是那一篇了，看的太多也太久了。</em></strong></p>
<p><strong>Step1、把采集到的RGB图像转换为HSI图像。</strong></p>
<p>　　HSI模型能反映人对色彩的感知和鉴别能]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（四）-- 车牌定位]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%9B%9B%EF%BC%89-%E8%BD%A6%E7%89%8C%E5%AE%9A%E4%BD%8D/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（四）-车牌定位/</id>
    <published>2014-12-29T07:24:23.000Z</published>
    <updated>2014-12-29T07:37:06.000Z</updated>
    <content type="html"><![CDATA[<p>第四篇：车牌定位　　</p>
<p>　　车牌定位就是采用一系列图像处理或者数学的方法从一幅图像中将车牌准确地定位出来。车牌定位提取出的车牌是整个车牌识别系统的数据来源，它的效果的好坏直接影响到整个系统的表现，只有准确地定位出车牌，才会有后续的车牌分割与字符识别。</p>
<p>　　目前车牌定位有两大类、基于灰度、基于彩色。</p>
<h4 id="基于灰度：">基于灰度：</h4>
<p>　　我们采用的是<strong>基于灰度的形态学的车牌定位</strong>：首先根据车牌区域中丰富的纹理特征，提取车牌图像中垂直方向的边缘并二值化。然后对得到的二值图像进行数学形态学(膨胀、腐烛、幵闭运算等)的运算，使得车牌区域形成一个闭合的连通区域。最后通过车牌的几何特征(高、宽、宽高比等)对得到的候选区域进行筛选，最终得到车牌图像。</p>
<p>　　<strong>基于灰度的还有边缘检测的车牌定位</strong>：由于车牌字符的灰度值与车牌底色的灰度值相差较大，字符与底色的交界处就有灰度突变，灰度突变处就会产生边缘，这是车牌定位技术中非常重要的特征。也可以通过检测车牌的外边框来定位车牌，由于外边框的上下左右四边都为直线，而且有明显的边缘特征，所以首先利用边缘检测算法提取车牌边框位置，然后，用Hough变换算法检测直线，确认外边框的上下左右四条边位置就确定了车牌在图像中的位置。</p>
<p>　　<strong>基于投影法的车牌定位方法</strong>：首先对车牌图像进行二值化，由于车牌区域存在明显的剧烈的字符与背景的灰度跳变，将跳变次数投影到垂直轴上，那么车牌区域对应的垂直轴上会有一个明显的峰值，这样可以得到车牌的上下边界。然后对上下边界内的区域进行水平投影，字符区域会出现明显的峰值，这样可以得到车牌的左右边界。这种方法比较理想化。</p>
<p>　　<strong>基于纹理分析的车牌定位方法</strong>：所谓的纹理特征是指对图像进行扫描得到的灰度变化曲线，由于扫描经过车牌得到的变化曲线明显不同于经过非车牌得到的曲线，根据这个特点再结合形态学操作和其它先验知识就能从图像中提取出车牌。</p>
<h4 id="基于彩色的：">基于彩色的：</h4>
<p>　　从颜色空间的角度来看，HSV (Hue色调，Saturation饱和度，Value亮度)颜色空间具有线性伸缩性，比RGB颜色空间更容易区分色彩。HSV车牌定位典型的思路是首先将车牌图像从RGB空间转换到HSV空间，然后寻找图像中含有蓝白相间、黄黑相间、白红相间和白黑相间的地方，对得到的候选区域进一步用字符颜色提取车牌字符，最后用车牌的字符特征确定车牌位置。基于彩色图像的车牌定位方法对字符颜色和背景颜色固定的车牌可以取得较好的效果。</p>
<p>　　<strong>基于彩色图像的边缘检测和区域生长相结合的车牌定位</strong>：实现该方法的基本思想是：首先可以利用边緣检测算子对原始彩色(RGB空问)图像进行边缘检测，使得车牌区域的纵向纹理特征得到增强；接着利用数学形态学中的膨胀算法实现区域的连通，然后采用区域生长的方法对候选区域进行标记，最后利用车牌具有的特征和字符排列的频率特点，去除伪车牌区域，得到车牌区域。</p>
<p>　　<strong>基于纹理和颜色综合特征的车牌定位</strong>：首先将原始彩色图像M0的颜色空间转化到HSV颜色空间Ml；接着对Ml进行色彩分割，把所需要的颜色的区域设置为前景白色，其他区域设为背景黑色，此时得到图像M2，其次对M2采用区域生长的方法进行处理，并生成连通区域，得到车牌区域的集合A，然后若集合A中不包含车牌，则继续对Ml进行色彩分割，提取下一块前景颜色区域，并对该区域进行车牌特征分析，重复上述过程。</p>
<p>　　<strong>车牌轮廓特征判断条件</strong>：</p>
<pre><code>（1）外接轮廓的高度大于5个像素或小于25个像素

（2）外接轮廓的宽度大于20个像素或小于80个像素

（3）外接轮廓的宽高比大于2或小于10
</code></pre><p> 　　由于我国车牌种类繁多，颜色组合不一致，会遇到以下问题：一方面各地发放的车牌的底色色调会有所不同，另一方面受自然光照变化影响，采集到车牌图像的色度的变化范围也很大。因此，定位我国车牌的方法不适宜直接利用颜色信息进行定位。</p>
<p>　　其实，还有一些文献里提出<strong>支持向量机和adaboost等分级分类的定位方法</strong>，虽然使用训练的方法可以很准确的得到车牌图像，但是实际中由于环境的复杂性，单纯的一种方法并不不能得到很好的结果。对图像进行预处理，结合三次定位，像素统计粗定位，颜色阈值定位，文理特征定位，一次次的精确定位结果，调整参数，知道得到正确的车牌图像。</p>
<p>　　这里有涉及到边缘检测的应用，其中边缘检测就有几种常用的算子方法。还涉及颜色空间的转换，这里不做具体展开。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第四篇：车牌定位　　</p>
<p>　　车牌定位就是采用一系列图像处理或者数学的方法从一幅图像中将车牌准确地定位出来。车牌定位提取出的车牌是整个车牌识别系统的数据来源，它的效果的好坏直接影响到整个系统的表现，只有准确地定位出车牌，才会有后续的车牌分割与字符识别。</p>
<]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
</feed>
