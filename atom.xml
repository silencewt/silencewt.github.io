<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silence 婷婷 Blog]]></title>
  <subtitle><![CDATA[既然选择远方，便风雨兼程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://silencewt.github.io/"/>
  <updated>2015-04-01T13:14:03.706Z</updated>
  <id>http://silencewt.github.io/</id>
  
  <author>
    <name><![CDATA[Wangt]]></name>
    <email><![CDATA[wangt_hust@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《赢在测试2》-- 推荐的阅读书籍]]></title>
    <link href="http://silencewt.github.io/2015/04/01/%E3%80%8A%E8%B5%A2%E5%9C%A8%E6%B5%8B%E8%AF%952%E3%80%8B-%E6%8E%A8%E8%8D%90%E7%9A%84%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    <id>http://silencewt.github.io/2015/04/01/《赢在测试2》-推荐的阅读书籍/</id>
    <published>2015-04-01T13:06:42.000Z</published>
    <updated>2015-04-01T13:12:23.000Z</updated>
    <content type="html"><![CDATA[<p>　　这里推荐了很多书，有一些我看过，或者准备看的书，其中最受大家推荐的就是：<strong>《软件测试经验和教训》</strong></p>
<p>1、<code>《软件测试艺术》</code></p>
<p>理由：展示大师Glenford Myers多年软件测试思想和技术，是入门的一本好教材。</p>
<p>2、<code>《软件测试经验和教训》</code>《lessons learned in software testing》</p>
<p>理由：书中分享了3位作者多年的测试经验，知道成功的测试需要什么，书中汇总了293条测试经验建议，可以用于自己的测试工作中，避免一些容易放的错误。经典必读，《赢在测试》中采访的人中有很多个推荐。“红宝书”</p>
<p>3、<code>《A Practitioners Guide  to software Test Design》</code></p>
<p>理由：关注测试用例的一本著作，其中包括白盒、黑盒、与基于经验的测试技术，每个测试技术都结合了技术原理，案例分析和优缺点分析，是每个测试人员了解和应用测试用例设计的一本好书。</p>
<p>4、<code>《思维导图--大脑使用说明书》</code></p>
<p>理由：帮助你提高记忆力和理解力，激发想象力，更好的制定生活和工作计划。</p>
<p>5、<code>《硝烟中的scrum》</code></p>
<p>理由：敏捷入门书，启蒙书</p>
<p>6、<code>《全程软件测试》</code></p>
<p>理由：作者朱少民，测试入门的一本教材，读完后对测试会有一个全面的了解</p>
<p>邰晓梅推荐：</p>
<p>7、<code>《 secret of a buccaneer scholar》</code></p>
<p>理由：中文版《学习要像加勒比海盗》作者：James bach。一本关于自我教育的书，虽然很薄，但是记录了James对自我教育、自我学习方面的认识和经验，这本书相信能让很多爱学习的人受启发。其中的学习态度和方法值得我们去思考。</p>
<p>8、<code>《essential software test design》</code></p>
<p>理由：作者：Torbjorn Ryber 一本关于测试设计的书，书中以测试分析4步法的方式讲述了常用的十几种测试设计技术的应用，并辅以实例。</p>
<p>9、<code>《XUnit test patterns :refactoring test code》</code></p>
<p>理由：作者：Gerard Meszaros 中文版《XUnit测试模式，测试代码重构》，书中对于单元测试的人来说有帮助，书中谈到很多测试代码的坏味道，以及大量被证明的好的测试模式，是的测试代码更易编写和维护。</p>
<p>肖丽琼推荐：</p>
<p>10：<code>《微软梦工厂》</code></p>
<p>理由：励志类，了解软件帝国的精英们是怎么工作和生活的，同是IT人会有很多的共鸣。</p>
<p><code>《学习要像加勒比海盗》</code></p>
<p>高翔推荐：</p>
<p><code>《软件测试经验和教训》</code></p>
<p>11：<code>《探索式软件测试》</code></p>
<p>理由：作者james a whittaker,以“漫游”为核心，提出一套有助于探索式测试的方法。</p>
<p>12：<code>《你的灯还亮着吗？》</code></p>
<p>理由：一本轻快的书，有效的探讨人们如何思考，问题如何定义，如何解决等深刻的主题。</p>
<p>步琼推荐：</p>
<p>13：<code>《beautiful testing》</code></p>
<p>理由：里面有很多项目实例和很好的经验分享，也包括一些测试趣事。</p>
<p>薛继国推荐：</p>
<p>14：<code>《质量免费》</code></p>
<p>理由：详细阐述质量的定义，扩宽思路，提高对产品质量的认识，对于从事测试的人来说有很大的帮助。</p>
<p>王冬推荐：</p>
<p>《全程软件测试》</p>
<p>《软件测试经验和教训》</p>
<hr>
<p>我自己看过觉得不错的测试书籍：</p>
<p>1、<code>《软件测试》</code></p>
<p>理由：Patton的那个版本，第三版，这个很基础，讲解了测试的各方面基础的内容，易懂，可以入门。</p>
<p>2、<code>《从菜鸟到测试架构师》</code></p>
<p>理由：讲述一个菜鸟测试工程师在IBM里是怎么一步步的走到架构师的，书中以故事的形式呈现测试的各个方面，可以当成小说看，也挺有意思的，读完后对整个测试的职业规划会有一定的了解，清楚整个测试行业的职业目标。</p>
<p>3、<code>《性能测试全程详解和案例分析》</code></p>
<p>理由：详细的讲述了性能测试的各个概念，简单易懂，比较全面，是性能测试的入门书，书中还介绍了如何使用测试工具Jmeter进行性能测试。</p>
<p>4、<code>《赢在测试2》</code></p>
<p>理由：看别人的故事总能激励自己，作者采访了十个人，每个人的故事都能给自己一点启发，且他们作为成功人士，对于测试，对于这个行业的了解，他们的经历都有一些共同点。很推荐，可以从他们身上学到很多。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这里推荐了很多书，有一些我看过，或者准备看的书，其中最受大家推荐的就是：<strong>《软件测试经验和教训》</strong></p>
<p>1、<code>《软件测试艺术》</code></p>
<p>理由：展示大师Glenford Myers多年软件测试思想和技术]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="测试" scheme="http://silencewt.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三月，关于团队管理的重要性]]></title>
    <link href="http://silencewt.github.io/2015/04/01/%E4%B8%89%E6%9C%88%EF%BC%8C%E5%85%B3%E4%BA%8E%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <id>http://silencewt.github.io/2015/04/01/三月，关于团队管理的重要性/</id>
    <published>2015-04-01T05:30:59.000Z</published>
    <updated>2015-04-01T13:07:41.000Z</updated>
    <content type="html"><![CDATA[<p>实验室有个项目进行到现在还在改需求，还在处于不确定的状态，这让我整个三月份在技术上都没有一点进步，也让我切切实实的感受到<code>项目需求</code>和<code>团队的重要性</code>。</p>
<p>　　三月份是一个很郁闷的月份，但同样也是一个有所收获的月份，最重要的是对于团队管理有了更深一步的认识，自己在这方面还有待加强。对于项目上的需求管理，项目的开发流程都有了更深的理解。这里所谓更深的理解都是针对自己，都是和自己之前的经历相比，可能这些感触对于另一些人来说是微不足道的。但是个人觉得有必要做一次总结和梳理，以便以后学习。</p>
<h3 id="项目需求管理上：">项目需求管理上：</h3>
<ul>
<li>一个项目不管大的还是小的，项目需求明确才是最重要的。在需求没有明确的情况下，就去开发，之后需求改了，变动过大，之前做的开发就是无用功，那么就是在浪费人力物力，浪费时间。</li>
<li>需求不能只是口头上说说，应该形成书面的文字，就算是小的项目也应该有正规的文档。口头上说，随意性太大，会造成今天这样说，明天忘了，又那样改，整体的变动就会很大，往往需要重新来过，这要在公司里代价就很大。</li>
<li>项目的主管人对于项目的需求要十分明确，不能团队成员问你需求的时候，模棱两可的回答，这会给成员带来不安定，怀疑的心理，进而对整个项目没有信心，缺乏认同感。</li>
</ul>
<p>去年实验室给某公司做一个小项目，开发一个简单的对数据处理的界面软件，我们实验室老板让我们自己和对方联系沟通。这个项目一开始就没有什么正式明确的需求，对方给一个大体的要求和时间，我们实现了之后，给对方看，我们每周交流一次，每周对方都会有新的需求需要我们实现（这好像有点像敏捷），我们也都尽量在原基础上完成。没想到这个小项目持续了三、四个月还没有验收，时不时的有需求要增加，直到最近还要增加一个功能，然后我们发现增加这个功能的话可能会造成原有系统较大的变化，这时改动的代价就很大了。<br>　　整个沟通的过程中，一直没有正式的需求的说明书，就算是之后口头增加的功能也没有一个正式的文档，有几次就出现这周说实现这个功能，下周就说不需要这样，要那样做，变化过大，给人感觉随意性太大。这也让我对这个公司有不好的印象。让我明白文档的重要性，当面沟通可以很好的解决问题，消除歧义，但是口头沟通的内容也需要记录下来形成正式的文档，以便后续的查阅。</p>
<p>　　</p>
<blockquote>
<p>需求阶段没有做好，调研没有做好，就匆忙的开始一个项目，只一味追求结果，那么这个项目会拖延很长的时间，消磨成员耐心。那个项目进行了好几个月，背后的几个月一直在改动，实验室人员已经对其没有兴趣和动力了，都呈现出一种疲乏的状态，大家似乎都明白，做了也白做，反正这个做了也是要改的，还不能等对方确定了再做。</p>
</blockquote>
<p> 虽然，很多时候需求时无法确定下来的，需求的变更也是可以理解的，需求本身就是一种不确定性的因素。但是一个软件，一个项目他的主体的功能是不会变动的，在大体不变的需求确定下，可以采用敏捷的方式开发，这样就不会有架构上大的变化。新需求的提出也会让团队成员更有动力，更有挑战性。而不是一味的在原有基础上改动。<strong>当然我们在做那个项目的时候没有考虑周全，没有很好的实现模块化，使得最后增加功能的时候变得比较麻烦，这也是我们的一个教训，这让我们以后在开发的时候更注重接口和模块化，少耦合</strong>。</p>
<h3 id="团队管理上：">团队管理上：</h3>
<blockquote>
<p>１、负责人需要适时的调动大家的积极性，让团队成员保持热情，增加整个团队的士气。</p>
</blockquote>
<p>　　2015年实验室有个关于嵌入式的项目，这个方面我们大家都没有接触过，大家对硬件都不是很熟。对方公司也对嵌入式不是很懂，所以很希望我们能帮忙，花了将近一个月的时间确定板子，拿到板子后对方对于具体的细节也无法给出一个确切的交代。实验室的人都对嵌入式开发没有一点头绪，这段时间的氛围就很差，都不想做硬件这方面。大家对其也没有热情。<br>　　这个时候我就觉得作为一个领导者就应该适时的增加团队的热情，稳住士气，调动大家的积极性，而不是任由这种情绪一直持续下去，我们老板在这个方面就做的不是很好，他对实验室的人不闻不问，也不在乎实验室的氛围。反而这让我感到很不好，我尽量的起到带头作用，鼓励大家多接触。但是我也知道做一件事情兴趣很重要，没有兴趣很难做成功的。所以，这里就很需要领导者能有魄力，调动大家的积极性，让团队成员保持热情，或者要明白自己的团队擅长的是社么，有挑战就是好处。</p>
<blockquote>
<p>2、一个团队里，每个人都要有一样的目标，都要有对这个团队的责任心，都要有互相沟通的意识。只要一个出现变异，不愿和成员沟通，对项目不闻不问，那么就会影响到整个团队，这种人就应该及时踢出团队（适时的教导无用下）否则会带坏整个团队氛围。维持团队氛围也是一个领导者该做的事情。</p>
</blockquote>
<p>  　　三月份是个繁忙的季节，周围的人都开始忙着找实习，我也不例外，我也想去到一个心仪的公司实习。忙着准备找实习的资料，同样的也忙着实验室的项目，恨不得每天24小时都可以工作，不要休息。实验室有一个男生不爱和我们沟通，不太愿意和我们交流，平时就是自己干自己的，三月份他自己就忙着找实习，项目的事情一点都不过问，但是合作的公司有事情又会打电话给他，他呢，收到消息也不会跟我们说，造成我们团队消息的脱节，往往都是在最后一个阶段才得到消息。<br>  　　其实，我的想法很简单，<strong>既然我们在实验室就应该做好实验室的事情，就应该对这个团队负责，有任何事情都要大家一起商量，互相沟通而不是自己干自己的，人是社会的人，不是太自私。</strong>作为一个领导者，就需要适时的对这个成员进行开导，而在学校这个环境，大家都是平等的学生，也不好说什么，委婉的告知后，还是不理睬，也只能任由他，但要保证其他人不会受到他的影响，实验室其他人都比较开朗，思想个方面都比较接近，不会受到某个人的影响。<strong>只是这些事情让我知道，团队需要一个核心，团队的氛围需要维持，团队之间需要互相交流和沟通，需要每个人的责任心，才能很好的完成一件事情，独来独往是不会成功的。这些都让我感受到团队管理的重要，以前不觉得，现在感触很深，负责人没有做好，会影响到整个团队的士气。</strong></p>
<blockquote>
<p>3、传承，一个领导者不仅要做好管理团队的事情，同时还要做好传承，训练新人的任务。</p>
</blockquote>
<p>　　在学校实验室的这个环境里，每年都会新人加入实验室，也会有人离开，那么离开的人除了做好交接之外，应该考虑如何将新人训练培养出来。实验室每年都会有一个新的负责人，这个负责人就应该统领实验室的事务。今年，师姐走了，我就是负责人，对于师弟师妹我尽可能的去帮助他们熟悉实验室项目，熟悉环境。但是这期间并不是每个人都会致力于实验室的项目的，总会有人不在乎，对实验室的事情不在意，这种人，我只能尽量的和他沟通，把我该做的做好，剩下就看他自己愿不愿意了，毕竟实验室还是一个校园的环境，很多人会过于随意，有些人读研的目的就是混日子，并不是每个人都有目标，都想要改变自己的。这个时候旁人也无法左右他的思想。</p>
<hr>
<p>最后在朋友圈里看到同学发的一个状态：</p>
<blockquote>
<p>一个人快乐或悲伤，只要不是装出来的，就必有其道理。你可以去分享他的快乐，同情他的悲伤，却不可以命令他怎样怎样，因为这是违背人类的天性的。——积极的结论</p>
</blockquote>
<p>写到这里又想到了我是歌手孙楠临时退赛的决定，这不是一个成熟的人该做的事情，退赛时是否由想到整个团队的工作人员，是否有想过整个团队，只能说太任性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>实验室有个项目进行到现在还在改需求，还在处于不确定的状态，这让我整个三月份在技术上都没有一点进步，也让我切切实实的感受到<code>项目需求</code>和<code>团队的重要性</code>。</p>
<p>　　三月份是一个很郁闷的月份，但同样也是一个有所收获的月份，最]]>
    </summary>
    
      <category term="心路历程" scheme="http://silencewt.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="心路历程" scheme="http://silencewt.github.io/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自动化测试及工具的一点理解]]></title>
    <link href="http://silencewt.github.io/2015/03/10/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>http://silencewt.github.io/2015/03/10/自动化测试及工具的一点理解/</id>
    <published>2015-03-10T03:01:39.000Z</published>
    <updated>2015-03-10T03:04:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong>1、回归测试：</strong></p>
<p>　　由于回归测试的测试目标是已有的，稳定的功能，我们会下意识的以为是不会有问题的，并且往往只需要测试一次就行，在这中情况下，如果能有一个稳定的自动化测试脚本来代替手工的操作，将极大的提高工作效率，在关注新功能的同时不会忽略回归测试。而且随着产品版本不断的迭代，叠加的功能也会越来越多，我们会更关注新功能，没有更多的精力和意识去关注既有功能是否被破坏掉了，所以自动化是不二的选择。</p>
<p><strong>2、手工测试和自动化的区别</strong>：</p>
<p> 　　手工测试：测试人员能很好的把握测试用例之间执行的先后顺序，一个个有序的执行测试，后执行的测试可以利用前一个测试执行后所创建的数据记录</p>
<p>　　自动化测试：需要在程序中将脚本的执行顺序显示的用代码表示出来，并且清晰的告诉计算机如何判断结果的正确与否，测试用例之间的依赖关系很难在脚本中清晰的表达出来，运行脚本的人员并不知道用例之间的依赖性。</p>
<p><strong>3、测试环境</strong></p>
<p> 　　我们知道，在测试之前对于测试环境的搭建是很重要的，保证测试环境的正确性、快速的搭建出测试环境，有利于之后测试的顺利进行。一般对于同一个需要测试的软件，系统的环境要求是一样的，要是在不同的机子上测试，每次都需要重新搭建一个环境，这样既耗时又耗费力气，如果能将环境的配置信息编写成脚本，每次只需要运行脚本就可以将环境搭建好，那么节省大量的人力物力。</p>
<p><strong>4、不是所有都是自动化</strong></p>
<p> 　　软件产品开发的特点就是紧急，时间紧，如何在短时间内实现自动化，是否需要自动化都是需要考虑的。如果产品周期短，脚本的开发执行成本远远大于手工执行脚本，在根据之后对于该脚本的执行次数来看，就可以简单的判断是否可以自动化。自动化测试虽然好，但不能一味的将所有的都自动化，自动化投入的时间成本会比较高。自动化框架和脚本的开发是一个投入量很大的项目，而一个可读性不高，健壮性不强的脚本，往往会让测试人员耗费大量的精力去维护，其结果往往得不偿失。所以在脚本开发时要特别注意脚本的了可读性、独立运行性和可重复性，降低后续的维护成本。</p>
<hr>
<p>对于自动化测试工具：</p>
<p>1、<strong>界面自动化测试工具</strong>，我们往往入门的时候都是用的商业或者开源的工具，例如：QTP、RFT之类，这些都是界面级别的自动化测试，界面自动化测试的有一定开发难度，但是确有不少的开源库可以提供，完全可以基于以上库开发，或者有一些开源的工具很成熟了，你所做的就是基于以上进行一下更改。例如：测试java界面的工具就有aboot、swbot、mathron等开源工具，测试web界面的有selenium、watin等，测试移动端的有robotium、monkey等。要能二次开发这些工具，主要是需要理解抓取对象和回放的原理，然后是一些配置文件的处理，对象库里主要是XML的处理，一般录制功能我觉得可以忽略。</p>
<p><strong>2、白盒测试工具</strong>，一些代码级别的测试工具，例如：对代码覆盖率的分析、对代码质量的分析等，这方面涉及较浅，就不随便造次了。</p>
<p><strong>3、接口自动化测试工具</strong>，接口自动化测试工具在开发的时候，首先需要明确业务接口类型，然后掌握一定的接口工具的应用方式，一般的接口工具都是会解析某种接口定义文件，然后将接口文件以界面的形式展现出来，可以通过对界面接口的操作：对某个接口填写参数，然后发送到服务器端，查看响应，或者直接get接口返回值。例如：SoapUI工具是针对WebService系统的测试，主要是解析WSDL接口定义文件。Jmeter和LR也可以做接口测试工具，例如：java接口和HTTP接口等。之前，开发过的接口工具包括：SNMP接口和corba接口工具，其原理也是解析mib和IOR接口定义文件，然后可以对接口进行set与get操作。所以，开发这类的工具，一定要明确什么是软件接口、然后接口描述文件是什么，最后是如何去对接口进行操作，日志和结果的展现等，还有一些就是额外的功能了，例如：录制，将测试人员对接口的操作录制下来，成为工作流等。</p>
<p><strong>4、性能自动化测试工具</strong>，看到性能测试工具，大家很容易想到LR、Jmeter之类，这方面的工具，我用的较少，但是会基于自己公司内部的产品一些特殊性能场景方面的测试，会专门开发一些这样的工具，例如：开发一个发送SNMP网络报文的工具，模拟告警最大接收和并发性能，开发一个网元模拟器，能够模拟大量不同IP的网元，可以在公司网元管理器上测试同时管理的最大网元等。所以，性能测试首先要与业务场景相结合，然后掌握一定的性能基础和指标，分析好相关的接口协议和需要模拟的业务，就可以快速开发相应的工具了。</p>
<p><strong>5、系统应用级别的自动化测试工具</strong>，这种工具需要明确应用场景，即明确需求，例如：我之前开发一些部门内部工具集合，专门提供给测试人员进行脚本录制()、公司级别的有采集和巡检工具。(对外支持)，这部分工具带来的效益是很大的。所以说，千万不要将自动化测试局限在测试方面，其实提高测试与开发的人员的效率、以及对公司产品的质量保障方面的工具都是能给公司带来直接效益的。也许几行代码也是一个能提升效率的好的工具。</p>
<hr>
<p>　　<strong>测试工具虽好但不能迷恋，不能期望测试工具可以取代手工测试。测试工具在测试工作中起的是辅助作用，一般用来提高测试效率。</strong>自动化测试弥补了手工测试的不足，减轻一定的工作量。<strong>实际上测试工具是无法替代大多数手工测试的，而一些诸如性能测试等自动化测试也是手工所不能完成的。</strong></p>
<p>　　对于自动测试技术，<strong>应当依据软件的不同情况来分别对待</strong>，一般自动技术会应用在引起大量重复性工作的地方、系统的压力点、以及任何适合使用程序解决大批量输入数据的地方。然后再<strong>寻找合适的自动测试工具，或者自己开发测试程序。一定不要为了使用测试工具而使用。</strong></p>
<p>　　<strong>我个人认为自动化测试，就是用技术和自动化去服务测试，保证质量，提高产品生产率（不是测试生产力）。无论如何这个行业需求是关键，脱离需求和具体环境，一切都是玩笑。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1、回归测试：</strong></p>
<p>　　由于回归测试的测试目标是已有的，稳定的功能，我们会下意识的以为是不会有问题的，并且往往只需要测试一次就行，在这中情况下，如果能有一个稳定的自动化测试脚本来代替手工的操作，将极大的提高工作效率，在关注新功能的]]>
    </summary>
    
      <category term="测试" scheme="http://silencewt.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试" scheme="http://silencewt.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux文件目录结构详解]]></title>
    <link href="http://silencewt.github.io/2015/03/10/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://silencewt.github.io/2015/03/10/Linux文件目录结构详解/</id>
    <published>2015-03-10T02:51:45.000Z</published>
    <updated>2015-03-10T03:01:14.000Z</updated>
    <content type="html"><![CDATA[<p>整理自《鸟哥的私房菜》</p>
<p>　　对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学好Linux的至关重要的一步.，深入了解linux文件目录结构的标准和每个目录的详细功能，对于我们用好linux系统只管重要，下面我们就开始了解一下linux目录结构的相关知识。</p>
<p>　　当在使用Linux的时候，如果您通过ls –l / 就会发现，在/下包涵很多的目录，比如etc、usr、var、bin … … 等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就象树形结构，所以我们可以把文件系统的结构形象的称为 树形结构。</p>
<p> 　　文件系统的是用来组织和排列文件存取的，所以她是可见的，在Linux中，我们可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/ 起始的树形结构。linux文件系统的最顶端是/，我们称/为Linux的root，也就是 Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。</p>
<p>　　由于linux是开放源代码，各大公司和团体根据linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的PC。因为你根本不知道一些基本的配置，文件在哪里。。。这就造成了混乱。这就是FHS（Filesystem Hierarchy Standard ）机构诞生的原因。该机构是linux爱好者自发的组成的一个团体，主要是是对linux做一些基本的要求，不至于是操作者换一台主机就成了linux的‘文盲’。</p>
<p> 　　根据FHS(<a href="http://www.pathname.com/fhs/)的官方文件指出，" target="_blank" rel="external">http://www.pathname.com/fhs/)的官方文件指出，</a> 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准。 也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。 这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。</p>
<p>　　事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动， </p>
<p>四中类型:</p>
<p>1.可分享的：</p>
<p>可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；</p>
<p>2.不可分享的：</p>
<p>自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</p>
<p>3.不变的：</p>
<p>有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</p>
<p>4.可变动的：</p>
<p>经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</p>
<p>事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：</p>
<p>/ (root, 根目录)：与开机系统有关；</p>
<p>/usr (unix software resource)：与软件安装/执行有关；</p>
<p>/var (variable)：与系统运作过程有关。</p>
<p>一. 根目录 (/) 的意义与内容：</p>
<p>　　根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。</p>
<p>　　因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。</p>
<p>根据以上原因，FHS认为根目录(/)下应该包含如下子目录：</p>
<p><strong>/bin：</strong>系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。</p>
<p><strong>/boot：</strong>主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。</p>
<p><strong>/dev：</strong>在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp<em>, / dev/hd</em>, /dev/sd*等等</p>
<p> <strong>/etc：</strong>系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop</p>
<p><strong>/etc/xinetd.d/ ：</strong>这就是所谓的super daemon管理的各项服务的设定档目录。</p>
<p><strong>/etc/X11/ ：</strong>与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。</p>
<p><strong>/home：</strong>这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号：</p>
<p><strong>~ ：</strong>代表当前使用者的家目录，<br> <strong>~guest：</strong>则代表用户名为guest的家目录。</p>
<p><strong>/lib：</strong>系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。</p>
<p><strong>/media：</strong>media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。</p>
<p><strong>/mnt：</strong>如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。</p>
<p><strong>/opt：</strong>这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。</p>
<p><strong>/root：</strong>系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。</p>
<p><strong>/sbin：</strong>Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</p>
<p><strong>/srv：</strong>srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。</p>
<p><strong>/tmp：</strong>这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。</p>
<p>　　事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下：</p>
<p><strong>/lost+found：</strong>这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found</p>
<p><strong>/proc：</strong>这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？</p>
<p><strong>/sys：</strong>这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。</p>
<p>　　除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。</p>
<p>那哪些<strong>目录不可与根目录分开</strong>呢？有底下这些：</p>
<p>/etc：配置文件</p>
<p>/bin：重要执行档</p>
<p>/dev：所需要的装置文件</p>
<p>/lib：执行档所需的函式库与核心所需的模块</p>
<p>/sbin：重要的系统执行文件</p>
<p>这五个目录千万不可与根目录分开在不同的分区。请背下来啊。</p>
<p>二. /usr 的意义与内容：</p>
<p>　　依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。</p>
<p>　　/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p>
<p>　　因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些：</p>
<p><strong>/usr/X11R6/：</strong>为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。</p>
<p><strong>/usr/bin/：</strong>绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关)</p>
<p><strong>/usr/include/</strong>：c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。</p>
<p><strong>/usr/lib/：</strong>包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生</p>
<p><strong>/usr/local/：</strong>统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录</p>
<p><strong>/usr/sbin/：</strong>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)</p>
<p><strong>/usr/share/：</strong>放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件</p>
<p><strong>/usr/share/doc：</strong>软件杂项的文件说明</p>
<p><strong>/usr/share/zoneinfo：</strong>与时区有关的时区文件</p>
<p><strong>/usr/src/：</strong>一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。</p>
<p>三.  /var 的意义与内容：</p>
<p>　　如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：</p>
<p><strong>/var/cache/：</strong>应用程序本身运作过程中会产生的一些暂存档</p>
<p><strong>/var/lib/：</strong>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去</p>
<p><strong>/var/lock/</strong>：某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用</p>
<p><strong>/var/log/</strong>：非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。</p>
<p><strong>/var/mail/</strong>：放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。</p>
<p><strong>/var/run/</strong>：某些程序或者是服务启动后，会将他们的PID放置在这个目录下</p>
<p><strong>/var/spool/</strong>：这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。</p>
<p>　　由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。</p>
<p>四. 目录树(directory tree) :</p>
<p>　　在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：</p>
<p>目录树的启始点为根目录 (/, root)；<br>　　每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。<br>　　每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。<br>如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话． </p>
<p>五. 绝对路径与相对路径</p>
<p>　　除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：</p>
<p>绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；</p>
<p>相对路径：相对于目前路径的文件名写法。 例如 ./home/n1516 或 等等。反正开头不是 / 就属于相对路径的写法</p>
<p>而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？</p>
<p>cd /var/log   (absolute)</p>
<p>cd ../var/log (relative)</p>
<p>因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：</p>
<p>.  ：代表当前的目录，也可以使用 ./ 来表示；</p>
<p>.. ：代表上一层目录，也可以 ../ 来代表。</p>
<p>这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。</p>
<p>实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？</p>
<p>命令：<br>cd /var/spool/mail<br>cd ../cron<br>说明：<br>　　由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。这个相对路径是非常有帮助的，尤其对于某些软件开发商来说。 一般来说，软件开发商会将数据放置到/usr/local/里面的各相对目录。 但如果用户想要安装到不同目录呢？就得要使用相对路径。</p>
<p>实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？<br>说明：<br>　　由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>整理自《鸟哥的私房菜》</p>
<p>　　对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学好Linux的至关重要的一步.，深入了解linux文件目录结构的标准和每个目录的详细功能，对于我们用好linux系统只管重要，下面我们就开始了解一下linux目录]]>
    </summary>
    
      <category term="Linux" scheme="http://silencewt.github.io/tags/Linux/"/>
    
      <category term="Linux" scheme="http://silencewt.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python 批量更换图片格式脚本]]></title>
    <link href="http://silencewt.github.io/2015/02/01/python-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%8D%A2%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%84%9A%E6%9C%AC/"/>
    <id>http://silencewt.github.io/2015/02/01/python-批量更换图片格式脚本/</id>
    <published>2015-02-01T13:52:23.000Z</published>
    <updated>2015-02-01T13:54:49.000Z</updated>
    <content type="html"><![CDATA[<p>问题：将某文件下的所有jpg的图片更换为png的图片</p>
<p>简单的实现:</p>
<pre><code><span class="comment"># -*- coding:utf-8 -*-</span>
<span class="keyword">from</span> os.path <span class="keyword">import</span> splitext
<span class="keyword">import</span> glob
<span class="keyword">from</span> PIL <span class="keyword">import</span> Image

<span class="function"><span class="keyword">def</span> <span class="title">get_all_file</span><span class="params">(filename)</span>:</span>
    files = glob.glob(filename)
    <span class="keyword">return</span> files

<span class="function"><span class="keyword">def</span> <span class="title">to_ather_file</span><span class="params">(files, type)</span>:</span>
    <span class="keyword">for</span> jpg <span class="keyword">in</span> files:
        im = Image.open(jpg)
        png = splitext(jpg)[<span class="number">0</span>]+<span class="string">"."</span> + type
        im.save(png)
        <span class="keyword">print</span> png


<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    filename = <span class="string">"./image/*.[Jj][Pp][Gg]"</span>
    files = get_all_file(filename)
    to_ather_file(files, <span class="string">"png"</span>)
</code></pre><p>　　这是一种很简单的是实现方法，就是先用glob获得某路径下的所有文件，该文件下都是jpg图片（题目是给定的，也可以考虑存在其他图片的情况的处理方式，就是获得文件的后缀名，判断是否为jpg），然后依次读入图片，使用splitext获得文件名和后缀名，然后按照要求重组文件名并保存就好了。</p>
<p>这里介绍两个部分：</p>
<p><strong>glob模块：</strong></p>
<p>在python中，glob模块是用来查找匹配的文件的    在查找的条件中，需要用到Unix shell中的匹配规则：     </p>
<p>  *    :   匹配所所有       </p>
<p>  ?    :   匹配一个字符       </p>
<p>*.*  :   匹配如：[hello.txt,cat.xls,xxx234s.doc]     </p>
<p>  ?.*  :   匹配如：[1.txt,h.py]     </p>
<p>  ?.gif:   匹配如：[x.gif,2.gif]   </p>
<p> 可以参考：fnmatch    如果没有匹配的，glob.glob(path)将返回一个空的list:[]</p>
<p>也就说：glob是用来寻找文件的。某种命名规则的文件的。</p>
<pre><code><span class="keyword">import</span> glob

 <span class="function"><span class="keyword">def</span> <span class="title">get_all</span><span class="params">()</span>:</span>
     <span class="string">'''获取目录[c:\\tmp]下面所有的文件'''</span>
     <span class="keyword">return</span> glob.glob(<span class="string">'c:\\tmp\\*.*'</span>)

 <span class="function"><span class="keyword">def</span> <span class="title">get_my_file</span><span class="params">()</span>:</span>
     <span class="string">'''获取目录[c:\\tmp]下面文件名为4个字符的文件'''</span>
     <span class="keyword">return</span> glob.glob(<span class="string">'c:\\tmp\\????.txt'</span>)

 <span class="function"><span class="keyword">def</span> <span class="title">get_batch_file</span><span class="params">()</span>:</span>
     <span class="string">'''获取目录[c:\\tmp]下面扩展名为\'.txt\'的文件'''</span>
     <span class="keyword">return</span> glob.glob(<span class="string">'c:\\tmp\\*.txt'</span>)

 <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>
     print(<span class="string">'获取目录[c:\\tmp]下面所有的文件：'</span>)
     tem_files = get_all()
     print(tem_files)
     print(<span class="string">'获取目录[c:\\tmp]下面文件名为4个字符的文件：'</span>)
     tem_files = get_my_file()
     print(tem_files)
     print(<span class="string">'获取目录[c:\\tmp]下面扩展名为\'.txt\'的文件：'</span>)
     tem_files = get_batch_file()
     print(tem_files)

 <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
     main()
</code></pre><p>　　</p>
<p><strong>python文件操作：</strong><br>有关文件夹与文件的查找，删除等功能 在 os 模块中实现。使用时需先导入这个模块，</p>
<p>导入的方法是:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> os</span>
</code></pre><p>1、将一个路径名分解为目录名和文件名两部分</p>
<pre><code>fpath , fname = os.path.<span class="built_in">split</span>( <span class="string">"你要分解的路径"</span>)
</code></pre><p>例如：</p>
<pre><code><span class="keyword">a</span>, <span class="keyword">b</span> = os.path.<span class="built_in">split</span>( <span class="string">"c:\\123\\456\\test.txt"</span> )

<span class="keyword">print</span> <span class="keyword">a</span>

<span class="keyword">print</span> <span class="keyword">b</span>
</code></pre><p>显示：</p>
<pre><code><span class="built_in">c</span>:\<span class="number">123</span>\<span class="number">456</span>

test.txt
</code></pre><p>2、 分解文件名的扩展名</p>
<pre><code>fpathandname , fext = <span class="built_in">os</span>.path.splitext( <span class="string">"你要分解的路径"</span>)
</code></pre><p>例如：</p>
<pre><code>a, b = os.path.splitext( <span class="string">"c:\\123\\456\\test.txt"</span> )

print a

print b
</code></pre><p>显示：</p>
<pre><code><span class="built_in">c</span>:\<span class="number">123</span>\<span class="number">456</span>\test

.txt
</code></pre><p>文件操作还有很多有用的函数，可以通过查找手册来看。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>问题：将某文件下的所有jpg的图片更换为png的图片</p>
<p>简单的实现:</p>
<pre><code><span class="comment"># -*- coding:utf-8 -*-</span>
<span class="keyword">from</s]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python类似微信未读信息图片脚本]]></title>
    <link href="http://silencewt.github.io/2015/02/01/python%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E6%9C%AA%E8%AF%BB%E4%BF%A1%E6%81%AF%E5%9B%BE%E7%89%87%E8%84%9A%E6%9C%AC/"/>
    <id>http://silencewt.github.io/2015/02/01/python类似微信未读信息图片脚本/</id>
    <published>2015-02-01T13:32:18.000Z</published>
    <updated>2015-02-01T14:04:24.000Z</updated>
    <content type="html"><![CDATA[<p>其实就是实现一个效果，给一张图片，然后再右上角给出未读的信息数目，就像我们打开微信的时候，总是看到红点就忍不住想要点击去查看一样。</p>
<p>类似这种效果：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/new_weixin.jpg" alt="weixn"></p>
<p>可以知道，图片是给定的，那么只要随机生成一个数字，然后再在图片的右上角显示出来就好了，这里可以使用PIL，这样就比较方便的实现了，</p>
<p>代码：</p>
<pre><code><span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageDraw, ImageFont

<span class="keyword">import</span> random

origin_image = <span class="string">"./image/test.jpg"</span>
new_image = <span class="string">"./image/new_test.jpg"</span>
color = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)

<span class="function"><span class="keyword">def</span>  <span class="title">numRandom</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> random.randint(<span class="number">0</span>, <span class="number">100</span>)

<span class="function"><span class="keyword">def</span> <span class="title">draw_text_for_image</span><span class="params">(text, origin_image,fill_color)</span>:</span>
<span class="keyword">try</span>:
    image = Image.open(origin_image)
    size = image.size
    x = size[<span class="number">0</span>] - <span class="number">60</span>
    font = ImageFont.truetype(<span class="string">"arial.ttf"</span>, <span class="number">36</span>)
    draw = ImageDraw.Draw(image)
    draw.text((x, <span class="number">15</span>), text, font=font, fill=fill_color)
    image.save(new_image,<span class="string">'jpeg'</span>);
<span class="keyword">except</span> :
    <span class="keyword">print</span> <span class="string">"Unable to load image"</span>

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    text = str(numRandom())
    draw_text_for_image(text,origin_image,color)    
</code></pre><p>先得到需要的图片和保存的图片路径，利用随机数产生一个随机数字，ImageDraw实现在图片是添加文字。</p>
<p>image.size获得图片的长宽，返回一个元祖。</p>
<p>这里说说最后一个__name__ ==\ “__main__“:</p>
<p>　　当打开一个.py文件时,经常会在代码的最下面看到if __name<strong> == “__main</strong>“:</p>
<p>　　模块是对象,并且所有的模块都有一个内置属性name。一个模块的 _<em>name<strong> 的值取决于您如何应用模块。如果 import 一个模块，那么模块\</strong>name<strong> 的值通常为模块文件名，不带路径或者文件扩展名。但是您也可以像一个标准的程序样直接运行模块，在这 种情况下,\</strong>name<strong> 的值将是一个特别缺省”\</strong>main_</em>“。</p>
<p>在cmd 中直接运行.py文件，则__name__的值是’__main__‘；</p>
<p>而在import 一个.py文件后，__name__的值就不是’__main__‘了；</p>
<p>从而用if __name__ == ‘__main__‘来判断是否是在直接运行该.py文件</p>
<p>如:</p>
<pre><code><span class="comment">#Test.py</span>

<span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span>

<span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self)</span>:</span><span class="keyword">pass</span>

<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span><span class="keyword">print</span> <span class="string">'Hello, World!'</span>

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:

Test().f()

<span class="comment">#End</span>
</code></pre><p>你在cmd中输入：</p>
<p>C:&gt;python Test.py</p>
<p>Hello, World!</p>
<p>说明：”_<em>name<strong> == ‘\</strong>main_</em>‘“是成立的</p>
<p>你再在cmd中输入:</p>
<p>C:&gt;python</p>
<p>>&gt;&gt;import Test</p>
<p>>&gt;&gt;Test._<em>name<strong>                #Test模块的\</strong>name_</em></p>
<p>‘Test’</p>
<p>>&gt;&gt;_<em>name<strong>                       #当前程序的\</strong>name_</em></p>
<p>‘_<em>main_</em>‘</p>
<p>无论怎样，Test.py中的”_<em>name<strong> == ‘\</strong>main_</em>‘“都不会成立的!</p>
<p>所以，下一行代码永远不会运行到</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实就是实现一个效果，给一张图片，然后再右上角给出未读的信息数目，就像我们打开微信的时候，总是看到红点就忍不住想要点击去查看一样。</p>
<p>类似这种效果：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/new_w]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python生成验证码脚本]]></title>
    <link href="http://silencewt.github.io/2015/02/01/python%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%E8%84%9A%E6%9C%AC/"/>
    <id>http://silencewt.github.io/2015/02/01/python生成验证码脚本/</id>
    <published>2015-02-01T13:14:07.000Z</published>
    <updated>2015-02-01T13:15:40.000Z</updated>
    <content type="html"><![CDATA[<p>最近每天都用python写一个小的脚本，练习使用python语法。</p>
<p>验证码的生成：</p>
<p>这里使用了python的图像处理库PIL，安装PIL的过程中出了一个小麻烦，就使用Pillow-win32的一个文件，具体的我也忘了，可以百度下。</p>
<p>直接看代码：</p>
<pre><code><span class="comment"># -*- coding:utf-8 -*-</span>

<span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageFont,ImageDraw,ImageFilter
<span class="keyword">import</span> random
<span class="comment">#返回随机字母</span>
<span class="function"><span class="keyword">def</span> <span class="title">charRandom</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> chr((random.randint(<span class="number">65</span>,<span class="number">90</span>)))
<span class="comment">#返回随机数字</span>
<span class="function"><span class="keyword">def</span> <span class="title">numRandom</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> random.randint(<span class="number">0</span>,<span class="number">9</span>)
<span class="comment">#随机颜色</span>
<span class="function"><span class="keyword">def</span> <span class="title">colorRandom1</span><span class="params">()</span>:</span>
<span class="keyword">return</span>       (random.randint(<span class="number">64</span>,<span class="number">255</span>),random.randint(<span class="number">64</span>,<span class="number">255</span>),random.randint(<span class="number">64</span>,<span class="number">255</span>))
<span class="comment">#随机长生颜色2</span>
<span class="function"><span class="keyword">def</span> <span class="title">colorRandom2</span><span class="params">()</span>:</span>
<span class="keyword">return</span> (random.randint(<span class="number">32</span>,<span class="number">127</span>),random.randint(<span class="number">32</span>,<span class="number">127</span>),random.randint(<span class="number">32</span>,<span class="number">127</span>))

width = <span class="number">60</span> * <span class="number">4</span>
height = <span class="number">60</span>
image = Image.new(<span class="string">'RGB'</span>, (width,height), (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));
<span class="comment">#创建font对象</span>
font = ImageFont.truetype(<span class="string">'Arial.ttf'</span>,<span class="number">36</span>);

<span class="comment">#创建draw对象</span>
draw = ImageDraw.Draw(image)
<span class="comment">#填充每一个颜色</span>
<span class="keyword">for</span> x <span class="keyword">in</span> range(width):
    <span class="keyword">for</span> y <span class="keyword">in</span> range(height):
        draw.point((x,y), fill=colorRandom1())

<span class="comment">#输出文字</span>
<span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">4</span>):
    draw.text((<span class="number">60</span>*t+<span class="number">10</span>,<span class="number">10</span>), charRandom(),font=font, fill=colorRandom2())

<span class="comment">#模糊</span>
image = image.filter(ImageFilter.BLUR)
image.save(<span class="string">'./image/code.jpg'</span>,<span class="string">'jpeg'</span>)
</code></pre><p>PIL对于图像的处理还是可以的：</p>
<p>这里是官方的文档：<a href="http://effbot.org/imagingbook/" target="_blank" rel="external">http://effbot.org/imagingbook/</a> 讲的很详细</p>
<p>Image 类是 PIL 库中一个非常重要的类，通过这个类来创建实例可以有直接载入图像文件，读取处理过的图像和通过抓取的方法得到的图像这三种方法。可以对图形进行简单的操作例如旋转、裁剪、缩小放大，滤波等等。</p>
<p>ImageFont模块是字体模块，可以对字体进行设置</p>
<p>上面程序的思想：</p>
<pre><code><span class="number">1</span>、定义了几个随机获取颜色和数字字母的函数，获得验证码的文字

<span class="number">2</span>、Image.<span class="keyword">new</span>生成一个黑色的画布，也就是图片，大小<span class="number">60</span>*<span class="number">240</span>

<span class="number">3</span>、ImageFont定义图片上将使用的字体

<span class="number">4</span>、对该图片生成一个draw对象，通过该draw对象，改变图像的像素，使用随见长生的颜色

<span class="number">5</span>、在图片上产生文字，文字也使用随机的颜色

<span class="number">6</span>、对图片进行模糊化处理

<span class="number">7</span>、将图片保存
</code></pre><p>最后就可以在image文件下得到code.jpg 的图片<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/code.jpg" alt="code"></p>
<p><strong>扩展：</strong></p>
<p>可以的话，还可以通过draw对象在图片上随机产生几根线条，将验证码变得更难看懂，可以将文字倾斜等等。</p>
<pre><code>image.rotate(random.randint(<span class="number">0</span>,<span class="number">30</span>),expand=<span class="number">0</span>)

<span class="function"><span class="keyword">def</span> <span class="title">randomLine</span><span class="params">(self, num)</span>:</span>
　　draw = ImageDraw.Draw(self.image)
　　<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,num):
　　draw.line([self.randomPoint(),self.randomPoint()], self.randomRGB())
　　<span class="keyword">del</span> draw
</code></pre><p>　　</p>
<p>　　关于验证码还有很多可以值得看的，之前在用opencv的时候，就想着做一个验证码识别的程序，从而可以实现自动登入系统，不需要每次都手工输入验证码，这好像也是图灵研究的一部分，也是人和机器的区分标志，<strong>全自动区分计算机和人类的图灵测试</strong>（英语：Completely Automated Public Turing test to tell Computers and Humans Apart，简称<strong>CAPTCHA</strong>），俗称验证码。具体的可以百度了解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近每天都用python写一个小的脚本，练习使用python语法。</p>
<p>验证码的生成：</p>
<p>这里使用了python的图像处理库PIL，安装PIL的过程中出了一个小麻烦，就使用Pillow-win32的一个文件，具体的我也忘了，可以百度下。</p>
<p>]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python学习笔记（三）]]></title>
    <link href="http://silencewt.github.io/2015/01/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://silencewt.github.io/2015/01/17/python学习笔记（三）/</id>
    <published>2015-01-17T12:27:50.000Z</published>
    <updated>2015-01-17T12:28:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="函数式编程："><strong>函数式编程</strong>：</h4>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python内建了map()和reduce()函数。</p>
<p>map()：函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。举例：有一个函数f(x)=x^2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<p>>&gt;&gt;map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])<br>[1, 4, 9, 16, 25, 36, 49, 64, 81]</p>
<p>reduce()：把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>>&gt;&gt; def fn(x, y): …<br>return x * 10 + y …<br>>&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])<br>13579</p>
<p>filter()：和map()类似，也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<p>在一个list中，删掉偶数，只保留奇数，可以这么写：<br>def is_odd(n):<br>    return n % 2 == 1<br> filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]) # 结果: [1, 5, 9, 15]</p>
<p>sorted()：该函数可以对list进行排序，sorted([36, 5, 12, 9, 21])。它也是一个高阶函数，可以接收一个比较函数来实现自定义的排序。比如，如果要倒序排序，就可以自定义一个reversed_cmp函数：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">reversed_cmp</span><span class="params">(x, y)</span>:</span>    
<span class="keyword">if</span> x &gt; y:       
    <span class="keyword">return</span> -<span class="number">1</span>   
<span class="keyword">if</span> x &lt; y:       
     <span class="keyword">return</span> <span class="number">1</span>    
<span class="keyword">return</span> <span class="number">0</span>
</code></pre><p>传入自定义的比较函数reversed_cmp，就可以实现倒序排序：</p>
<p>>&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp) [36, 21, 12, 9, 5]</p>
<hr>
<h4 id="面向对象编程"><strong>面向对象编程</strong></h4>
<p><strong>类</strong>：</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span>               
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span>        
        self.name = name         
        self.score = score
</code></pre><p> 　　Student类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 <strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创#建的实例本身。有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</p>
<p>　　类中定义的函数和其他函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，仍然可以用默认参数、可变参数和关键字参数。</p>
<p>外部代码还是可以自由地修改一个实例的name、score属性</p>
<p>＼&gt;&gt;&gt; bart = Student(‘Bart Simpson’, 98)<br>＼&gt;&gt;&gt; bart.score<br> 98<br>＼&gt;&gt;&gt; bart.score = 59</p>
<p>　　如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<strong>。self.</strong>name = name，self.__score = score</p>
<p>　　在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<p>　　在Python中，变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，不能用<strong>name</strong>、<strong>score</strong>这样的变量名。</p>
<p><strong>多态</strong>：</p>
<p>　　当我们定义一个class的时候，就相当于定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p>
<p>判断一个变量是否是某个类型可以用isinstance()判断：</p>
<p>＼&gt;&gt;&gt; isinstance(a, list)</p>
<p>true 或 false</p>
<p>在调用类实例方法的时候，变量视作父类类型，这样，所有子类类型都可以正常被接收。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="函数式编程："><strong>函数式编程</strong>：</h4>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python内建了map()和reduce()函数。</p>
<p>map()：函数]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python学习笔记（二）]]></title>
    <link href="http://silencewt.github.io/2015/01/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://silencewt.github.io/2015/01/17/python学习笔记（二）/</id>
    <published>2015-01-17T12:16:48.000Z</published>
    <updated>2015-01-17T12:22:55.000Z</updated>
    <content type="html"><![CDATA[<h4 id="List："><strong>List</strong>：</h4>
<p>list是一种有序的集合，可以随时添加和删除其中的元素。List里面的元素可以是不同类型的，也可以是list，嵌套，相当于二维数组。list=[‘dfs’,’DSF’,123]，空的list=[]</p>
<p>len（）：函数可以获得list元素的个数</p>
<p>list[0]: 下标为0的元素值</p>
<p>list[-1]：倒数第一个元素，即最后一个数</p>
<p>pop（）：弹出末尾的元素</p>
<p>pop（i）：弹出第i个元素</p>
<p>append（）：list中追加元素到末尾</p>
<p>insert（1，“”）：把元素插入到指定的位置，比如索引号为1的位置。</p>
<p>sort()：对元素排序</p>
<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置可变也不可变对象：</p>
<p>字符串是不可变的，比如str=”apple”；str.replace(‘a’, ‘A’) 这个的结果是Apple，但是str还是apple</p>
<p>list是可变的：比如list = [1,2,4,3,5]; list.sort(); 这个结果是12345，list的结果也是12345</p>
<p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<hr>
<h4 id="tuple："><strong>tuple</strong>：</h4>
<p>有序列表叫元组。tuple和list非常类似，但是tuple一旦初始化就不能修改，没有append()，insert()这样的方法。其他获取元素的方法和list是一样的。当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来。tuple=（’dfs’,’DSF’,123），空的tuple=（）；只有一个元素的tuple=(1，)</p>
<p>在显示只有1个元素的tuple时，也要加一个逗号,，以免误解成数学计算意义上的括号。</p>
<p>“可变”的tuple：tuple = (‘a’, ‘b’, [‘A’, ‘B’])；tuple[2][0]=’x’；tuple=[2][1]=’y’；这时候在输出tuple为(‘a’, ‘b’, [‘x’, ‘y’])？</p>
<p>这个tuple定义的时候有3个元素，分别是’a’，’b’和一个list。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/a.jpg" alt="a"></p>
<p>之后修改list的值，变为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/2.jpg" alt="q"></p>
<p>tuple指向的值并没有变化，变化的只是list指向的值，tuple一开始指向的list并没有改成别的list，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>
<hr>
<h4 id="字典："><strong>字典</strong>：</h4>
<p>dictionary，相当于map，一个键值对，使用大括号，dict = {‘apple’： 1，‘bananan’：2， ’orange‘：3}。相应的使用dict[‘apple’]就可以得到1。</p>
<p>这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。多次对一个key放入value，后面的值会把前面的值冲掉即更新。key必须是不可变对象。</p>
<p>判断是否存在key：一、可以使用in ：’apple’ in dict 输出 true。二、通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：dict.get（’apple’），dict.get（’apple’,-1）。</p>
<p>pop(key)方法，删除一个key，对应的value也会从dict中删除</p>
<p>和list比较，dict有以下几个特点：</p>
<p>查找和插入的速度极快，不会随着key的增加而增加；</p>
<p>需要占用大量的内存，内存浪费多。</p>
<p>而list相反：</p>
<p>查找和插入的时间随着元素的增加而增加；</p>
<p>占用空间小，浪费内存很少。</p>
<p>所以，dict是用空间来换取时间的一种方法。</p>
<hr>
<h4 id="set："><strong>set：</strong></h4>
<p>set和dict类似，也是一组key的集合，但不存储value。在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：s=set([1,2,3])，重复的值会自动过滤：s=set([1,2,2,3,3]) 为set([1,2,3])</p>
<p>add(key)：方法可以添加元素到set中</p>
<p>remove(key)：方法可以删除元素</p>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作（s1 &amp; s2 | S3)</p>
<hr>
<h4 id="切片Slice："><strong>切片Slice</strong>：</h4>
<p>L[0:3]：L[:3]取前3个元素，从索引0开始取，直到索引3为止，但不包括索引3。</p>
<p>L[-2:]：倒数两个数（后两个数），最后一个数的索引是-1</p>
<p>L[-2:-1]：倒数第二个数，这个时候不包括-1即最后一个数。</p>
<p>L[:：5]：每5个数取一个，</p>
<hr>
<h4 id="迭代："><strong>迭代</strong>：</h4>
<p>给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple。for…..in </p>
<p>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()。</p>
<p>由于字符串也是可迭代对象，因此，也可以作用于for循环：for ch in ‘ABC’</p>
<p>使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，不必知道该对象究竟是list还是其他数据类型。</p>
<p>如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：</p>
<p>>&gt;&gt; from collections import Iterable<br>>&gt;&gt; isinstance(‘abc’, Iterable) # str是否可迭代<br> True</p>
<p>如果要对list实现类似Java那样的下标循环？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p>
<p>>&gt;&gt; for i, value in enumerate([‘A’, ‘B’, ‘C’]):<br> …     print i, value …<br>0 A<br>1 B</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="List："><strong>List</strong>：</h4>
<p>list是一种有序的集合，可以随时添加和删除其中的元素。List里面的元素可以是不同类型的，也可以是list，嵌套，相当于二维数组。list=[‘dfs’,’DSF’,123]，空的lis]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python学习笔记（一）]]></title>
    <link href="http://silencewt.github.io/2015/01/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://silencewt.github.io/2015/01/17/python学习笔记（一）/</id>
    <published>2015-01-17T12:02:24.000Z</published>
    <updated>2015-01-17T12:14:16.000Z</updated>
    <content type="html"><![CDATA[<p>这个python记录的有点乱，都是在看电子档资料的时候，记录下来的。</p>
<p>1、学习Python与其他语言最大的区别就是，Python的代码块不使用大括号（{}）来控制类，函数以及其他逻辑判断。python最具特色的就是用缩进来写模块。</p>
<p>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行</p>
<p>2、Python语句中一般以新行作为为语句的结束符。但是可以使用斜杠（ \）将一行的语句分为多行显示，但是如果包含[], {} 或 () 括号就不需要使用多行连接符。</p>
<p>3、Python 接收单引号(‘ )，双引号(“ )，三引号(‘’’ “””) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法</p>
<p>4、注释采用#，还有一种文档字符串的特别注释。你可以在模块、类或者函数的起始添加一个字符串，起到在线文档的功能。与普通注释不同，文档字符串可以在运行时访问，也可      以用来自动生成文档。</p>
<p>5、Python中的变量不需要声明，变量的赋值操作既是变量声明和定义的过程。每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>6、可以为多个对象指定多个变量：a, b, c = 1, 2, “john” 即将1赋给a,2赋给b,john赋给c。</p>
<p>7、Python有五个标准的<strong>数据类型</strong>：</p>
<p>Numbers（数字）：int  long(L)  float complex</p>
<p>String（字符串）:python的字串列表有2种取值顺序:从左到右索引默认0开始的，最大范围是字符串长度少1，从右到左索引默认-1开始的，最大范围是字符串开头。+是字符串连接运算符，星号（<em>）是重复操作（print str</em>2输出两个str）；[:]表示截取字符串的一部分</p>
<p>List（列表）：list = [ ‘abcd’, 786 , 2.23, ‘john’, 70.2 ]列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>Tuple（元组）：用”()”标识。内部元素用逗号隔开。但是元素不能二次赋值（不能修改也不能删除），相当于只读列表，只有一个元素时要留有逗号a=(1,)；可以使用del删除整个元祖</p>
<p>Dictionary（字典）：用”{ }”标识，由索引(key)和它对应的值value组成。结构类似json</p>
<p>列表：是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>python创建对象后，数据类型是不允许改变的，只能用del var1,var2来删除多个对象。</p>
<p>字典：字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，键必须不可变，可以用数，字符串或元组充当，但不可以用列表就不行，</p>
<hr>
<p>python算术运算符</p>
<p>*<em>：幂运算 2*</em>3=8</p>
<p>//：取整数 返回商的整数部分  9.0//2.0=4.0</p>
<p>and：(a and b) 返回 true，类似的有or 和 not</p>
<p>in：成员运算符   x in y 如果x在y中，则为TRUE，not in 表示为x不在y中怎为TRUE </p>
<p>is:身份运算符is是判断两个标识符是不是引用自一个对象（返回结果 1），is not是判断两个标识符是不是引用自不同对象</p>
<hr>
<p>python流程控制</p>
<pre><code><span class="number">1</span>、<span class="keyword">if</span> 判断条件：

      执行语句……

 <span class="keyword">else</span>：（<span class="keyword">elif</span> 判断条件:）

      执行语句……
</code></pre><p> 　　python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or 或and</p>
<pre><code><span class="number">2</span>、<span class="keyword">while</span> 判断条件：

        执行语句……

  <span class="keyword">else</span>：
</code></pre><p>　　在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while     … else 也是一样。while 可以循环嵌套</p>
<pre><code><span class="number">3</span>、<span class="keyword">for</span> itareting_var <span class="keyword">in</span> <span class="keyword">sequence</span>

       statement(s)
</code></pre><hr>
<p>Python函数</p>
<p>函数代码块以def关键词开头，后接函数标识符名称和圆括号()。<br>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。<br>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>函数内容以冒号起始，并且缩进。<br>Return[expression]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</p>
<p>定义一个什么事也不做的空函数，可以用pass语句<br>函数返回多值，其实就是一个tuple：x,y=myfun() == r=myfun(),r=(x,y)</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">( parameters )</span>:</span>
   <span class="string">"函数_文档字符串"</span>
   function_suite
   <span class="keyword">return</span> [expression]
</code></pre><p>所有参数（自变量）在Python里都是按引用传递。如果你在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。</p>
<p><strong>默认参数</strong>：</p>
<p>先定义一个函数，传入一个list，添加一个END再返回：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span>    

    L.append(<span class="string">'END'</span>)    

    <span class="keyword">return</span> L
</code></pre><p>当你正常调用时，结果似乎不错：</p>
<p>＼&gt;&gt;&gt; add_end([1, 2, 3])<br>[1, 2, 3, ‘END’]<br>＼&gt;&gt;&gt; add_end([‘x’, ‘y’, ‘z’])<br> [‘x’, ‘y’, ‘z’, ‘END’]</p>
<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<p>＼&gt;&gt;&gt; add_end()<br>[‘END’]</p>
<p>但是，再次调用add_end()时，结果就不对了：</p>
<p>＼&gt;&gt;&gt; add_end()<br> [‘END’, ‘END’]<br>＼&gt;&gt;&gt; add_end()<br>[‘END’, ‘END’, ‘END’]</p>
<p>　　很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了’END’后的list。</p>
<p>原因解释如下：</p>
<p>　　Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<p>所以，定义默认参数要牢记一点：<strong>默认参数必须指向不变对象</strong>！</p>
<p>要修改上面的例子，我们可以用None这个不变对象来实现：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span>   
    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:        
        L = []    
    L.append(<span class="string">'END'</span>)    
    <span class="keyword">return</span> L
</code></pre><p>现在，无论调用多少次，都不会有问题：</p>
<p>＼&gt;&gt;&gt; add_end()<br>[‘END’]<br>＼&gt;&gt;&gt; add_end()<br>[‘END’]</p>
<p>　　为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
<p><strong>可变参数</strong>：</p>
<p>参数个数不确定，可以把a，b，c……作为一个list或tuple传进来，函数定义如下：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span>   
<span class="keyword">for</span> i <span class="keyword">in</span> numbers:
</code></pre><p>在调用的时候，需要先组装出一个list或tuple：</p>
<p>＼&gt;&gt;&gt; calc([1, 2, 3])</p>
<p>如果利用可变参数，函数的参数改为可变参数：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span>   
 <span class="keyword">for</span> n <span class="keyword">in</span> numbers:
</code></pre><p>调用函数的方式可以简化成这样：</p>
<p>＼&gt;&gt;&gt; calc(1, 2, 3)</p>
<p>　　定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：calc()</p>
<p>　　如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p>
<p>＼&gt;&gt;&gt; nums = [1, 2, 3]<br>＼&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</p>
<p>　　但是这样太繁琐，可以在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：</p>
<p>＼&gt;&gt;&gt; nums = [1, 2, 3]<br>＼&gt;&gt;&gt; calc(*nums)</p>
<p><strong>关键字参数：</strong></p>
<p>　　关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span>
</code></pre><p>　　函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p>
<p>＼&gt;&gt;&gt; person(‘Michael’, 30)</p>
<p>也可以传入任意个数的关键字参数：</p>
<p>＼&gt;&gt;&gt; person(‘Bob’, 35, city=’Beijing’)</p>
<p>　　关键字参数可以扩展函数的功能。比如，在person函数里，可以保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，函数也能收到。试想做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<p>也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>
<p>＼&gt;&gt;&gt; kw = {‘city’: ‘Beijing’, ‘job’: ‘Engineer’} </p>
<p>＼&gt;&gt;&gt; person(‘Jack’, 24, city=kw[‘city’], job=kw[‘job’]) 或者 person(‘Jack’, 24, **kw)</p>
<p><strong>参数组合：</strong></p>
<p>将上面三种参数组合：def func(a, b, c=0, <em>args,**kw):  解释器自动按照参数位置和参数名把对应的参数传进去所以，对于任意函数，都可以通过类似func(\</em>args, **kw)的形式调用它，无论它的参数是如何定义的。</p>
<hr>
<p><strong>匿名函数</strong>：lambda   lambda [arg1 [,arg2, ….argn]] : expression</p>
<p>　　用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。</p>
<p>　　Lambda函数能接收任何数量的参数但只能返回一个表达式的值，同时只能不能包含命令或多个表达式。</p>
<p>　　匿名函数不能直接调用print，因为lambda需要一个表达式。lambda函数拥有自己的名字空间，且不能访问自有参数列表之外或全局名字空间里的参数。虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</p>
<p><strong>模块</strong>就是一个Python文件，只有导入import了模块你才能使用模块里的函数。当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。<br>from  modname  import   funcname1,funcname2….导入某模块中的具体某个函数。</p>
<p>　　模块搜索路径存存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH（就是Python中lib的路劲）和由安装过程决定的默认目录。一个Python表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。</p>
<hr>
<p><strong>命名空间</strong></p>
<p>　　每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。Python会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给全局变量在一个函数里赋值，必须使用global语句。</p>
<p>　　global VarName的表达式会告诉Python， VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量了。</p>
<pre><code>a=<span class="number">0</span>;
<span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span>
 <span class="keyword">global</span> a     <span class="comment">#若将其注释掉将出现错误 UnboundLocalError: local variable 'a' referenced before assignment</span>
 a +=<span class="number">1</span>
<span class="keyword">print</span> a
</code></pre><p><strong>包</strong></p>
<p>　　包是一个分层次的目录结构，例如你要在A文件夹下有三个a1.py，a2.py，a3.py。这时可在A下创建<strong>init</strong>.py文件，然后再里面使用显示的导入语句，</p>
<p>　　import a1 from a1; import a2 from a2; import a3 from a3;  这样就导入A包的时候这些类就全都是可用的了，import A;  A.a1();这就是包的使用方法。</p>
<p><strong>文件I/O</strong></p>
<p>　　raw_input(提示) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）</p>
<p>　　input(提示) 函数和raw_input(提示) 函数基本可以互换，但是input会假设你的输入是一个有效的Python表达式，并返回运算结果。</p>
<p>　　open(filename,mode,buffering):打开一个文件</p>
<p>　　Write()方法可将任何字符串写入一个打开的文件，不在字符串的结尾不添加换行符(‘\n’)。</p>
<p>　　read（）方法从一个打开的文件中读取一个字符串。</p>
<p>　　Tell()方法告诉你文件内的当前位置；换句话说，下一次的读写会发生在文件开头这么多字节之后：</p>
<p>　　seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p>
<p><strong>面向对象</strong></p>
<p>　　在python中实现数据隐藏很简单，不需要在前面加什么关键字，只要把类变量名或成员函数前面加两个下划线即可实现数据隐藏的功能，这样，对于类的实例来说，其变量名和成员函数是不能使用的，对于其类的继承类来说，也是隐藏的，这样，其继承类可以定义其一模一样的变量名或成员函数名，而不会引起命名冲突。Python不允许实例化的类访问隐藏数据，但你可以使用object._className__attrName访问属性。</p>
<p>参考的都是网上资料</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个python记录的有点乱，都是在看电子档资料的时候，记录下来的。</p>
<p>1、学习Python与其他语言最大的区别就是，Python的代码块不使用大括号（{}）来控制类，函数以及其他逻辑判断。python最具特色的就是用缩进来写模块。</p>
<p>缩进的空白数量]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[公交wifi运营平台分析]]></title>
    <link href="http://silencewt.github.io/2015/01/17/%E5%85%AC%E4%BA%A4wifi%E8%BF%90%E8%90%A5%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90/"/>
    <id>http://silencewt.github.io/2015/01/17/公交wifi运营平台分析/</id>
    <published>2015-01-17T11:55:16.000Z</published>
    <updated>2015-01-17T11:55:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、前言背景">一、前言背景</h3>
<p>　　昨晚下午，老板让看一些车载公交wifi后台管理的一些东西，这个随着移动端设备而兴起的wifi战，慢慢的也会越演越烈。</p>
<p>　　现在于很多人在外面的时候，进入一家店首先看的不是菜单，而是问一句“你们的wifi密码是多少”？没有贴着“免费wifi”标签的店，估计都不会有人进去用餐，咖啡店，甜品店，餐厅，美发店……到处都可以看到免费wifi的字样，wifi已经成为标配了。随着移动端的兴起，微信营销的推广，对WiFi的需求也越来越多，这个可以说是生有体会，武汉某商圈的兴起就和wifi，微信脱不了关系。聚餐、活动总是可以看到大半以上的成员拿着手机再看。正是，对WiFi的需求的增加，让wifi营销成为关注点，除了固定地点，餐厅、美发店等，移动wifi也成为了热点，地铁wifi，公交wifi，渐渐地进入人们的生活。</p>
<p>　　2014年中国智能手机用户规模已达到5亿人，到2017年全球手机用户量预计增长至45.5亿。智能终端的全面普及和移动互联网的发展带来wifi接入需求迅速膨胀的同时，也带来基于移动通信与wifi应用创新的巨大市场机遇。现在智慧城市建设如火如荼，其中就有公交wifi热，公交wifi建设造价不低，而且后期流量使用巨大，产生的费用也是不少的，所以也不能全靠政府买单，自然就有了运营盈利这块。直接向用户收费一般都是不可取的，只能间接的，例如广告，通过广告商的投入来盈利。公交WiFi是指在公交车上实现WiFi。公交WiFi是政府部门及相关单位为了方便乘客出行、提高乘车体验，通过在公交车上安装无线网络设备，乘客只需通过移动终端即可实现无线互联的一种WiFi利用方式。</p>
<p>　　中国科学院发布的《中国新型城市化报告2012》中提到，在选取的中国百万人口以上的50个主要城市中，居民平均单行上班时间要花39分钟。而大部分上班族选用的上班交通工具均为公交车，而且途中都在使用手机、平板等上网浏览新闻、刷微博、上微信、听音乐、看视频等。</p>
<p>　　公共交通系统是市民出行的主要交通工具，为了提供给乘客更智能、更舒适、更便捷的乘车环境和相关设施，将无聊的上班时间变得有趣而且有用，结合目前已经日益成熟的无线信息系统，在载客运输的基本职能上给乘客带来更多有价值的增值服务。从受众的视听感受来看，音视频往往会更加形象、便于记忆，达到更及时准确的传播。未来，公交WiFi将作为智慧城市发展的一部分进入我们的生活，势必从一线省会城市向二三线城市普及和推广。</p>
<p>　　来自某调研公司的数据表明，国内公交WiFi供应商产品中，涉及到“广告推送”的大部分是由设备内部存储的内容来实现，其存储的内容若要更新，必须修改代码，无法实现直接覆盖，这样导致了设备内部的存储内容更新困难，且由于公交WiFi是通过一车一设备的方式实现的，因此采用这样的方式就要求终端客户需对每一台设备进行单独更新，如想要二次开发，依托终端用户的力量不足，而求助于供应商则需要消耗极大的人力物力。不仅如此，设备内的广告内容不能由后台统一推送，无法实现广告主动推送功能，则广告功效自然无从谈起。于是出现了一些新的，满足要求的wifi设备，其中属厦门才茂公司的车载公交wifi路由器最为成熟。</p>
<h3 id="二、wifi推送系统">二、wifi推送系统</h3>
<p>　　目前一些商家为了是用户能够快速的连上自家wifi，从一开始的密码设置到现在的直接连通，很多商家并没有多想到通过wifi来营销。商家还是有别于公交wifi，公交的盈利大部分来自于广告，那么如果公交上拥有了wifi，那么自然会考虑到如何从中获取盈利。目前存在以下几个方式：</p>
<p>　　第一，wifi广告认证就是用户使用商家提供的免费wifi网络时，会在上网登录页面看到商家的广告信息，看10-30秒广告即可上网。</p>
<p>　　第二，wifi微信认证的原理是用户接入无线网络，微信就可以上网了，用户根据商家认证页面提示启动微信，扫描商家的官方微信二维码关注商家微信，即可获得上网权限，商家通过免费的wifi服务获得了微信粉丝，为以后的营销做好了准备。</p>
<p>　　第三，wifi短信认证是通手机接收短信验证码获取上网权限，认证系统会留下用户的手机号码，为商家二次营销做好准备。</p>
<p>　   第四，wifi微博认证的形式和微信认证的形式相似，成为商家微博粉丝即可获得上网权限。</p>
<p>　　第五，wifi App下载就是让接入无线网络的用户下载App来获取上网权限。wifi营销更突出了商家与用户之间的互动，将商家的活动信息精确无误的传递给用户，让用户在享受免费wifi服务的同时，能够更清晰的了解商家信息，引起用户兴趣和关注度，进而选择二次消费。</p>
<h3 id="三、wifi系统组成">三、wifi系统组成</h3>
<h4 id="（一）网络架构">（一）网络架构</h4>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/wifi.jpg" alt="ｗｉｆｉ"></p>
<h4 id="（二）系统功能">（二）系统功能</h4>
<p>　　后台网管：后台网管是一个远程的WIFI设备集中管理系统，可实现设备的远程查询、远程配置、远程升级等功能，WIFI设备的运行并不依赖于网管，“后台网管”功能的加入将使WIFI设备的集中管理变得更加灵活，更加智能；</p>
<p>　　广告推送系统：广告推送子系统可用于发布公共信息，推送商业广告，广告页面可根据不同需求进行定制修改，广告推送方式多样灵活；</p>
<p>　　用户接入认证系统：用户接入认证子系统是一个用户注册、用户认证及用户计费/计时系统，该系统对用户接入Internet访问进行控制，用户只需打开web浏览器即可进行认证，提供多种接入认证方式，包括注册帐号、短信验证码方式，以及手机号黑白名单等方式，“接入认证系统”使运营者对用户接入Internet的控制变得可能；</p>
<p> 　   用户上网行为管理系统：上网行为管理系统可对用户访问Internet的内容进行管理/限制，同时也可记录用户访问的Internet内容，“上网行为管理”功能在流量控制及内容限制方面尤为突出。</p>
<p>　　各子系统的功能完整独立，可根据不同运营要求自由组合，如果只监控WIFI设备的运行状况，搭配“后台网管”即可；需要以广告推送方式来发布公共信息，可搭配“广告推送系统“；如果考虑用户接入的统计和控制，则要加上“接入认证系统”；对用户上网行为有要求的情况下，可加入“上网行为管理系统”；</p>
<p>　　商家购买该wifi路由之后，可以选择性的接入上述系统，拥有该系统的登入账号，并对其进行管理。可以选择B/S，或者C/S系统。对于公交车而言，可以根据移动设备联网的手机号情况，熟悉有哪些用户是经常乘坐哪一路的公交，可以针对的性的对其进行相应的广告推送。</p>
<p>　　这个系统比较重要的就是每个登入用户数据的收集，以及对数据的分析，进而有目的性的推送消息，以及流量的导入。</p>
<p>　　以下功能应该属于后台网管部分。主要是商家对路由器的控制和设置。</p>
<p>　　1、支持多种认证方式：</p>
<p>　　　　短信验证、WEB认证、微信认证、QQ认证、微博认证等方式</p>
<p>　　2、流量控制</p>
<p>　　带宽管理</p>
<p>　　流量控制策略，是通过为用户和应用指定“带宽通道对象”，让指定的用户和应用走指定的通道，实现对用户和应用的带宽上下限管理，例如限制迅雷、FTP的　　下载带宽等。</p>
<p>　　3、每用户控制</p>
<p>　　每用户控制，就是对每个用户进行控制，策略中无论是时长限额、流量限额还是带宽限制、连接数限制，针对的都是个体用户，而并非用户组，比如时长限　　　　制QQ使用1小时，表示用户组内每个用户使用QQ不能超过1小时，带宽控制中限制上传带宽为100kbps，指的是用户组内每个用户上传带宽最大值为100kbps……，　　通过每用户控制，可以使网络资源得到更加合理的应用。</p>
<p>　　每用户控制主要包含4个部分：</p>
<blockquote>
<p>带宽控制：限制每用户的上传、下载带宽；<br>连接控制：限制每用户的并发连接数及每秒新建连接数；<br>时长限额：限制每用户使用网络应用的最大时长，超时长被阻塞；<br>流量限额：限制每用户使用网络应用的最大流量，超流量被阻塞；</p>
</blockquote>
<p>　　为保证每位乘客都可以较好的体验上网，对每个用户的流量是必须进行控制的，不然会出现某个用户使用了某个霸道的app，直接占用所有的带宽流量，那么就会影响到其他用户的无法联网。</p>
<p>　　4、带宽控制</p>
<p>　　通过带宽控制策略实现对目标组织结构中每个用户限制其上传和下载带宽，实现流量管控</p>
<p>　　5、用户管理</p>
<p>　　　　支持用户导入</p>
<p>　　　　IP导入</p>
<p>　　　　第三方数据导入</p>
<p>　　　　自定义</p>
<p>　　6、流量阈值</p>
<p>　　流量阈值功能即指当网口总流量超阈值时触发，除了可以通过声音或者邮件进行外，还可以通过弹屏方式显示具体的超阈值流量信息。</p>
<p>　　7、日志管理</p>
<p>　　日志记录了系统主要的操作和事件，以及系统的各项信息，辅助技术支持人员进行系统维护和故障诊断。日志管理中提供多种日志查询。</p>
<p>　　日志可以显示每个路由器的运行情况，不便于日常的维护和维修，及时的对无法联网的路由器进行维护。</p>
<p>　　以下功能是对应广告商的管理：</p>
<p>　　1、及时跟新广告内容，针对性的对每条线路公交推送相应的广告内容。</p>
<p>　　2、对用户实行流量的导入，获得用户的点击量和浏览量。记录用户的上网行为并对其进行管理，用户上线下线的管理，使用wifi时长的记录和次数，以图表的形式清　　晰的展现出来，便于进行分析。如哪种形式的广告更能够吸引用户点击，哪种标语的出现可以增加用户的浏览时间？某条公交线路上的用户对哪一商圈的信息比较关　　注？某条线路上的用户对哪一个方面会比较感兴趣，一般在什么时间段会关注使用公交上的wifi？……等等，通过对这些数据的收集和分析，有便于公交寻找相对应的　　广告投放，增加盈利。</p>
<p>　　3、后台可以根据不同，对广告页面推送进行多元化管理，对广告商的综合管理，每个广告的方式、时长，出现的次数，图片和信息的更新等等。</p>
<p>　　这个部分重点就在于对广告的管理和用户信息的采集。</p>
<h3 id="四、公交wifi难点">四、公交wifi难点</h3>
<h4 id="（一）网速">（一）网速</h4>
<p>　　公交wifi是移动场景下的，使用的是运营商无线信号，和固定场景下使用的有线宽带wifi是不同的。无线信号的资源是有限的，而有线宽带的资源却是接近无限的。所以，前者的上网体验肯定比不上后者。对于用户来说，用公交wifi上网同用手机流量上网来比，信号会更好。随着运营商的努力，随着4G时代的到来，无线信号越来越好了。那么用户在公交车上的体验也会越来越好。其实技术是成熟的，主要看基础设施的发展。</p>
<h4 id="（二）wifi盈利模式探索">（二）wifi盈利模式探索</h4>
<p>　　wifi战就是数据战服务商探索盈利模式。目前，刚起步的公交wifi也处在烧钱阶段。公交免费wifi前期投入还是蛮大的，公交免费wifi的成本中，硬件成本主要是车载路由器，然后是日常维护和向运营商购买流量的成本。支持3G网络的车载路由价格在2000元左右，而支持4G网络的路由在3000元左右。再加上人工等成本，笼统地计算，一辆公交车硬件成本为4000多元。这里并每月有加上向运营商购买的流量费。</p>
<p>目前现有的盈利模式：</p>
<p>　　第一种是卖广告，这也是比较成熟的盈利模式之一。这种模式虽然是盈利最直接的一种模式，但无疑也最影响用户体验的。公交wifi模式下，所提供的所有视频、音乐、读书等内容不能够实时，用户自由选择性也不强，只能通过广告弹窗的方式让用户获得信息。</p>
<p>　　第二种应用分发，把流量变现，比如在wifi开放平台上承载各种应用，然后把流量导到微信公众号、支付宝钱包等，在用户登录wifi的时候推荐能用于下次自动登录的应用程序，这个App能作为应用市场，给用户分发有刚性需求的应用和游戏。</p>
<p>　　第三种以网换网，用移动互联网模式来思考，采用‘以网换网’O2O模式，通过社交游戏实现变现，比如，在公交车上，乘客可以在享受热门游戏或者使用一些热门移动应用上网服务的同时，换取免费使用公交WiFi的流量。</p>
<h3 id="五、总结">五、总结</h3>
<p>　　公交wifi，说到底就是一种数据之战，但却建立在良好的网络基础上，配合硬件和网络的使用，根据获得的数据针对性的推送消息，这个如果能很好的实现，所获得的价值是很可观的。公交是一个庞大的交通链，城市的主动脉，若能解决上述问题，使公交wifi得以很好的利用，将又是移动互联网的一次应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、前言背景">一、前言背景</h3>
<p>　　昨晚下午，老板让看一些车载公交wifi后台管理的一些东西，这个随着移动端设备而兴起的wifi战，慢慢的也会越演越烈。</p>
<p>　　现在于很多人在外面的时候，进入一家店首先看的不是菜单，而是问一句“你们的wif]]>
    </summary>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[testNG小试牛刀]]></title>
    <link href="http://silencewt.github.io/2015/01/12/testNG%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://silencewt.github.io/2015/01/12/testNG小试牛刀/</id>
    <published>2015-01-12T13:28:22.000Z</published>
    <updated>2015-01-12T13:37:18.000Z</updated>
    <content type="html"><![CDATA[<p>　　testNG是一个测试框架，其灵感来自JUnit和NUnit的，但引入了一些新的功能，使其功能更强大，使用更方便。</p>
<p>　　testNG是一个开源自动化测试框架；testNG表示下一代。 testNG是类似于JUnit（特别是JUnit 4），但它不是一个JUnit扩展。它的灵感来源于JUnit。它的目的是优于JUnit的，尤其是当测试集成的类。 testNG的创造者是Cedric Beust（塞德里克·博伊斯特）</p>
<p>　　testNG消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。 因为它在很大程度上借鉴了Java注解annotation（JDK5.0引入的）来定义的测试，它也可以告诉你如何使用这个新功能在真实的Java语言生产环境中。</p>
<h3 id="testNG的特点：">testNG的特点：</h3>
<ul>
<li>注解</li>
<li>testNG使用Java和面向对象的功能</li>
<li>支持综合类测试（例如，默认情况下，没有必要创建一个新的测试每个测试方法的类的实例）</li>
<li>独立的编译时间测试代码运行时配置/数据信息</li>
<li>灵活的运行时配置</li>
<li>主要介绍“测试组”。当编译测试，只要问testNG运行所有的“前端”的测试，或“快”，“慢”，“数据库”等</li>
<li>支持依赖测试方法，并行测试，负载测试，局部故障</li>
<li>灵活的插件API</li>
<li>支持多线程测试</li>
</ul>
<hr>
<p>　　testNG.xml文件记录了一些非常简单的术语。xml是一个以XML记录所有测试的文件口这个文件能够很容易地在一个文件中描述所有测试套件和它们的参数，可以将它签人到代码库中，或通过电子邮件发送给其他组员。也可以很容易地提取测试的子集，或分成几种运行时配置。这个文件并不是运行testNG所必须的。</p>
<p>　　</p>
<blockquote>
<p>一个suite(套件)由一个或多个测试组成。</p>
<p>一个test(测试)由一个或多个类组成。</p>
<p>一个class(类)由一个或多个方法组成。</p>
</blockquote>
<hr>
<p><strong>testNG相对于junit的一些优点</strong>：</p>
<p>　　1. testNG是一个设计用来简化广泛的测试需求的测试框架，从单元测试到集成测试这个是testNG设计的出发点，不仅仅是单元测试，而且可以用于集成测试。设计目标的不同，对比junit的只适合用于单元测试，testNG无疑走的更远。可以用于集成测试，这个特性是我选择testNG的最重要的原因。</p>
<p>　　2. 测试的过程的三个典型步骤，注意和junit(4.0)相比，多了一个将测试信息添加到testng.xml文件或者build.xml测试信息尤其是测试数据不再写死在测试代码中，好处就是修改测试数据时不需要修改代码/编译了，从而有助于将测试人员引入单元测试/集成测试。</p>
<p>　　3. 基本概念，相比junit的TestCase/TestSuite，TestNG有suite/test/test method三个级别，即将test/test method明确区分开了。</p>
<hr>
<h3 id="基本使用：">基本使用：</h3>
<p><strong>1、异常处理</strong></p>
<p>　　testNG可以简单方便的检测异常的发生，通过@ExpectedExceptions标注预期捕获的异常，当确实发生预期的异常，testNG认为测试通过。也可以指定标注多个异常。</p>
<p><strong>2、失败处理</strong><br>　　当testNG运行的case有失败的时候，会在test-output目录下生成一个testng-failed.xml文件，这对于批量执行测试定位问题很有帮助，testng可以单独执行这些失败的测试。</p>
<p><strong>3、使用参数</strong></p>
<p>　　testNG传参数的两种方式（xml文件，@DataProvider）</p>
<p><strong>使用testng.xml设置参数</strong></p>
<p> 　　参数在xml文件中可以在suite级别定义，也可以在test级别定义；testNG会尝试先在包含当前类的test标签中寻找参数，如果没找到则在上层的suite标签中查找。即在test标签中相同的参数对当前类当前方法的优先级比较高。 testNG支持这种传参方式的类型如下：String、 int/Integer、boolean/Boolean、 byte/Byte、 char/Character、 double/Double、 float/Float、 long/Long、 short/Short。对于非上述类型TestNG无法通过这种方式进行传参，可以通过@DataProvider方式传参</p>
<p> <strong>DataProvider方式传参</strong></p>
<p>　　只提供了一个字符串属性：名称，供测试方法作为传递参数的annotation使用两种DataProvider，一种是返回一个二维数组对象，如上面的例子；另外一种DataProvider是返回一个Iterator，DataProvider可以向测试方法传递任意类型任意数目的参数，利用DataProvider提供不同的参数集合对一个测试方法进行多次调用。</p>
<p><strong>4、Annotation</strong></p>
<p>　　快速预览，这些可以在官方的文档上找到更详细的资料。</p>
<p>　</p>
<blockquote>
<p>@BeforeSuite:        被注释的方法将在所有测试运行前运行 　　<br>@AfterSuite:    　被注释的方法将在所有测试运行后运行<br>@BeforeTest: 　被注释的方法将在测试运行前运行 　　<br>@AfterTest: 　被注释的方法将在测试运行后运行 　　<br>@BeforeGroups:       被配置的方法将在列表中的gourp前运行。这个方法保证在第一个属于这些组的测试方法调用前立即执行。<br>@AfterGroups:     被配置的方法将在列表中的gourp后运行。这个方法保证在最后一个属于这些组的测试方法调用后立即执行。 　　<br>@BeforeClass:    被注释的方法将在当前类的第一个测试方法调用前运行。 　　<br>@AfterClass:       被注释的方法将在当前类的所有测试方法调用后运行<br>@BeforeMethod:        被注释的方法将在每一个测试方法调用前运行。<br>@AfterMethod:        被注释的方法将在每一个测试方法调用后运行。</p>
</blockquote>
<p><strong>5、分组</strong></p>
<p>　　testNG的annotation有分组的功能，这些分组的名称和编号完全由我们自己来决定。@Test（groups={“fast”,”database”}）定义了分组之后可以在排除或者运行某个组。testNG容许执行复杂的测试方法分组。不仅可以申明方法属于组，而且可以指定分组包含其他分组。然后TestNG可以被调用，并被要求包含某些分组和排除其他的分组。这将提供怎样划分测试的最大弹性，并且如果想运行两个不同的测试装置不需要重新编译。</p>
<p><strong>6、依赖</strong></p>
<p>　　有些时候，需要测试方法按照一个特定的顺序被调用。这非常有用，比如：
　　</p>
<ul>
<li><p>在运行更多测试方法前确认特定数量的测试方法调用完成并且成功</p>
</li>
<li><p>初始化测试并希望这个初始化方法也作为测试方法（被标记为@Before/After的方法将不作为最终报告的一部分）</p>
</li>
</ul>
<p>为了做到这点，需要使用@Test注解的dependsOnMethods属性或者dependsOnGroups属性。</p>
<p>这里有两种依赖：</p>
<ul>
<li>强依赖。在运行你的测试方法前所有依赖方法必须运行并且成功。哪怕有一个依赖方法失败，测试方法都不会被调用，在报告中将被标记为SKIP。</li>
<li>软依赖。测试方法在依赖方法运行后总是会被运行，即使某些依赖方法失败。对于只想确认测试方法是按照特定顺序运行，而测试方法并不真正依赖其他方法是否成功的情况下非常有用。软依赖通过在@Test注解中增加”alwaysRun=true”来实现。</li>
</ul>
<hr>
<p>　　除了上面基本的使用之外还有，testNG在并发测试、异步测试和多线程测试方面的应用等等。</p>
<p>关于testng的使用可以参考官方文档：<a href="http://testng.org/doc/documentation-main.html" target="_blank" rel="external">http://testng.org/doc/documentation-main.html</a></p>
<p>这是看了《java测试新技术—testng》这本书的一点记录，虽没有全部理解，但是对于很多部分还是了解理解了。知道有这么个东西。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　testNG是一个测试框架，其灵感来自JUnit和NUnit的，但引入了一些新的功能，使其功能更强大，使用更方便。</p>
<p>　　testNG是一个开源自动化测试框架；testNG表示下一代。 testNG是类似于JUnit（特别是JUnit 4），但它不是一个JU]]>
    </summary>
    
      <category term="testNG" scheme="http://silencewt.github.io/tags/testNG/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(三)--web模块]]></title>
    <link href="http://silencewt.github.io/2015/01/12/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%B8%89-web%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/12/maven小项目注册服务-三-web模块/</id>
    <published>2015-01-12T02:29:10.000Z</published>
    <updated>2015-01-12T03:26:01.000Z</updated>
    <content type="html"><![CDATA[<p>　　java的web应用打包方式一般为war它和jar的区别就是包含了更多的资源和文件，如JSP文件，静态资源文件，servlet等等。war包的核心就WEB-INF文件夹下必须有一个web.xml 的配置文件，子目录classes包含所有该项目的类，子目录lib包含所有的依赖，这两个目录都会在运行的时候添加到classpath下。</p>
<p>　　maven对于web项目有统一的格式。项目代码和资源还是放在src/main/java和src/main/resources下，web资源目录在src/main/webapp/。webapp下就包含WEB-INF，css, js, jsp,等等文件夹。</p>
<p>　　这里account-service模块是综合之前三个模块，提供总的服务，直接看代码。</p>
<h3 id="service模块：">service模块：</h3>
<p> SignUpRequest对应表单的信息：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> SignUpRequest {
<span class="keyword">private</span> String id;

<span class="keyword">private</span> String email;

<span class="keyword">private</span> String name;

<span class="keyword">private</span> String password;

<span class="keyword">private</span> String confirmPassword;

<span class="keyword">private</span> String captchaKey;

<span class="keyword">private</span> String captchaValue;

<span class="keyword">private</span> String activateServiceUrl;

<span class="keyword">public</span> String <span class="title">getId</span>() {
    <span class="keyword">return</span> id;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span>(String id) {
    <span class="keyword">this</span>.id = id;
}

<span class="keyword">public</span> String <span class="title">getEmail</span>() {
    <span class="keyword">return</span> email;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span>(String email) {
    <span class="keyword">this</span>.email = email;
}

<span class="keyword">public</span> String <span class="title">getName</span>() {
    <span class="keyword">return</span> name;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
    <span class="keyword">this</span>.name = name;
}

<span class="keyword">public</span> String <span class="title">getPassword</span>() {
    <span class="keyword">return</span> password;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span>(String password) {
    <span class="keyword">this</span>.password = password;
}

<span class="keyword">public</span> String <span class="title">getConfirmPassword</span>() {
    <span class="keyword">return</span> confirmPassword;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfirmPassword</span>(String confirmPassword) {
    <span class="keyword">this</span>.confirmPassword = confirmPassword;
}

<span class="keyword">public</span> String <span class="title">getCaptchaKey</span>() {
    <span class="keyword">return</span> captchaKey;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaptchaKey</span>(String captchaKey) {
    <span class="keyword">this</span>.captchaKey = captchaKey;
}

<span class="keyword">public</span> String <span class="title">getCaptchaValue</span>() {
    <span class="keyword">return</span> captchaValue;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaptchaValue</span>(String captchaValue) {
    <span class="keyword">this</span>.captchaValue = captchaValue;
}

<span class="keyword">public</span> String <span class="title">getActivateServiceUrl</span>() {
    <span class="keyword">return</span> activateServiceUrl;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActivateServiceUrl</span>(String activateServiceUrl) {
    <span class="keyword">this</span>.activateServiceUrl = activateServiceUrl;
}
}
</code></pre><p>　　<br>接口实现：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>{
String generateCaptchaKey() <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">byte</span>[] generateCaptchaImage(String captchaKey)
    <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> signUp(SignUpRequest signUpRequest) <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> activate(String activationNumber) <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> login(String id, String password) <span class="keyword">throws</span> AccountServiceException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>{
<span class="keyword">private</span> AccountPersistService accountPersist;
<span class="keyword">private</span> AccountEmailService accountEmail;
<span class="keyword">private</span> AccountCaptchaService accountCaptcha;
<span class="keyword">private</span> Map&lt;String, String&gt; activationMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();

<span class="keyword">public</span> AccountPersistService <span class="title">getAccountPersist</span>() {
    <span class="keyword">return</span> accountPersist;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountPersist</span>(AccountPersistService accountPersist) {
    <span class="keyword">this</span>.accountPersist = accountPersist;
}
<span class="keyword">public</span> AccountEmailService <span class="title">getAccountEmail</span>() {
    <span class="keyword">return</span> accountEmail;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountEmail</span>(AccountEmailService accountEmail) {
    <span class="keyword">this</span>.accountEmail = accountEmail;
}
<span class="keyword">public</span> AccountCaptchaService <span class="title">getAccountCaptcha</span>() {
    <span class="keyword">return</span> accountCaptcha;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountCaptcha</span>(AccountCaptchaService accountCaptcha) {
    <span class="keyword">this</span>.accountCaptcha = accountCaptcha;
}
<span class="keyword">public</span> String <span class="title">generateCaptchaKey</span>() <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> accountCaptcha.generateCaptchaKey();
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to generate captcha key"</span>,e);
    }

}
<span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">generateCaptchaImage</span>(String captchaKey)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> accountCaptcha.generateCaptchaImage(captchaKey);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to generate captcha image"</span>,e);
    }

}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signUp</span>(SignUpRequest signUpRequest)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> 
    {
        <span class="keyword">if</span> (!signUpRequest.getPassword().equals(signUpRequest.getConfirmPassword())) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"password donnot match"</span>);
        }

        <span class="keyword">if</span> (!accountCaptcha.validateCaptcha(signUpRequest.getCaptchaKey(), 
                signUpRequest.getCaptchaValue())) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captcha not match"</span>);
        }
        Account account = <span class="keyword">new</span> Account();
        account.setId(signUpRequest.getId());
        account.setEmail(signUpRequest.getEmail());
        account.setName(signUpRequest.getName());
        account.setPassword(signUpRequest.getPassword());
        account.setActivated(<span class="keyword">false</span>);

        accountPersist.createAccount(account);

        String activationId = RandomGenerator.getRandomString();
        activationMap.put(activationId, account.getId());
        String link = signUpRequest.getActivateServiceUrl().endsWith(<span class="string">"/"</span>) ? 
                signUpRequest.getActivateServiceUrl()+activationId : signUpRequest.getActivateServiceUrl()+
                <span class="string">"?key="</span>+activationId;
        accountEmail.sendMail(account.getEmail(), <span class="string">"please activate Your email"</span>, link);

    } <span class="keyword">catch</span> (AccountCaptchaException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to validate captcha"</span>, e);
    } <span class="keyword">catch</span> (AccountEmailException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to send email"</span>, e);
    } <span class="keyword">catch</span> (AccountPersistException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to create account"</span>, e);
    }
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span>(String activationId)
        <span class="keyword">throws</span> AccountServiceException {
    String accountId = activationMap.get(activationId);

    <span class="keyword">if</span> (accountId == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"invalid account activated id"</span>);
    }
    <span class="keyword">try</span> {
        Account account = accountPersist.readAccount(accountId);
        account.setActivated(<span class="keyword">true</span>);
        accountPersist.updateAccount(account);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to activate"</span>);
    }

}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span>(String id, String password)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        Account account = accountPersist.readAccount(id);
        <span class="keyword">if</span> (account == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"account donnot exits"</span>);
        }
        <span class="keyword">if</span> (!account.isActivated()) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"account not activate"</span>);
        }
        <span class="keyword">if</span> (!account.getPassword().equals(password)) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"password is error"</span>);
        }
    } <span class="keyword">catch</span> (AccountPersistException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to logging"</span>, e);
    }
}
}
</code></pre><p>　　注意service的配置文件中pom必须将email、captcha、persist这三个模块包含进去，依赖关系：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-email<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-captcha<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.icegreen<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>greenmail<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${greenmail.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><hr>
<h3 id="account-web模块：">account-web模块：</h3>
<p>pom需要依赖servlet，service模块，其他的配置和一般的maven项目一样。</p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-service<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>

<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><p>  <br>web.xml：定义了一些servlet，具体的servlet实现代码在src/main/java 下。</p>
<pre><code><span class="tag">&lt;<span class="title">web-app</span>&gt;</span>
<span class="tag">&lt;<span class="title">display-name</span>&gt;</span>Sample Maven Project: Account Service<span class="tag">&lt;/<span class="title">display-name</span>&gt;</span>
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
<span class="tag">&lt;<span class="title">context-param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>
        classpath:/account-persist.xml
        classpath:/account-captcha.xml
        classpath:/account-email.xml
        classpath:/account-service.xml
    <span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">context-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>SignUpServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.SignUpServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ActivateServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.ActivateServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.LoginServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/captcha_image<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>SignUpServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/signup<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ActivateServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/activate<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
</code></pre><p><br>　　这个给出其中一个servlet的代码：对用户login的处理。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span>
<span class="keyword">extends</span> <span class="title">HttpServlet</span>
</span>{
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">929160785365121624</span>L;

<span class="keyword">private</span> ApplicationContext context;

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>()
    <span class="keyword">throws</span> ServletException
{
    <span class="keyword">super</span>.init();
    context = WebApplicationContextUtils.getWebApplicationContext( getServletContext() );
}

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span>( HttpServletRequest req, HttpServletResponse resp )
    <span class="keyword">throws</span> ServletException,
        IOException
{
    String id = req.getParameter( <span class="string">"id"</span> );
    String password = req.getParameter( <span class="string">"password"</span> );

    <span class="keyword">if</span> ( id == <span class="keyword">null</span> || id.length() == <span class="number">0</span> || password == <span class="keyword">null</span> || password.length() == <span class="number">0</span> )
    {
        resp.sendError( <span class="number">400</span>, <span class="string">"incomplete parameter"</span> );
        <span class="keyword">return</span>;
    }

    AccountService service = (AccountService) context.getBean( <span class="string">"accountService"</span> );

    <span class="keyword">try</span>
    {
        service.login( id, password );
        resp.getWriter().print( <span class="string">"Login Successful!"</span> );
    }
    <span class="keyword">catch</span> ( AccountServiceException e )
    {
        resp.sendError( <span class="number">400</span>, e.getMessage() );
    }
}
}
</code></pre><p>　　关于jsp界面只有两个：login.jsp和signup.jsp这个对于接触过web 的而言很简单了。</p>
<p>　　基本上这些内容大概就可以说明maven的好处和使用方法了，经过书上的讲解和自己的实际操练，对maven的使用会更加熟悉，当然自己用到的只是maven的皮毛，它的功能可 不仅仅只有这些，这些只是它的核心功能。如果能在实际项目中运用，并去学习的话会对maven有更深的了解，鉴于时间关系，我只能先了解个大概，之后若需要的时候能够快速的使用起来，也希望能在实验室项目中好好的使用这个工具。（有机会和时间的话，尝试重构实验室之前的web项目代码）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　java的web应用打包方式一般为war它和jar的区别就是包含了更多的资源和文件，如JSP文件，静态资源文件，servlet等等。war包的核心就WEB-INF文件夹下必须有一个web.xml 的配置文件，子目录classes包含所有该项目的类，子目录lib包含所有的]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用maven进行测试]]></title>
    <link href="http://silencewt.github.io/2015/01/12/%E7%94%A8maven%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/"/>
    <id>http://silencewt.github.io/2015/01/12/用maven进行测试/</id>
    <published>2015-01-12T02:26:31.000Z</published>
    <updated>2015-01-12T02:28:14.000Z</updated>
    <content type="html"><![CDATA[<p>　　maven的重要职责之一就是自动运行单元测试，它通过maven-surefire-plugin与主流的单元测试框架junit和testng集成，并且能够自动生成丰富的结果报表。</p>
<p>　　maven并不是一个单元测试框架，他只是在构建执行打特定的生命周期阶段的时候，通过插件来执行JUnit或testNG的测试用例，这个插件就是maven-surefire-plugin，也叫做测试运行器。maven-surefire-plugin会自动执行测试源码路劲下（src/test/java）的所有符合以下命名模式的测试用例
　　</p>
<blockquote>
<p>*<em>/Test</em>.java：任何子目录下的所有命名以Test开头的java类</p>
<p>　　*<em>/*</em>Test.java：任何子目录下的所有命名以Test结尾的java类</p>
<p>　　*<em>/*</em>TestCase.java：任何子目录下的所有命名以TestCase结尾的java类</p>
</blockquote>
<p>　　只要将测试类按上述模式命名，maven就能自动运行它们，用户也就不再需要定义测试集合（testsuite）来聚合测试用例了。</p>
<p>　　当然也可以自定义来包含一些不符合上述命名规则的测试类，以下定义以Tests结尾的用例：</p>
<pre><code><span class="variable">&lt;plugin&gt;</span>
  <span class="variable">&lt;groupId&gt;</span>org.apache.maven.plugin<span class="variable">&lt;/groupId&gt;</span>
  <span class="variable">&lt;artifactId&gt;</span>maven-surefire-plugin<span class="variable">&lt;/artifactId&gt;</span>
  <span class="variable">&lt;version&gt;</span>2.5<span class="variable">&lt;version&gt;</span>
  <span class="variable">&lt;configuration&gt;</span>
<span class="variable">&lt;includes&gt;</span>
   <span class="variable">&lt;include&gt;</span><span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>Tests.java<span class="variable">&lt;/include&gt;</span>
<span class="variable">&lt;/includes&gt;</span>
  <span class="variable">&lt;/configuration&gt;</span>
<span class="variable">&lt;/plugin&gt;</span>
</code></pre><p>　　日常工作中，软件开发人员总有很多理由来跳过单元测试，“我敢保证这次改动不会导致任何测试失败，测试运行太耗时了，暂时跳过一，有持续集成服务跑所有测试呢，我本地就不执行啦。在大部分情况下，这想法都是不对的。任何改动都要交给测试去验证，测试运行耗时过长应该考虑优化测试，更不要完全依赖持续集成服务来报告错误，测试错误应该尽早在尽小范围内发现，并及时修复。</p>
<p>　　maven同时也可以通过设置skipTest来跳过测试。</p>
<p><strong>测试报告</strong>：</p>
<p>　　surefire会在target-report下生成两种格式的错误与报告，简单文本格式和支持JUnit的XML格式。</p>
<p><strong>测试覆盖率报告</strong>：</p>
<p>　　cobertura是一个开源的测试覆盖率统计工具，使用时添加插件cobertura-maven-plugin</p>
<p><strong>testng</strong>：</p>
<p>　　可以使用testing.xml的文件，来配置想要运行的测试集合。然后再pom文件里在配置使用该文件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　maven的重要职责之一就是自动运行单元测试，它通过maven-surefire-plugin与主流的单元测试框架junit和testng集成，并且能够自动生成丰富的结果报表。</p>
<p>　　maven并不是一个单元测试框架，他只是在构建执行打特定的生命周期阶段的时]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(二)--captcha模块]]></title>
    <link href="http://silencewt.github.io/2015/01/12/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%BA%8C-captcha%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/12/maven小项目注册服务-二-captcha模块/</id>
    <published>2015-01-12T02:12:05.000Z</published>
    <updated>2015-01-12T02:15:58.000Z</updated>
    <content type="html"><![CDATA[<p>　　验证码生成模块，配置信息基本和前面的模块一样。account-captcha需要提供的服务是生成随机的验证码主键，然后用户可以使用这个主键要求服务生成一个验证码图片，这个图片对应的值应该是随机的，最后用户用肉眼读取图片的值，并将验证码的主键与这个值交给服务进行验证。这一服务对应的接口可以定义如下：</p>
<h3 id="具体代码：">具体代码：</h3>
<pre><code><span class="keyword">public</span> <span class="interface"><span class="keyword">interface</span> AccountCaptchaService </span>{
<span class="comment">//生成主见</span>
    <span class="built_in">String</span> generateCaptchaKey() throws AccountCaptchaException;
    byte[] generateCaptchaImage(<span class="built_in">String</span> captchaKey) throws AccountCaptchaException;
<span class="comment">//验证主键和值</span>
    <span class="built_in">boolean</span> validateCaptcha(<span class="built_in">String</span> captchaKey, <span class="built_in">String</span> captchaValue)throws AccountCaptchaException;
    List&lt;<span class="built_in">String</span>&gt; getPreDefinedTexts();
    <span class="built_in">void</span> setPreDefinedTexts(List&lt;<span class="built_in">String</span>&gt; preDefinedTexts);
}
</code></pre><p>　　额外定义的getPreDefinedText和set方法可以预定义验证码图片的值，提高程序的可预测性。</p>
<p> 　　为你了能够生成随机的验证码主键，定义一个类RandomGenerator如下：</p>
<pre><code>public class <span class="type">RandomGenerator</span> {

private <span class="keyword">static</span> <span class="type">String</span> rangeString = <span class="string">"0123456789qwertyuiopasdfghjklzxcvbnm"</span>;
public <span class="keyword">static</span> synchronized <span class="type">String</span> getRandomString(){
<span class="type">Random</span> random = new <span class="type">Random</span>();
<span class="type">StringBuffer</span> <span class="literal">result</span> = new <span class="type">StringBuffer</span>();
<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
    <span class="literal">result</span>.append(rangeString.charAt(random.nextInt(rangeString.length())));
}
<span class="keyword">return</span> <span class="literal">result</span>.toString();
}
}
</code></pre><p>　　该方法提供了一个线程安全且静态的方法，nextInt（）会放回一个大于等于0且小于n的整数。</p>
<h3 id="接口实现：">接口实现：</h3>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountCaptchaServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountCaptchaService</span>,<span class="title">InitializingBean</span> </span>{

    <span class="keyword">private</span> DefaultKaptcha producer;
    <span class="keyword">private</span> Map&lt;String,String&gt; captchaMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();
    <span class="keyword">private</span> List&lt;String&gt; preDefinedTexts;
    <span class="keyword">private</span> <span class="keyword">int</span> textCount = <span class="number">0</span>;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span>() <span class="keyword">throws</span> Exception {
        producer = <span class="keyword">new</span> DefaultKaptcha();
        producer.setConfig(<span class="keyword">new</span> Config(<span class="keyword">new</span> Properties()));
}

    <span class="keyword">public</span> String <span class="title">generateCaptchaKey</span>() <span class="keyword">throws</span> AccountCaptchaException {
        String key = RandomGenerator.getRandomString();
        String value = getCaptchaText();
        captchaMap.put(key, value);
        <span class="keyword">return</span> key;
    }

    <span class="keyword">private</span> String <span class="title">getCaptchaText</span>() {
        <span class="keyword">if</span>(preDefinedTexts != <span class="keyword">null</span> &amp;&amp; !preDefinedTexts.isEmpty()){
            String text = preDefinedTexts.get(textCount);
            textCount = (textCount+<span class="number">1</span>)%preDefinedTexts.size();
            <span class="keyword">return</span> text;
        }
        <span class="keyword">else</span> {
            <span class="keyword">return</span> producer.createText();
        }

    }

<span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">generateCaptchaImage</span>(String captchaKey)
        <span class="keyword">throws</span> AccountCaptchaException {
    String text = captchaMap.get(captchaKey);
    <span class="keyword">if</span> (text == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captaha key"</span>+captchaKey+<span class="string">"not found"</span>);
    }
    BufferedImage image = producer.createImage(text);
    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();
    <span class="keyword">try</span> {
        ImageIO.write(image,<span class="string">"jpg"</span> , out);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"failed to write image"</span>);
    }
    <span class="keyword">return</span> out.toByteArray();
}

<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateCaptcha</span>(String captchaKey, String captchaValue)
        <span class="keyword">throws</span> AccountCaptchaException {
    String text = captchaMap.get(captchaKey);
    <span class="keyword">if</span> (text == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captaha key"</span>+captchaKey+<span class="string">"not found"</span>);
    }
    <span class="keyword">if</span> (text.equals(captchaValue)) {
        captchaMap.remove(captchaKey);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }<span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

}

<span class="keyword">public</span> List&lt;String&gt; <span class="title">getPreDefinedTexts</span>() {

    <span class="keyword">return</span> preDefinedTexts;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPreDefinedTexts</span>(List&lt;String&gt; preDefinedTexts) {
    <span class="keyword">this</span>.preDefinedTexts = preDefinedTexts;

}

}
</code></pre><p>　　afterPropertiesSet会在framework初始化的时候调用，这个方法初始化验证码生成器，并提供默认配置。</p>
<p>   　generateCaptchaKey()首先生成一个随机的验证码主键，每个主键将和一个验证码字符串相关联，然后这组关联会被存储到中captchaMap以备将来验证。主键的目的仅仅是标识验证码图片，其本身没有实际的意义。getCaptchaText()用来生成验证码字符串，当preDefinedTexts存在或者为空的时候，就是用验证码图片生成器producer创建一个随机的字符串。当preDefinedTexts，不为空的时候，就顺序地循环该字符串列表读取值。preDefinedTexts有其对应的一组get和stet方法，这样就能让用户预定义验证码字符串的值。generateCaptchaImage方法就能通过producer来生成一个Bufferedlmage ,随后的代码将这个图片对象转换成jpg格式的字节数组并返回。有了该字节数组，用户就能随意地将其保存成文件，或者在网页上显示。</p>
<p>　　用户得到了验证码图片以及主键后。就会识别图片中所包含的字符串信息，然后将此验证码的值与主键一起反馈给 validateCaptcha方法以进行验证。</p>
<h3 id="测试代码：">测试代码：</h3>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountCaptchaServiceTest</span> </span>{
<span class="keyword">private</span> AccountCaptchaService service;
<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span>() <span class="keyword">throws</span> Exception{
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_captcha.xml"</span>);
    service = (AccountCaptchaService) ctx.getBean(<span class="string">"accountCaptchaService"</span>);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenerateCaptcha</span>() <span class="keyword">throws</span> Exception{
    String captchaKey = service.generateCaptchaKey();
    assertNotNull(captchaKey);

    <span class="keyword">byte</span>[] captchaImage = service.generateCaptchaImage(captchaKey);
    assertTrue(captchaImage.length&gt;<span class="number">0</span>);

    File image = <span class="keyword">new</span> File(<span class="string">"target"</span>+captchaKey +<span class="string">".jpg"</span>);
    OutputStream output = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        output = <span class="keyword">new</span> FileOutputStream(image);
        output.write(captchaImage);
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span> (output != <span class="keyword">null</span>) {
            output.close();
        }
    }
    assertTrue(image.exists() &amp;&amp; image.length()&gt;<span class="number">0</span>);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValidateCaptchaCorrect</span>() <span class="keyword">throws</span> Exception{
    List&lt;String&gt; preDefinedTexts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    preDefinedTexts.add(<span class="string">"12345"</span>);
    preDefinedTexts.add(<span class="string">"abcde"</span>);
    service.setPreDefinedTexts(preDefinedTexts);
    String captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertTrue(service.validateCaptcha(captchaKey, <span class="string">"12345"</span>));
    captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertTrue(service.validateCaptcha(captchaKey, <span class="string">"abcde"</span>));
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValidateCaptchaIncorrect</span>()
        <span class="keyword">throws</span> Exception
{
    List&lt;String&gt; preDefinedTexts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    preDefinedTexts.add(<span class="string">"12345"</span>);
    service.setPreDefinedTexts(preDefinedTexts);
    String captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertFalse(service.validateCaptcha(captchaKey, <span class="string">"67809"</span>));
}
}
</code></pre><p>　　</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomGeneratorTest</span> </span>{
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetRandomTest</span>() <span class="keyword">throws</span> Exception{
    Set&lt;String&gt; randoms = <span class="keyword">new</span> HashSet&lt;String&gt;(<span class="number">100</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
        String random = RandomGenerator.getRandomString();
        assertFalse(randoms.contains(random));
        randoms.add(random);
    }

}
}
</code></pre><p>　　这个测试代码比较容易看懂。运行测试后可以在项目的target目录下看到生成的验证码图片。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　验证码生成模块，配置信息基本和前面的模块一样。account-captcha需要提供的服务是生成随机的验证码主键，然后用户可以使用这个主键要求服务生成一个验证码图片，这个图片对应的值应该是随机的，最后用户用肉眼读取图片的值，并将验证码的主键与这个值交给服务进行验证。这一]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(一)--email和persist模块]]></title>
    <link href="http://silencewt.github.io/2015/01/11/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%B8%80-email%E5%92%8Cpersist%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/11/maven小项目注册服务-一-email和persist模块/</id>
    <published>2015-01-11T01:32:06.000Z</published>
    <updated>2015-01-11T01:38:29.000Z</updated>
    <content type="html"><![CDATA[<p>跟着书里的讲解，跟着做了一遍该项目：</p>
<p>首先明白注册账户的需求：</p>
<p>　　账号的lD和Email地址都可以用来唯一地标识某个用户，而显示名称则用来显示在页面下，方便浏览。注册的时候用户还需要输入两次密码，以确保没有输错，系统则需要负责检查ID和email的唯一性，验证两次输入的密码是否一致，验证码是由系统随机生成的只能由肉眼识别其内容的图片，若输入正确的验证码信息，系统则会进行检查，如果验证码错误。系统会生成并返回新的验证码。所有检查都没问题了，系统就会生成一个激活链接，并发送到用户的邮箱。单击激活链接后，账户就被激活了，这时账户注册完成，用户可以进行登录。对于一个账户注册服务，还需要考虑一些安全因素，例如，需要在服务器端密文地保存密码，检查密码的强弱程度，更进一步则需要考虑验证码的失效时间，激活链接的失效时间等等。</p>
<p><strong>需求用例</strong>：</p>
<p><strong>主要场景</strong>：</p>
<p>1、用户访问注册页面</p>
<p>2、系统随机生成验证码图片</p>
<p>3、用户输入ID、Email等注册信息</p>
<p>4、输入验证码</p>
<p>5、提交注册请求</p>
<p>6、系统检查验证码、检查ID的唯一性，检查邮箱是否已被注册、密码和确认密码是否一致</p>
<p>7、系统保存未激活的账户信息</p>
<p>8、系统生成激活连接，发送给用户邮箱</p>
<p>9、用户打开邮箱，访问激活链接</p>
<p>10、系统解析激活连接，激活相关用户</p>
<p>11、用户使用ID和密码登陆</p>
<p><strong>扩展场景：</strong></p>
<p>4a：用户无法看清验证码，请求重新生成    1、跳转到2</p>
<p>6a：系统检测到用户输入的验证码有误        1、提示验证码有错，2、跳转到2</p>
<p>6b：检测到 ID已被注册，邮箱，密码有误    1、提示错误信息，2、跳转到2</p>
<p>从上面可以看出该服务有几个接口：生成验证码图片、处理注册请求、激活账户以及处理登陆请求。</p>
<p><strong>接口结构：</strong></p>
<p>acountService类：<br>generateCaptchaKey()<br>generateCaptchaImage(captchakey:string)<br>signUp(signUpRequest:SignUpRequest)：接收对象，进行验证。如果验证正确。则创建一个末被激活的账户，同时在后台也需要发送一封带有激活链接的邮件。<br>activate(activationNumber:string)：方法接收一个激活码，查找时应的账户进行激活<br>login(id:string,password:string)<br>signUpRequest：包含用户的注册信息，表单信息：id、Email、displayName、password、comfirmpassword、captchaKey、captchaValue。<br>generateCaptchaKey()的简单解释就是验证码，每个captcha都需要有一个key ,根据这个key ,系统才能得到对应的验证码图片以及实际值。因此，generateCaptchaImage会生成一个captchakey使用这个key再调用generateCaptchaImage方法就能得到验证码图片。验证码的key以及验证码图片被传送到客户端，用户通过肉眼识别再输人验证码的值，伴随着key再传送到服务器端验证，服务器端就可以通过这个key查到正确的验证码值，井与客户端传过来的值进行比对验证。</p>
<p><strong>模块划分：</strong></p>
<p>com.hust.silence.accout.service：系统的核心，它封装了所有下层细节，对外暴露简单的接日，这实际上是一个Facade模式。<br>com.hust.silence.accout.web：该模块包含所有与web相关的内容，包括jsp等，直接依赖于service模块<br>com.hust.silence.accout.persist：处理账户信息的持久化，包括增、删、改、查等，根据实现，可以基于数据库或者文件<br>com.hust.silence.accout.captcha：处理验证码的key生成、图片生成以及验证等<br>com.hust.silence.accout.email： 处理邮件服务的配置，激活邮件的编写和发送等</p>
<p><strong>配置pom.xml</strong><br>加入需要的各种spring framework的模块，Greenmail是开源的邮件服务套件，Javax.mail为实现发送的一个类库。从上面的信息我们可以知道，该项目时是com.hust.silence的一个account项目，项目里有一个模块为account-email。</p>
<hr>
<h4 id="实现Email模块："><strong>实现Email模块</strong>：</h4>
<p>account-email只有一个很简单的接口。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountEmailService</span> </span>{
        <span class="keyword">void</span> sendMail(String to, String subject, String htmlText) <span class="keyword">throws</span> AccountEmailException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountEmailService</span></span>{
<span class="keyword">private</span> JavaMailSender javaMailSender;
<span class="keyword">private</span> String systemEmail;

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span>(String to, String subject, String htmlText)
        <span class="keyword">throws</span> AccountEmailException {
    <span class="comment">// TODO Auto-generated method stub</span>
    <span class="keyword">try</span> {
        MimeMessage msg = javaMailSender.createMimeMessage();
        MimeMessageHelper msgHelper = <span class="keyword">new</span> MimeMessageHelper(msg);
        msgHelper.setFrom(systemEmail);
        msgHelper.setTo(to);
        msgHelper.setSubject(subject);
        msgHelper.setText(htmlText);
        javaMailSender.send(msg);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="comment">// TODO: handle exception</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountEmailException(<span class="string">"fail to send mail"</span>,e);
    }
}
<span class="comment">//实现依赖注入</span>
<span class="keyword">public</span> JavaMailSender <span class="title">getJavaMailSender</span>(){
    <span class="keyword">return</span> javaMailSender;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJavaMailSender</span>(JavaMailSender javaMailSender){
    <span class="keyword">this</span>.javaMailSender = javaMailSender;
}
<span class="keyword">public</span> String <span class="title">getSystemEmail</span>(){
    <span class="keyword">return</span> systemEmail;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystememail</span>(String systemEmail){
    <span class="keyword">this</span>.systemEmail = systemEmail;
}
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>{
<span class="javadoc">/**
 *
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6514881539290222459</span>L;
<span class="keyword">public</span> <span class="title">AccountEmailException</span>(String message) {
    <span class="keyword">super</span>(message);
}
<span class="keyword">public</span> <span class="title">AccountEmailException</span>(String message, Throwable throwable){
    <span class="keyword">super</span>(message, throwable);
}
}
</code></pre><p><strong>配置文件</strong>：<br><strong>id=”propertyConfigurer”</strong>：这是springframework用来帮助载入properties文件的组件，代码中表示从classpath的根目录下载入名为account-email.properties文件中的属性。<br><strong>id=”javaMailSender”</strong>：定义邮件服务器的一些配置.包括协议、端口、主机，用户名、密码，是否需要认证等属性。这段配置还使用了propertyConfigurer的属性引用，比如host的值为$ { email.host }。之前定义的propertyConfigurer作用就在于此、可以将邮件服务器相关的配置分离到外部的properties文件中，比如可以定义这样一个properties文件。配置javaMailSender使用163：</p>
<p>account-email.properties（在src/test/resources文件夹里）：<br>email.protocol=smtp<br>email.host=smtp.163.com<br>email.port=25<br>email.username=test@163.com<br>email.password=password<br>email.auth=true<br>email.systemEmail=test@163.com</p>
<p><strong>测试</strong>：</p>
<p>只需要测试一个sendMail（）接口，这个就需要准备properties文件，配置并启用一个测试使用的邮件服务器，准备好后，就调用该接口实现邮件发送，然后检查是否发送成功，关闭测试邮件服务器。具体代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailServiceTest</span> </span>{
<span class="keyword">private</span> GreenMail greenMail;

<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMailServer</span>() <span class="keyword">throws</span> Exception{
    greenMail = <span class="keyword">new</span> GreenMail(ServerSetup.SMTP);
    greenMail.setUser(<span class="string">"1219611916@qq.com"</span>, <span class="string">"silence"</span>);
    greenMail.start();
}

<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMail</span>() <span class="keyword">throws</span> Exception{
    <span class="comment">//根据account。xml创建一个spring framework的ApplicationContext</span>
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_email.xml"</span>);
    <span class="comment">//从ctx中获取需要测试的ID为accountEmailService的bean并转换成AccountEmailService接口，</span>
    <span class="comment">//针对接口的测试是最好的单元测试的实现</span>
    AccountEmailService accout = (AccountEmailService)ctx.getBean(<span class="string">"accountEmailService"</span>);
    String subject = <span class="string">"Test Subject"</span>;
    String htmlText = <span class="string">"&lt;h3&gt;test&lt;/h3&gt;"</span>;
    accout.sendMail(<span class="string">"1219611916@qq.com"</span>, subject, htmlText);
    greenMail.waitForIncomingEmail(<span class="number">2000</span>, <span class="number">1</span>);
    Message[] mags = greenMail.getReceivedMessages();
    assertEquals(<span class="number">1</span>,mags.length);
    assertEquals(subject, mags[<span class="number">0</span>].getSubject());
    assertEquals(htmlText, GreenMailUtil.getBody(mags[<span class="number">0</span>]).trim());
}

<span class="annotation">@After</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMailServer</span>() <span class="keyword">throws</span> Exception{
    greenMail.stop();
}
}
</code></pre><hr>
<h4 id="实现persist模块：">实现persist模块：</h4>
<p>该模块负责账户数据的持久化，以XML文件的形式保存账户数据，井支持账户的创建、读取、更新、删除等操作。</p>
<p>配置代码：</p>
<pre><code>  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.hust.silence.account<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
 <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">name</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="title">url</span>&gt;</span>

  <span class="tag">&lt;<span class="title">properties</span>&gt;</span>
<span class="tag">&lt;<span class="title">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="title">project.build.sourceEncoding</span>&gt;</span>
<span class="tag">&lt;<span class="title">dom4j.version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">dom4j.version</span>&gt;</span>
<span class="tag">&lt;<span class="title">springframework.version</span>&gt;</span>2.5.6<span class="tag">&lt;/<span class="title">springframework.version</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">properties</span>&gt;</span>

  <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">test</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${dom4j.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>

  <span class="tag">&lt;<span class="title">build</span>&gt;</span>
<span class="tag">&lt;<span class="title">testResources</span>&gt;</span>
    <span class="tag">&lt;<span class="title">testResource</span>&gt;</span>
        <span class="tag">&lt;<span class="title">directory</span>&gt;</span>src/test/resources<span class="tag">&lt;/<span class="title">directory</span>&gt;</span>
        <span class="tag">&lt;<span class="title">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="title">filtering</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">testResource</span>&gt;</span>
<span class="tag">&lt;/<span class="title">testResources</span>&gt;</span>
<span class="tag">&lt;<span class="title">plugins</span>&gt;</span>
    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
            <span class="tag">&lt;<span class="title">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="title">encoding</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span>
<span class="tag">&lt;/<span class="title">plugins</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">build</span>&gt;</span>
<span class="tag">&lt;/<span class="title">project</span>&gt;</span> 　
</code></pre><p>dom4j是支持XML操作的，build元素包含testresource是开启资源过滤的，在单元测试中用到。</p>
<p>具体代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountPersistService</span> </span>{
Account createAccount(Account account) <span class="keyword">throws</span> AccountPersistException;
Account readAccount(String id) <span class="keyword">throws</span> AccountPersistException;
Account updateAccount(Account account) <span class="keyword">throws</span> AccountPersistException;
<span class="keyword">void</span> deleteAccount(String id) <span class="keyword">throws</span> AccountPersistException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountPersistServiceImpl</span>
<span class="keyword">implements</span> <span class="title">AccountPersistService</span>
</span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ROOT = <span class="string">"account-persist"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNTS = <span class="string">"accounts"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT = <span class="string">"account"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_ID = <span class="string">"id"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_NAME = <span class="string">"name"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_EMAIL = <span class="string">"email"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_PASSWORD = <span class="string">"password"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_ACTIVATED = <span class="string">"activated"</span>;

    <span class="keyword">private</span> String file;

    <span class="keyword">private</span> SAXReader reader = <span class="keyword">new</span> SAXReader();

    <span class="keyword">public</span> String <span class="title">getFile</span>()
    {
        <span class="keyword">return</span> file;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFile</span>( String file )
    {
        <span class="keyword">this</span>.file = file;
    }

    <span class="keyword">public</span> Account <span class="title">createAccount</span>( Account account )
        <span class="keyword">throws</span> AccountPersistException
    {
        Document doc = readDocument();

        Element accountsEle = doc.getRootElement().element(ELEMENT_ACCOUNTS);

        accountsEle.add( buildAccountElement( account ) );

        writeDocument( doc );

        <span class="keyword">return</span> account;
    }

<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span>( String id )
    <span class="keyword">throws</span> AccountPersistException
{
    Document doc = readDocument();

    Element accountsEle = doc.getRootElement().element( ELEMENT_ACCOUNTS );

    <span class="keyword">for</span> ( Element accountEle : (List&lt;Element&gt;) accountsEle.elements() )
    {
        <span class="keyword">if</span> ( accountEle.elementText( ELEMENT_ACCOUNT_ID ).equals( id ) )
        {
            accountEle.detach();

            writeDocument( doc );

            <span class="keyword">return</span>;
        }
    }
}

<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
<span class="keyword">public</span> Account <span class="title">readAccount</span>( String id )
    <span class="keyword">throws</span> AccountPersistException
{
    Document doc = readDocument();

    Element accountsEle = doc.getRootElement().element( ELEMENT_ACCOUNTS );

    <span class="keyword">for</span> ( Element accountEle : (List&lt;Element&gt;) accountsEle.elements() )
    {
        <span class="keyword">if</span> ( accountEle.elementText( ELEMENT_ACCOUNT_ID ).equals( id ) )
        {
            <span class="keyword">return</span> buildAccount( accountEle );
        }
    }

    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">public</span> Account <span class="title">updateAccount</span>( Account account )
    <span class="keyword">throws</span> AccountPersistException
{
    <span class="keyword">if</span> ( readAccount( account.getId() ) != <span class="keyword">null</span> )
    {
        deleteAccount( account.getId() );

        <span class="keyword">return</span> createAccount ( account );
    }

    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">private</span> Account <span class="title">buildAccount</span>( Element element )
{
    Account account = <span class="keyword">new</span> Account();

    account.setId( element.elementText( ELEMENT_ACCOUNT_ID ) );
    account.setName( element.elementText( ELEMENT_ACCOUNT_NAME ) );
    account.setEmail( element.elementText( ELEMENT_ACCOUNT_EMAIL ) );
    account.setPassword( element.elementText( ELEMENT_ACCOUNT_PASSWORD ) );
    account.setActivated( ( <span class="string">"true"</span>.equals( element.elementText( ELEMENT_ACCOUNT_ACTIVATED ) ) ? <span class="keyword">true</span> : <span class="keyword">false</span> ) );

    <span class="keyword">return</span> account;
}

<span class="keyword">private</span> Element <span class="title">buildAccountElement</span>( Account account )
{
    Element element = DocumentFactory.getInstance().createElement( ELEMENT_ACCOUNT );

    element.addElement( ELEMENT_ACCOUNT_ID ).setText( account.getId() );
    element.addElement( ELEMENT_ACCOUNT_NAME ).setText( account.getName() );
    element.addElement( ELEMENT_ACCOUNT_EMAIL ).setText( account.getEmail() );
    element.addElement( ELEMENT_ACCOUNT_PASSWORD ).setText( account.getPassword() );
    element.addElement( ELEMENT_ACCOUNT_ACTIVATED ).setText( account.isActivated() ? <span class="string">"true"</span> : <span class="string">"false"</span> );

    <span class="keyword">return</span> element;
}

<span class="keyword">private</span> Document <span class="title">readDocument</span>()
    <span class="keyword">throws</span> AccountPersistException
{
    File dataFile = <span class="keyword">new</span> File( file );

    <span class="keyword">if</span>( !dataFile.exists() )
    {
        dataFile.getParentFile().mkdirs();

        Document doc = DocumentFactory.getInstance().createDocument();

        Element rootEle = doc.addElement( ELEMENT_ROOT );

        rootEle.addElement( ELEMENT_ACCOUNTS );

        writeDocument( doc );
    }

    <span class="keyword">try</span>
    {
        <span class="keyword">return</span> reader.read( <span class="keyword">new</span> File( file ) );
    }
    <span class="keyword">catch</span> ( DocumentException e )
    {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to read persist data xml"</span>, e );
    }
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeDocument</span>( Document doc )
    <span class="keyword">throws</span> AccountPersistException
{
    Writer out = <span class="keyword">null</span>;

    <span class="keyword">try</span>
    {
        out = <span class="keyword">new</span> OutputStreamWriter( <span class="keyword">new</span> FileOutputStream( file ), <span class="string">"utf-8"</span> );

        XMLWriter writer = <span class="keyword">new</span> XMLWriter( out, OutputFormat.createPrettyPrint() );

        writer.write( doc );
    }
    <span class="keyword">catch</span> ( IOException e )
    {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to write persist data xml"</span>, e );
    }
    <span class="keyword">finally</span>
    {
        <span class="keyword">try</span>
        {
            <span class="keyword">if</span> ( out != <span class="keyword">null</span>)
            {
                out.close();
            }
        }
        <span class="keyword">catch</span> ( IOException e )
        {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to close persist data xml writer"</span>, e );
        }
    }
}
}
</code></pre><p>Account是一个简单的类：对变量的读取和设置</p>
<p>private String id;<br>private String name;<br>private String email;<br>private String password;<br>private boolean activated;　</p>
<p>　　该测试用例遵守了测试接口而不测试实现这一原则:也就是说，测试代码不能引用实现类，由于测试是从接口用户的角度编写的，这样就能保证接口的用户无须知晓接口的实现细节，既保证了代码的解藕，也促进了代码的设计。</p>
<p> 测试代码：这里只给出了读取readAccount的test</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountPersistServiceTest</span> </span>{
<span class="keyword">private</span> AccountPersistService service;
<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span>() <span class="keyword">throws</span> Exception{
    File persistDataFile = <span class="keyword">new</span> File(<span class="string">"target/persist-classes/persist_data.xml"</span>);
    <span class="keyword">if</span>(persistDataFile.exists()){
        persistDataFile.delete();
    }
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_persist.xml"</span>);
    service = (AccountPersistService) ctx.getBean(<span class="string">"accountPersistService"</span>);
    Account account = <span class="keyword">new</span> Account();
    account.setId(<span class="string">"ww"</span>);
    account.setName(<span class="string">"wwss"</span>);
    account.setEmail(<span class="string">"16@qq.com"</span>);
    account.setPassword(<span class="string">"####"</span>);
    account.setActivated(<span class="keyword">true</span>);
    service.createAccount(account);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadAccount</span>() <span class="keyword">throws</span> Exception{
    Account account = service.readAccount(<span class="string">"ww"</span>);
    assertEquals(<span class="string">"ww"</span>,account.getId());
    assertEquals(<span class="string">"wwss"</span>,account.getName());
    assertEquals(<span class="string">"126@qq.com"</span>,account.getEmail());
    assertEquals(<span class="string">"####"</span>,account.getPassword());
    assertTrue(account.isActivated());
}
}
</code></pre><p>　　想要将上面的代码单个模块运行成功，还需要给出相应的配置文件，xml文件放在src/main/resources下，properties文件放在src/test/resources。尤其是这里只给出了相应的两个模块的代码，有兴趣的可以继续写完成。<br>account_email.properties:<br>email.protocol=smtp<br>email.host=”127.0.0.1”<br>email.port=”25”<br>email.username=16@qq.com<br>email.password=####<br>email.auth=true<br>email.systemEmail=16@qq.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>跟着书里的讲解，跟着做了一遍该项目：</p>
<p>首先明白注册账户的需求：</p>
<p>　　账号的lD和Email地址都可以用来唯一地标识某个用户，而显示名称则用来显示在页面下，方便浏览。注册的时候用户还需要输入两次密码，以确保没有输错，系统则需要负责检查ID和emai]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014图灵技术图书最受欢迎TOP15]]></title>
    <link href="http://silencewt.github.io/2015/01/09/2014%E5%9B%BE%E7%81%B5%E6%8A%80%E6%9C%AF%E5%9B%BE%E4%B9%A6%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8ETOP15/"/>
    <id>http://silencewt.github.io/2015/01/09/2014图灵技术图书最受欢迎TOP15/</id>
    <published>2015-01-09T01:12:34.000Z</published>
    <updated>2015-01-09T01:22:26.000Z</updated>
    <content type="html"><![CDATA[<p>来自：图灵社区昨晚给我发的邮件，感觉不错，和大家分享，mark下。</p>
<p>【小编语】 回首2014，感谢小伙伴们一路相随。让我们2015一起更快乐地玩耍。今天小编为大家盘点一下过去2014年表现最给力的技术图书，它们受到了小伙伴们的一致认可。大家一起阅读下吧~</p>
<p><strong>1、Python基础教程（第2版·修订版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook1.jpg" alt="tulin1"></p>
<p>Python入门第一书</p>
<p>全面详尽，10个项目引人入胜</p>
<p><strong>2、iOS开发指南：从零基础到App Store上架（第2版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook2.jpg" alt="图林2"></p>
<p>数百个项目案例 + 两个真实项目开发全过程</p>
<p>iOS开发者推荐图书，免费视频学习更轻松</p>
<p><strong>3、JavaScript高级程序设计（第3版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook3.jpg" alt="图林3"></p>
<p>JavaScript进阶首选</p>
<p>全能前端人员必读经典</p>
<p><strong>4、深入浅出Node.js</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook4.jpg" alt="图林4"></p>
<p>阿里巴巴一线Node开发者朴灵巨献</p>
<p>深度讲解Node.js</p>
<p><strong>5、啊哈！算法</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook5.jpg" alt="图林5"></p>
<p>萌系算法第一书</p>
<p>充满趣味和智慧，人人都能看懂</p>
<p><strong>6、机器学习实战</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook6.jpg" alt="图林6"></p>
<p>使用Python阐述机器学习第一书</p>
<p>实例经典，循序渐进</p>
<p><strong>7、CCNA学习指南：路由和交换认证（100-101，200-101，200-120）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook7.jpg" alt="图林7"></p>
<p>首屈一指的CCNA应试宝典</p>
<p>针对思科认证最新考纲编写</p>
<p><strong>8、Objective-C基础教程（第2版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook8.jpg" alt="图林8"></p>
<p>全面系统讲述Objective-C基础知识和面向对象编程</p>
<p>作者均为苹果顶级开发高手</p>
<p><strong>9、R语言实战</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook9.jpg" alt="图林9"> </p>
<p>全面详尽的R语言指南</p>
<p>畅销多年，广受好评</p>
<p><strong>10、Android编程权威指南</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook10.jpg" alt="图林10"><br>原版亚马逊Android畅销第一书</p>
<p>国际知名移动训练营Big Nerd Ranch出品</p>
<p><strong>11、第一行代码——Android</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook11.jpg" alt="图林11"></p>
<p>国内最受欢迎的Android入门书</p>
<p>CSDN超人气博主郭霖力作</p>
<p><strong>12、图解HTTP</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook12.jpg" alt="图林12"></p>
<p>最简单易读的HTTP入门书</p>
<p>涵盖基础知识、最新动向<br><strong>13、图解TCP/IP（第5版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook13.jpg" alt="图林13"></p>
<p>原版畅销36万册</p>
<p>TCP/IP圣经级教材<br><strong>14、大数据：互联网大规模数据挖掘与分布式处理</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook14.jpg" alt="图林14"></p>
<p>全球著名数据库技术专家力作</p>
<p>理论与实际算法实现并重</p>
<p><strong>15、Java性能优化权威指南</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook16.jpg" alt="图林15"></p>
<p>Java性能优化圣经</p>
<p>Java之父重磅推荐</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来自：图灵社区昨晚给我发的邮件，感觉不错，和大家分享，mark下。</p>
<p>【小编语】 回首2014，感谢小伙伴们一路相随。让我们2015一起更快乐地玩耍。今天小编为大家盘点一下过去2014年表现最给力的技术图书，它们受到了小伙伴们的一致认可。大家一起阅读下吧~</p]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://silencewt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小试牛刀]]></title>
    <link href="http://silencewt.github.io/2015/01/09/maven%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://silencewt.github.io/2015/01/09/maven小试牛刀/</id>
    <published>2015-01-09T01:07:34.000Z</published>
    <updated>2015-01-09T01:27:43.000Z</updated>
    <content type="html"><![CDATA[<p>　　Maven是一个采用纯Java编写的开源项目管理工具。Maven采用了一种被称之为project object model (POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，构建，测试，发布，报告等等。目前Apache下绝大多数项目都已经采用Maven进行管理。而Maven本身还支持多种插件，可以方便更灵活的控制项目。
　　</p>
<hr>
<h3 id="构建">构建</h3>
<p>　　理解maven的第一步我们需要知道构建是什么？《maven实战》这本书里写的很清楚，早上我们会从代码库里签出最新的代码，然后进行单元测试，如果发现bug就会找同事一起解决，之后回到自己的工作上，编写单元测试或者产品代码，然后测试，午饭后可能会需要开个会，汇报工作进度，查看测试报告那么就需要用IDE使用相关的工具集成，生成报告给经理查看，也可能QA发来了几个bug,于是熟练地用IDE生成了一个WAR包，部署到Web容器下，启动容器。看到熟悉的界面了，遵循bug报告，一步步重现了bug。。。修改好bug，提交代码，通知QA，下班。就会发现，在一天的工作中，我们出了编写代码就是在编译，运行生成文档，打包和部署等烦琐且不起眼的工作上，这就是构建。如果手工这样做，那成本也太高了，于是有人用软件的方法让这一系列工作完全自动化，使得软件的构建可以像全自动流水线一样，只需要一条简单的命令，所有烦琐的步骤都能够自动完成，很快就能得到最终结果。</p>
<p>　　Maven的用途之一是服务于构建，它是一个异常强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。我们要做的是使用Maven配置好项目，然后输入简单的命令(如mvn clean install)，Maven会帮我们处理那些烦琐的任务。Maven是跨平台的，无论是在Windows上，还是在Linux或者Mac上，都可以使用同样的命令。maven 能最大化的消除重复的构建，我们不需要去定义繁琐的构建过程，只要在maven里配置好相关的信息就好。最简单的例子是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编写好测试用例，当我们运行构建的时候，这些测试便会自动运行。maven可以帮助标准化构建过程，有了Maven之后，所有项目的构建命令都是简单一致的，这极大地避免了不必要的学习成本，而且有利于促进项目团队的标准化。Maven作为一个构建工具，不仅能帮我们自动化构建，还能够抽象构建过程，提供构建任务实现；它跨平台，对外提供了一致的操作接口，这一切足以使它成为优秀的、流行的构建工具。</p>
<p>　　maven不仅仅是一个构建工具，他还是一个依赖管理工具和项目信息管理工具，它提供了中央仓库，可以帮我们自动的下载构件。比如在使用javaweb开发是，会用到各种的第三方的库或者框架，这些类库都可以通过依赖的方式注入到项目中，随着依赖的增多，版本的不一致，版本的兼容性，臃肿的问题就会出现。每次手工的解决这些问题会很烦躁，maven就提供了一个优秀的解决方案，它通过一个坐标系统准确地定位每一个构件（artifact），也就是通过一组坐标Maven能够找到任何一个Java类库（如jar文件）。Maven给这个类库世界引入了经纬，让它们变得有秩序，于是我们可以借助它来有序地管理依赖，轻松地解决那些繁杂的依赖问题。</p>
<p>　　Maven还能帮助我们管理原本分散在项目中各个角落的项目信息，包括项目描述、开发者列表、版本控制系统地址、许可证、缺陷管理系统地址等。这些微小的变化看起来很琐碎，并不起眼，但却在不知不觉中为我们节省了大量寻找信息的时间。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，我们还能够轻松获得项目文档、测试报告、静态分析报告、源码版本日志报告等非常具有价值的项目信息。</p>
<h4 id="maven与IDE的比较：">maven与IDE的比较：</h4>
<p>　　IDE虽然提高了编码的效率，但IDE依赖大量的手工操作。编译、测试、代码生成等工作都是相互独立的，很难一键完成所有工作。手工劳动往往意味着低效，意味着容易出错。</p>
<p>　　很难在项目中统一所有的IDE配置，每个人都有自己的喜好。也正是由于这个原因，一个在机器A上可以成功运行的任务，到了机器B的IDE中可能就会失败。</p>
<p>　　我们应该合理利用IDE，而不是过多地依赖它。对于构建这样的任务，在IDE中一次次地点击鼠标是愚蠢的行为。Maven是这方面的专家，而且主流IDE都集成了Maven，我们可以在IDE中方便地运行Maven执行构建。</p>
<h4 id="maven于ant的区别：">maven于ant的区别：</h4>
<p>　　ant意指“另一个整洁的工具”（Another Neat Tool），它最早用来构建著名的Tomcat。可以将Ant看成是一个Java版本的Make，也正因为使用了Java，Ant是跨平台的。此外，Ant使用XML定义构建脚本build.xml。Ant是没有依赖管理的，所以很长一段时间Ant用户都不得不手工管理依赖，现在可以借助Ivy管理依赖。而Maven内置了依赖管理。
　　</p>
<hr>
<h4 id="使用maven的情况：">使用maven的情况：</h4>
<p>　　比如你是一个小软件公司的程序员，他所在的公司要开发一个新的Web项目。经过协商，决定使用Spring、iBatis和Tapstry。jar包去哪里找呢？公司里估计没有人能把Spring、iBatis和Tapstry所使用的jar包一个不少地找出来。大家的做法是，先到Spring的站点上去找一个spring.with.dependencies，然后去iBatis的网站上把所有列出来的jar包下载下来，对Tapstry、Apache commons等执行同样的操作。项目还没有开始，WEB.INF/lib下已经有近百个jar包了，带版本号的、不带版本号的、有用的、没用的、相冲突的，怎一个“乱”字了得！  在项目开发过程中，不时地会发现版本错误和版本冲突问题，这时只能硬着头皮逐一解决。项目开发到一半，经理发现最终部署的应用的体积实在太大了，要求去掉一些没用的jar包，于是只能加班加点地一个个删…… 这时就会想，要是能有一个系统或者框架来管理这些依赖就好了， 这时maven就发挥到作用了。</p>
<p>　　<em>书籍看到这里，让我想起大四的时候进来实验室时的一个项目，就是基于SSH框架的某公司管理系统，当时，在搭建环境的时候就需要一天的时候（网络卡），到不同的网站去下不同的jar包，和安装不同的框架，期间出错了几次，为了避免在次出错自己就手动的备份了所有资料，单独列了一个清单，记录各个依赖的版本。现在回过头来看，如果当时师兄师姐使用这个来构建项目的话，会有多轻松啊。实验室所学到的东西确实是有限的，很多新技术没有跟不上社会的变化。</em></p>
<hr>
<h3 id="maven与极限编程">maven与极限编程</h3>
<p>　　maven能很好的使用极限编程XP的一些实践当中去测试驱动开发（TDD）。TDD强调测试先行，所有产品都应该由测试用例覆盖。而测试是Maven生命周期的最重要的组成部分之一，并且Maven有现成的成熟插件支持业界流行的测试框架，如JUnit和TestNG。</p>
<p>　　<strong>十分钟构建</strong>。十分钟构建强调我们能够随时快速地从源码构建出最终的产品。这正是Maven所擅长的，只需要一些配置，之后用一条简单的命令就能让Maven帮你清理、编译、测试、打包、部署，然后得到最终的产品。</p>
<p>　　<strong>持续集成（CI）</strong>。CI强调项目以很短的周期（如15分钟）集成最新的代码。实际上,CI的前提是源码管理系统和构建系统。</p>
<p>　　在传统的瀑布模型开发中，项目依次要经历需求开发、分析、设计、编码、测试和集成发布阶段。从设计和编码阶段开始，就可以使用Maven来建立项目的构建系统。在设计阶段，也完全可以针对设计开发测试用例，然后再编写代码来满足这些测试用例。然而，有了自动化构建系统，我们可以节省很多手动的测试时间。此外，尽早地使用构建系统集成团队的代码，对项目也是百利而无一害。最后，Maven还能帮助我们快速地发布项目。</p>
<hr>
<h3 id="maven安装：">maven安装：</h3>
<p>　　最新的eclipse中集成的是3.2.1的maven，为了和命令行一起使用，我在插件里面使用3.2.5的，本机上安装的也是3.2.5，这个只要在eclipse里面设置一下就好了。当然也可以设置回去的。
　　</p>
<hr>
<h3 id="maven使用">maven使用</h3>
<h4 id="（一）_生成pom">（一） 生成pom</h4>
<p> 　　pom.xml文件是maven对一个项目的核心配置，这个文件将包含你希望如何构建项目的大多数配置信息，用于描述项目如何构建，声明项目依赖，等等。虽然很难列出一张非常全面的表，但在此可先列出最普通的默认的生命周期阶段：</p>
<p>　　<strong>validate</strong>：验证工程是否正确，所有需要的资源是否可用。<br>　　<strong>compile</strong>：编译项目的源代码。<br>　　<strong>test</strong>：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。<br>　　<strong>Package</strong>：把已编译的代码打包成可发布的格式，比如jar。<br>　　<strong>integration-test</strong>：如有需要，将包处理和发布到一个能够进行集成测试的环境。<br>　　<strong>verify</strong>：运行所有检查，验证包是否有效且达到质量标准。<br>　　<strong>install</strong>：把包安装在本地的repository中，可以被其他工程作为依赖来使用。<br>　　<strong>Deploy</strong>：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。<br>　　<strong>clean</strong>：清除先前构建的artifacts（在maven中，把由项目生成的包都叫作artifact）。<br>　　<strong>site</strong>：为项目生成文档站点。</p>
<p>　　首先创建一个空文件夹，在改文件夹里新建一个文佳pom.xml，配置文件，具体内容为：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span>
     <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
           <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.silence<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">name</span>&gt;</span>Maven Hello World Project<span class="tag">&lt;/<span class="title">name</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">project</span>&gt;</span>  
</code></pre><p>　　第二行：project元素，这是pom.xml的根元素，声明pom相关的命名空间，这里面的属性可以让我们的IDE跟快速的编辑pom第一行：制定了该xml文档的版本和编码方式。<br>　　第六行：根元素下的第一个子元素modelVersion指定了当前POM模型的版本，对于Maven2及Maven 3来说，它只能是4.0.0。<br>　　第7行到9行是最重要的代码段，groupId，artifactId和version这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者war都是以基于这些基本的坐标进行区分的。<br>　　<br>　　<strong>groupId</strong>定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联，譬如你在googlecode上建立了一个名为myapp的项目，那么groupId就应该是com.googlecode.myapp，如果你的公司是mycom，有一个项目为myapp，那么groupId就应该是com.mycom.myapp。<br>　　<br>　　<strong>artifactId</strong>定义了当前Maven项目在组中唯一的ID，我们为这个Hello World项目定义artifactId为hello-world，本书其他章节代码会被分配其他的artifactId。而在前面的groupId为com.googlecode.myapp的例子中，你可能会为不同的子项目（模块）分配artifactId，如：myapp-util、myapp-domain、myapp-web等等。</p>
<p>　　<strong>version</strong>指定了Hello World项目当前的版本——1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。随着项目的发展，version会不断更新，如升级为1.0、1.1-SNAPSHOT、1.1、2.0等等。</p>
<p>　　第十行：name元素声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但我还是推荐为每个POM声明name，以方便信息交流。</p>
<h4 id="（二）编写主代码">（二）编写主代码</h4>
<p> 　　项目主代码和测试代码不同，项目的主代码会被打包到最终的构件中（比如jar），而测试代码只在运行测试时用到，不会被打包。默认情况下，Maven假设项目主代码位于src/main/java目录，我们遵循Maven的约定，创建该目录，然后在该目录下创建文件com/juvenxu/mvnbook/helloworld/HelloWorld.java，<br> 　　写好这个之后，可以回到项目根目录下，运行mvn clean compile就可以生成编译java文件，生成对应的class文件</p>
<h4 id="（三）测试代码">（三）测试代码</h4>
<p>　　Maven项目中默认的测试代码目录是src/test/java。com/juvenxu/mvnbook/helloworld/testHelloWorld.java要有测试代码得为Hello World项目添加一个JUnit依赖，即在pom.xml中添加<dependencies>元素；</dependencies></p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span> 
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</code></pre><p>　　</p>
<p>　　第6行：scope为依赖范围，若依赖范围为test则表示该依赖只对测试有效，换句话说，测试代码中的import JUnit代码是没有问题的，但是如果我们在主代码中用import JUnit代码，就会造成编译错误。如果不声明依赖范围，那么默认值就是compile，表示该依赖对主代码和测试代码都有效。有了这段声明，Maven就能够自动从中央仓库（<a href="http://repo1.maven.org/maven2/）里下载junit-4.7.jar。" target="_blank" rel="external">http://repo1.maven.org/maven2/）里下载junit-4.7.jar。</a></p>
<h4 id="（四）执行">（四）执行</h4>
<p>　　mvn clean compile、mvn clean test（测试）、mvn clean package（打包）、mvn clean install（安装）。执行test之前是会先执行compile的，执行package之前是会先执行test的，而类似地，install之前会执行package。</p>
<p> 　　命令行输入的是mvn clean test，而maven实际执行的可不止这两个任务，还有clean:clean、resources:resources、compiler:compile、resources:testResources以及compiler:testCompile。暂时我们需要了解的是，在Maven执行测试（test）之前，它会先自动执行项目主资源处理，主代码编译，测试资源处理，测试代码编译等工作，这是Maven生命周期的一个特性。</p>
<h4 id="（五）简单的原型Archetype">（五）简单的原型Archetype</h4>
<p>　　可以快速的生成项目骨架，避免每次都一个个的创建文件夹，可以执行mvn archetype:generate，也可以在eclipse中选择。当然也可以根据自己的需要开发使用自定义的archetype来快速生成项目骨架。</p>
<hr>
<h3 id="maven坐标">maven坐标</h3>
<p>　　为了能自动的解析任何一个java构件，maven就将他们用坐标唯一标识，坐标元素包括:groupId,artifactId,version,packaging,classifier，只要设置这几个元素就可以很轻松地从中央仓库那儿获得对应的构件。前三天上面有介绍过，这里说说packaging：定义maven的打包方式，一般为jar（默认），当然也可以是war行的，最终会生成war的文件。classifier：帮助定义构建输出的一些附属构件。如某项目的主构件是nexus-index-2.0.0.jar，可能还会有nexus-index-2.0.0-Javadoc.jar和nexus-index-2.0.0-sources.jar这样一些附属构件（java文档和源代码），这里javadoc和sources就是这两个附属构件的classifier,这样附属的构件也会有自己唯一的坐标。</p>
<hr>
<h3 id="maven依赖">maven依赖</h3>
<p>　　每个依赖包含的元素有：groupId、artifactId、version还有type：<br>　　<strong>scope</strong>：依赖范围。用来控制依赖与这三种classpath的关系（编译classpath、运行classpath、测试classpath），如果没有指定依赖范围则默认使用compile，在编译、运行和测试的时候都需要用到该依赖。test则只对测试classpath有效，在编译主代码和运行项目的时候不会包含进去。runtime运行时的依赖，对测试运行有效，在编译主代码时无效。其实，还有provided和system两种。</p>
<p>　　<strong>optional</strong>：标记依赖是否可选，比如项目A依赖于项目B，B依赖于X和Y（XY可选的），根基依赖传递性，ＸＹ会是A的传递性依赖，但是由于XY是可选的，那么依赖不会传递，XY对A不会有影响。也就是说XY只对B起作用，不会被传递，如果A中需要XY则需要显示的声明。这个并不推荐，最好的方式就是排除依赖。可以使用maven命令分析依赖关系：mvn dependency:analyze</p>
<p>　　<strong>exclusions</strong>：用来排除传递性依赖maven引人的传递性依赖机制。一方面大大简化和方便了依赖声明。另一方面，大部分情况下我们只需要关心项目的直接依赖是什么，而不用考虑这些直接依赖会引人什么传递性依赖。但有时候，当传递性依赖造成问题的时候，我们就需要清楚地知道该传递性依赖是从哪条依赖路径引人的。这个可以以后遇到了在了解。</p>
<hr>
<h4 id="依赖范围">依赖范围</h4>
<p>　　就是用来控制依赖与这三种classpath(编译classpath、测试classpath、运行classpath)的关系，Maven有以下几种依赖范围：</p>
<p>　　<strong>compile</strong>: 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。</p>
<p>　　<strong>test</strong>:测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子就是JUnit，它只有在编译测试代码及运行测试的时候才需要。</p>
<p>　　<strong>provided:</strong> 已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。</p>
<p>　　<strong>runtime:</strong> 运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</p>
<p>　　<strong>system:</strong> 系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量</p>
<hr>
<h3 id="maven仓库">maven仓库</h3>
<p>　　简单来说就是，maven依赖构件存放的地方，所有的依赖构件都从仓库里下载，除了本地的项目依赖。maven有提供一个中央仓库，里面有各种开源的构件，可很方便的从上面获得。当然，这个仓库是远程的，也可以在本地设置一个私服，Nexus就是一个流行的开源maven仓库管理软件。现在我只需要使用仓库里的就可以了，没必要去建立私服。此处略过。</p>
<hr>
<h3 id="maven生命周期和插件：">maven生命周期和插件：</h3>
<p> 　　maven的生命周期就是为了对所有的构建过程进行抽象和统一，从大量项目和构建工具中学习和反思，然后总结了一套高度完善的、易扩展的生命周期。这个生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。也就是说，几乎所有项目的构建，都能映射到这样一个生命周期上。</p>
<p> 　　在maven的设计中，实际的任务(如编译源代码)都交由插件来完成。这种思想与设计模式中的模板方法非常相似。模板方法模式在父类中定义算法的整体结构，子类可以通过实现或者重写父类的方法来控制实际的行为，这样既保证了算法有足够的可扩展性，又能够严格控制算法的整体结构。</p>
<p>　　这本书里写的很清楚：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> AbstractBuild{
<span class="keyword">public</span> <span class="keyword">void</span> Build（）{
    initialize（）；
    compile（）；
    test（）；
    packagee（）；
    integrate（）；
    deploy（）；
}
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> initialize（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> compile（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> test（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> packagee（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> integrate（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> deploy（）；
}
</code></pre><p>　　生命周期抽象了构建的各个步骤，定义它们的次序，但没有提供具体实现，那么谁来实现这些步骤呢？不能有用户为了编译而写一堆代码。为测试又写一堆代码，那么就在重复发明轮子了?maven考虑了，因此设计插件机制。每个构建步骤都可以绑定一个或者多个插件行为，而maven为大多数构建步骤编写并绑定了默认插件。插件完成具体的任务，是实现着。maven有自动绑定的插件，当然也可以自定义绑定，在pom中设置build plugins plugin属性。 </p>
<p>　　maven有三套独立的生命周期：clean（清理项目）、default（构建项目）、site（建立项目站点）。每个生命周期都有几个阶段，这些阶段是有顺序的，调用后面的阶段时，必须先调用前面的阶段。我们从命令行执行maven命令就是在调用其生命周期阶段，比如：mvn clean：就是执行pre-clean和clean阶段。mvn test：执行default周期的validate、initialize……直到test阶段。mvn clean install：就是clean阶段加上default周期的直到install阶段。</p>
<hr>
<h3 id="maven聚合和继承">maven聚合和继承</h3>
<p>　　我们通常会将不一个项目分成不同的模块向，注册服务会分成persist，service等模块，maven的聚合特性能够把项日的各个模块聚合在一起构建，而maven继承特性则能帮助抽取各模块相同的依赖和插件等配置。在众多模块中，不可能对每个项目都进行构建，执行maven命令，会想用一个命令就运行几个模块的内容，为了能够一条命令就构建两个模块，需要在额外的创建一个account-aggregato模块，然后通过该模块构建整个项目的所有模块。对于聚合模块来说，pom.xml中的打包方式必须为pom,否则就无法构建。各个模块可以放在聚合模块目录下，即和pom同一个目录，聚合模块是项目目录的最顶层，其他莫快则作为其子目录存在。这个并不是唯一的，子模块也可以和聚合模块平行。</p>
<p>　　多模块项目中，各模块中会有很多相同的groupID和version，相同的spring依赖，和plugin配置。这就是重复，重复往往以为着更</p>
<p>　　更多的劳动和更多的潜在的问题。在面向对象世界中，程序员可以使用类继承在一定程度上消除重复，在maven的世界中，也有类似的机制能让我们抽取出重复的配置，这就是POM的继承。需要创建POM的斧子结构，然后在父POM中声明一些配置供子POM继承。以实现一处声明，多处使用的目的。</p>
<p>　　<strong>聚合的目的：快速构建项目</strong><br>　　<strong>继承的目的：消除重复配置</strong></p>
<hr>
<p>参考书籍：《maven实战》 <a href="http://hzbook.group.iteye.com/group/wiki/2872-Maven-in-action" target="_blank" rel="external">http://hzbook.group.iteye.com/group/wiki/2872-Maven-in-action</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　Maven是一个采用纯Java编写的开源项目管理工具。Maven采用了一种被称之为project object model (POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合文章系列汇总]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E6%96%87%E7%AB%A0%E7%B3%BB%E5%88%97%E6%B1%87%E6%80%BB/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合文章系列汇总/</id>
    <published>2014-12-30T06:41:27.000Z</published>
    <updated>2014-12-30T06:51:58.000Z</updated>
    <content type="html"><![CDATA[<p>　　这是实验室项目的资料汇总，一方面便于自己整理，理清思路，另一方面让大家对图像融合有个大概的了解。以后项目还没有完结，以后还会有所补充。</p>
<p>图像融合文章系列汇总：</p>
<p><a href="http://silencewt.github.io/2014/12/29/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E6%A6%82%E8%BF%B0/" target="_blank" rel="external">图像融合（一）— 概述</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E7%AE%80%E5%8D%95%E5%8A%A0%E6%9D%83%E8%9E%8D%E5%90%88/" target="_blank" rel="external">图像融合（二）— 简单加权融合</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（三）— 拉普拉斯金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%AF%B9%E6%AF%94%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（四）— 对比度金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89-%E6%A2%AF%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（五）— 梯度金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89-%E5%B0%8F%E6%B3%A2%E8%9E%8D%E5%90%88/" target="_blank" rel="external">图像融合（六）— 小波融合</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这是实验室项目的资料汇总，一方面便于自己整理，理清思路，另一方面让大家对图像融合有个大概的了解。以后项目还没有完结，以后还会有所补充。</p>
<p>图像融合文章系列汇总：</p>
<p><a href="http://silencewt.github.io/2014/]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（六）-- 小波融合]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89-%E5%B0%8F%E6%B3%A2%E8%9E%8D%E5%90%88/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（六）-小波融合/</id>
    <published>2014-12-30T05:47:21.000Z</published>
    <updated>2014-12-30T06:35:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="基于小波的融合（wavelet）">基于小波的融合（wavelet）</h3>
<p>　　小波变换的固有特性使其在图像处理中有如下优点：完善的重构能力，保证信号在分解过程中没有信息损失和冗余信息；把图像分解成平均图像和细节图像的组合，分别代表了图像的不同结构，因此容易提取原始图像的结构信息和细节信息；小波分析提供了与人类视觉系统方向相吻合的选择性图像。</p>
<p>　　离散小波变换(Discrete Wavelet Transform, DWT)。DWT的函数基由一个称为母小波或分析小波的单一函数通过膨胀和平移获得。因而，DWT同时具有时域和频域分析能力，与一般的金字塔分解相比，DWT图像分解具有以下优势：</p>
<ol>
<li>具有方向性，在提取图像低频信息的同时，还可获得了水平、垂直和对角三个方向的高频信息；</li>
<li>通过合理的选择母小波，可使DWT在压缩噪声的同时更有效的提取纹理、边缘等显著信息；</li>
<li>金字塔分解各尺度之间具有信息的相关性，而DWT在不同尺度上具有更高的独立性。</li>
</ol>
<p>DWT融合算法基本思想与金字塔算法一致，即：首先对源图像进行小波变换，然后按照一定规则对变换系数进行合并；最后对合并后的系数进行小波逆变换得到融合图像。由于不具有移不变性，基于DWT的标准小波融合算法获取的融合图像通常会存在“振铃”干扰;特别在处理连续的图像序列时，融合结果会出现明显的闪烁和抖动现象。</p>
<h4 id="1、原理阐述">1、原理阐述</h4>
<p>　　（1）小波的简单计算原理</p>
<p>　　 [x0，x1，x2，x3]=[90，70，100，70] 为达到压缩 我们可取 (x0+x1)/2  (x0-x1)/2 来代表 x0,x1  这样 [90,70] 可表示为 [80,10] 80即平均数 10是小范围波动数（可想象出一种波的形状） [90,70] —〉[80,10] , [100,70] —〉 [85,15] 可以想象80 和85 都是局部的平均值反映大的总体的状态，是变化相对缓慢的值，可以认为他们是低频部分的值。 而10、15是小范围波动的值局部变换较快，可以认为他们是高频部分的值。</p>
<p>　　1、 FIRST：把[90,70,100,70] 写成 [80,85,10,15] 即把低频部分写在一起（记频率L） 高频部分写在一起（H) </p>
<p>　　2、 SECOND：而[80,85] 又可经同样的变换—&gt; [82.5, -2.5] 这样 82.5表示更低频的信息(记频率LL) -2.5则表示了频率L上的波动 </p>
<p>　　3、最后[90,70,100,70] —〉[82.5, -2.5, 10, 15] 这样信息就可被压缩了（数字范围小了）</p>
<p>　　现在再来扩展一下  [90,70]—-&gt; [80,10] 写成矩阵 [90,70] * [1/2, 1/2]<br>[1/2 ,-1/2] 矩阵[1,1；1,-1]/2为haar转换矩阵。</p>
<p>　　如果是[90,70,100,70]第一步就可以写成矩阵M1：[0.5,0,0.5,0; 0.5,0,-0.5,0; 0,0.5,0,0.5;0,0.5,0,-0.5]，第二步只对低频L操作，高频不变可写成M2：[1/2,  1/2, 0, 0; 1/2, -1/2, 0, 0; 0,  0,  1, 0 ;0,  0,  0, 1]。另M= M1<em>M2，可得到4</em>4的点阵操作。</p>
<p>　　第一步运算后原图像缩小至左边一半了，右边的是对应波动信息；</p>
<p>　　第二步运算后图像又缩小至左边一半了，对应波动信息。</p>
<p>　　对一幅图像先进行行变化，在进行列变化，那么就是小波变化了。</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.1.png" alt="wave1"></p>
<p>　　LL：水平低频，垂直低频</p>
<p>　　LH：水平低频，垂直高频</p>
<p>　　HL：水平高频，垂直低频</p>
<p>　　HH：水平高频，垂直高频</p>
<p>　　其中，L表示低频，H表示高频，下标1、2表示一级或二级分解。在每一分解层上，图像均被分解为LL，LH，HH和HL四个频带，下一层的分解仅对低频分量LL进行分解。这四个子图像中的每一个都是由原图与一个小波基函数的内积后，再经过在x和y方向都进行2倍的间隔采样而生成的。这是正变换，也就是图像的分解；逆变换，也就是图像的重建。是通过图像的增频采样和卷积来实现的。这里有个问题进过处理后，数据或超出255或者出现负数，需要将其归一化到0-255之间，方可显示图像。这里介绍的只是简单的小波计算，小波计算的而不同就在于选取不同的小波系数，一般有haar小波，sym2小波等。</p>
<p>资料：<a href="http://www.blogbus.com/shijuanfeng-logs/221385402.html" target="_blank" rel="external">http://www.blogbus.com/shijuanfeng-logs/221385402.html</a></p>
<h4 id="2、融合规则">2、融合规则</h4>
<p><strong>规则一</strong>：系数绝对值较大法</p>
<p>　　该融合规则适合高频成分比较丰富，亮度、对比度比较高的源图像，否则在融合图像中只保留一幅源图像的特征，其他的特征被覆盖。小波变换的实际作用是对信号解相关，并将信号的全部信息集中到一部分具有大幅值的小波系数中。这些大的小波系数含有的能量远比小系数含有的能量大，从而在信号的重构中，大的系数比小的系数更重要。</p>
<p><strong>规则二</strong>：加权平均法</p>
<p>　　权重系数可调，适用范围广，可消除部分噪声，源图像信息损失较少，但会造成图像对比度的下降，需要增强图像灰度。</p>
<p><strong>规则三</strong>：局部方差准则</p>
<p>　　设A(x,y)和B(x,y)分别为高频子图像数据值，F(x,y)为相应高频子图像融合值，将A(x,y)和B(x,y)分成若干个M×N子块图像。对每个子块图像进行数值分布统计，计算其方差。确定A和B图像每个子块图像加权系数K1和K2。如果A图像子块方差大于B图像子块方差,则K1≥K2，否则K1&lt;K2。确定每个子块图像的数据融合数值为：F(i,j)=K1A(i,j)+K2B(i,j)。</p>
<h4 id="3、融合应用">3、融合应用</h4>
<p>　　若对二维图像进行N层的小波分解,最终将有(3N+1)个高低频带，其中包含3N个高频带和一个低频带。图像融合的基本步骤如下。</p>
<p>　　1）对每一源图像分别进行小波分解，建立图像的小波金字塔分解。</p>
<p>　　2）对各分解层分别进行融合处理，采用不同的融合算子对各分解层的不同频率分量进行融合处理，最终得到融合后的小波金字塔。低频：加权平均，高频：绝对值取大。</p>
<p>　　3）对融合后所得的小波金字塔进行小波逆变换，所得到的重构图像即为融合后的图像。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.2.png" alt="wave2"></p>
<p>　　图像的低频部表现的是图像的概貌和平均特性；图像的高频反应的是图像的细节特性，如图像的边缘、区域边界等。</p>
<p>　　融合规则：</p>
<p>　　基于局部方差的融合规则：在邻域W中，图像I在以（i ，j)为中心点的局部方差定义：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.3.png" alt="wave3"></p>
<p>　　式中为图像I 的均值，M，N 分别为局部区域的行数和列数，这里取局部区域为3*3，基于局部方差的融合方式常用的方法是选择法，即通常说的局部方差取大法。方差选择法的融合规则<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.4.png" alt="wave4"></p>
<p>　　L为分解尺度， 表示图像小波系数，<img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.5.png" alt="wave5"> 表示图像小波系数， =d=H,V,D分别表示的是水平、垂直、对角高频分量。如果两幅图片直接使用局部方差法进行融合，局部方差相差较大时，采用局部方差取大法能够比较完整的存储图像的微小细节。一旦局部方差相差很小时，局部方差取大法会使图像细节失真。</p>
<p>　　图像融合有一个重要的目的，即将图像的边缘、细节等都包含到融合图像中。一种方法是将图像的边缘提取出来，将它应用到相应的融合算法中。图像边缘检测的最好的算子是 canny 算子，将canny算子和局部方差的融合规则的算法相结合，提出了一种新的改进融合方法。融合步骤如下：</p>
<p>　　（1）小波分解。对于图像 A，B 分别进行 3 层小波分解，得到低频分量AA、AB和高频分量DLH，DLV，DLD。</p>
<p>　　（2）低频融合。对低频分量AA 和AB 所有的像素点计算其局部方差Var(i ,j)AA和 Var(i ,j)BA，然后进行归一化：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.6.png" alt="wave6"></p>
<p>　　然后，利用归一化的局部方差，按照如下：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.7.png" alt="wave7"></p>
<p>　　（3）高频融合。在图像 A 和 B 的每一个高频分DLA，DLB中，对每一个高频分量用 canny 算子进行边缘提取，再对边缘图像的每一个元素计算局部方差：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.8.png" alt="wave8"></p>
<p>　　其中 <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.9.png" alt="wave9"><br>表示源图像的第l层经 canny 算子处理的高频系数 <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.10.png" alt="wave10">为源图像的第l层经 canny 算子提取后的均值。<img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.11.png" alt="wave11"> 是对源图像的第l层高频分量进行边缘提取后求得的局部方差。<br> <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.12.png" alt="wave12"></p>
<p>　　（4）小波重构。对融合后的系数进行小波重构，得到融合后的图像。</p>
<p>　　附：这里介绍的小波是最简单的形式，融合规则也比较常用，很多红外和可见的融合也都用到了这里的规则，所以，实现这里面的算法来适用我们的应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="基于小波的融合（wavelet）">基于小波的融合（wavelet）</h3>
<p>　　小波变换的固有特性使其在图像处理中有如下优点：完善的重构能力，保证信号在分解过程中没有信息损失和冗余信息；把图像分解成平均图像和细节图像的组合，分别代表了图像的不同结构，因此]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
</feed>
