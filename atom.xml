<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silence 婷婷 Blog]]></title>
  <subtitle><![CDATA[既然选择远方，便风雨兼程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2014-12-25T08:24:44.877Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Wangt]]></name>
    <email><![CDATA[wangt_hust@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JUnit单元测试--小试牛刀]]></title>
    <link href="http://yoursite.com/2014/12/25/JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://yoursite.com/2014/12/25/JUnit单元测试-小试牛刀/</id>
    <published>2014-12-25T07:51:46.000Z</published>
    <updated>2014-12-25T08:16:46.000Z</updated>
    <content type="html"><![CDATA[<p>单元测试更多的是在开发阶段完成，开发人员每写一个函数的时候都会写相应的单元测试。对于java代码，普遍使用的是jUnit，根据jUnit可以自己相应的开发一套自动化测试框架。这个的前提是要学会junit，先知道怎么用，才能知道怎么为我所用。</p>
<p>学习JUnit的操作很简单，JUnit是一个敏捷编程的开发框架，他的设计很值得学习。这也是我学习JUnit的原因。</p>
<p>JUnit最大的特点就是：各个方法之间是独立的，一个方法的失败不会影响另一个方法的执行。</p>
<p>JUnit 3：是基于反射机制的方法，有命名的约束，必须以test开头。每一个类都继承了TestCase类，而TestCase的父类是Assert类。即所有测试类都是TestCase类的子类。</p>
<p>JUnit 4：引入了注解(annotation)，通过解析注解就可以为测试提供相应的信息。@Test表明这是要执行的测试方法，不管测试方法的名字是什么，都会执行。每一个类可以不继承任何类，可以是一个普通类也可以去继承一个类或实现一个接口，要实现测试只需要在要测试的方法之前加@Test注释就可以了，但是仍然可以直接使用断言，静态导入import static org.junit.Assert.*；</p>
<p>为了更好地理解junit测试用例，我找了一个简单的例子来练习：</p>
<p>例如有这么一个类Greeting，根据每天不同的时间来返回不同的问候语：</p>
<pre><code><span class="keyword">package</span> com.test.one;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>{
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_MORNING = <span class="string">"Good Morning Sunshine!"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_AFTERNOON = <span class="string">"Just a few more hours before quiting time!"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_EVENING = <span class="string">"I am outta here"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HOUR_MORNING = <span class="number">12</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HOUR_AFTERNOON = <span class="number">17</span>;
  <span class="keyword">private</span> java.sql.Timestamp iGreetingTime = <span class="keyword">null</span>;
  <span class="keyword">public</span> <span class="title">Greeting</span>(){
    <span class="keyword">this</span>(System.currentTimeMillis());
  }
  <span class="keyword">public</span> <span class="title">Greeting</span>(<span class="keyword">long</span> greetingTime) {
    <span class="keyword">super</span>();
    iGreetingTime = <span class="keyword">new</span>  java.sql.Timestamp(greetingTime);
}
  <span class="keyword">public</span> String <span class="title">getGreeting</span>(){

    <span class="keyword">if</span>(iGreetingTime.getHours()&lt;MAX_HOUR_MORNING){
        <span class="keyword">return</span> GREETING_MORNING;
    }<span class="keyword">else</span> <span class="keyword">if</span> (iGreetingTime.getHours()&lt;MAX_HOUR_AFTERNOON) {
        <span class="keyword">return</span> GREETING_AFTERNOON;
    }<span class="keyword">else</span> {
        <span class="keyword">return</span> GREETING_EVENING;
    }
  }
}
</code></pre><p>我们需要测试这个类，看是否可以根据时间的不同，来呈现不同的问候语。创建junit的测试用例需要遵循一下几点：</p>
<p>1、Junit类需继承TestCase<br>2、setUp（）和setDown（）为每个方法准备或销毁测试装备<br>3、创建public的方法，方法名为test开头，如testMorningGreeting（），使用assert判断实际返回的值和期望。<br>4、super（testMethod）为每个测试方法生成实例。首先执行setUp()，然后执行testMethod ，最后执行tearDown（）。</p>
<pre><code><span class="keyword">package</span> com.test.test;

<span class="keyword">import</span> java.sql.Time;

<span class="keyword">import</span> com.test.one.Greeting;

<span class="keyword">import</span> junit.framework.TestCase;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>{

    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span>() <span class="keyword">throws</span> Exception {
        <span class="keyword">super</span>.setUp();
    }

    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span>() <span class="keyword">throws</span> Exception{
        <span class="keyword">super</span>.tearDown();
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMorningGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the morning greeting expected"</span>, Greeting.GREETING_MORNING, greeting.getGreeting());
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAfternoonGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the Afternoon greeting expected"</span>, Greeting.GREETING_AFTERNOON, greeting.getGreeting());
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEveningGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the Evening greeting expected"</span>, Greeting.GREETING_EVENING, greeting.getGreeting());
    }

    <span class="keyword">public</span> <span class="title">GreetingTest</span>(String testMethod){
        <span class="keyword">super</span>(testMethod);
    }
}
</code></pre><p>这个只是单个测试用例，junit也提供了测试套件组织想要执行的测试用例。</p>
<p>如果你已经有了两个测试用例，AddJobCmdImpTest、RemoveJobCmdImpTest等TestCase的子类别，如果想一次运行这两个测试，需要使用AllTest的类，代表一个测试套件。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> AllTest {
<span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span>(){
    TestSuite suite = <span class="keyword">new</span> TestSuite(<span class="string">"Test for XXXX"</span>);
    suite.addTest(<span class="keyword">new</span> TestSuite(AddJobCmdImpTest.class));
    suite.addTest(<span class="keyword">new</span> TestSuite(RemoveJobCmdImpTest.class));
    <span class="keyword">return</span> suite;
}
}
</code></pre><p>以下是JUnit4的代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>{

<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span>() <span class="keyword">throws</span> Exception {
    <span class="keyword">super</span>.setUp();

}
<span class="annotation">@After</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span>() <span class="keyword">throws</span> Exception{
    <span class="keyword">super</span>.tearDown();
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ttrestMorningGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the morning greeting expected"</span>, Greeting.GREETING_MORNING, greeting.getGreeting());
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAfternoonGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the Afternoon greeting expected"</span>, Greeting.GREETING_AFTERNOON, greeting.getGreeting());
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEveningGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the Evening greeting expected"</span>, Greeting.GREETING_EVENING, greeting.getGreeting());
}
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>单元测试更多的是在开发阶段完成，开发人员每写一个函数的时候都会写相应的单元测试。对于java代码，普遍使用的是jUnit，根据jUnit可以自己相应的开发一套自动化测试框架。这个的前提是要学会junit，先知道怎么用，才能知道怎么为我所用。</p>
<p>学习JUnit的操]]>
    </summary>
    
      <category term="JUnit" scheme="http://yoursite.com/tags/JUnit/"/>
    
      <category term="软测" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[功能测试用例编写]]></title>
    <link href="http://yoursite.com/2014/12/25/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99/"/>
    <id>http://yoursite.com/2014/12/25/功能测试用例编写/</id>
    <published>2014-12-25T07:42:30.000Z</published>
    <updated>2014-12-25T07:51:00.000Z</updated>
    <content type="html"><![CDATA[<p>由于还不熟悉怎么用markdown来展现表格的内容，若想查看请移步我的博客园：<br><a href="http://www.cnblogs.com/silence-hust/p/4112055.html" target="_blank" rel="external">http://www.cnblogs.com/silence-hust/p/4112055.html</a></p>
<p>感谢大家的关注，我会继续努力的……</p>
<p>下面是幅我很喜欢的图片：人为什么要怎么努力，分享给大家<br>一定要看到最后哦！<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/人为什么要努力1.jpg" alt="人为什么要怎么努力"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于还不熟悉怎么用markdown来展现表格的内容，若想查看请移步我的博客园：<br><a href="http://www.cnblogs.com/silence-hust/p/4112055.html" target="_blank" rel="external">ht]]>
    </summary>
    
      <category term="测试用例" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
      <category term="软测" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/"/>
    
      <category term="测试用例" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[web前端性能测试小点]]></title>
    <link href="http://yoursite.com/2014/12/25/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%82%B9/"/>
    <id>http://yoursite.com/2014/12/25/web前端性能测试小点/</id>
    <published>2014-12-25T06:57:34.000Z</published>
    <updated>2014-12-25T07:04:46.000Z</updated>
    <content type="html"><![CDATA[<p>关于前端性能的文章：<br> <a href="http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html</a></p>
<p>　　web应用的前端性能响应时间指浏览器的页面加载时间。浏览器的页面加载时间包括对html的解析，对页面图片及css等文件的获取和加载、客户端脚本的执行时间以及对你页面进行展现所花费的时间。这个与并发用户量的大小并没有直接的关系，主要关注：如何提高浏览器下载和执行资源的并发性，如何让浏览器尽快开始渲染页面，如何让浏览器尽可能充分的利用缓存。在yahoo中，到少50个团队通过纯粹的前端性能相关的技巧，将最终用户的响应时间减少了25%以上。<br>　　<br>在了解web前端性能时，我们应该知道http协议。</p>
<p>　　http协议采用请求/响应模型，客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本等信息，服务器以一个状态行作为响应，响应的内容包括消息协议的版本、成功或者错误编码加上包含服务器的信息、实体元信息等内容。该协议是一种非面向连接的协议，每个http请求都是独立的。<br>　　<code>请求报文的格式</code>：请求行 | 通用信息头 | 请求头 | 实体头 | 报文主体   Method     Request-URI  HTTP-versionCRIF<br>　　<code>响应报文的格式</code>：状态行 | 通用信息头 | 响应头 | 实体头 | 报文主体</p>
<p>响应报文的状态码如下：</p>
<blockquote>
<p>1XX：信息响应类，表示接收到请求并继续处<br>2XX：处理成功响应类，表示动作被成功接收、理解和接收<br>3XX：重定向响应类，表示为了完成指定的动作，必须接收进一步处理<br>4XX：客户端错误，表示客户请求包含语法错误或不能正确的执行<br>5XX：服务端错误，表示服务器不能正确执行一个正确的请求</p>
</blockquote>
<p>与前端性能相关的头信息：</p>
<p> 1、accept-encoding：告诉服务器所接受的页面的编码方式，gzip使用gzip压缩，deflate不压缩，压缩可以减少下载所需的时间。</p>
<p>2、connection：因为HTTP是费面向连接的，无状态的协议，每一个HTTP请求都会经过“建立连接—请求页面或资源—获得资源—断开连接”的过程。对于小的资源可能建立连接的时间都会超过对资源的处理时间，为了减少时间引入了持久连接。当浏览器和服务器约定好后，当某个资源传输完成后并不立即断开连接，而是等待一段时间，在这段时间内若传输其他的资源就复用该连接，否则就关闭。当值为keep-alive时有持久连接。</p>
<p>3、expires：用于只是返回数据的到期时间。到期时间之前都是从缓存处直接获取相应的资源，之后才会向服务器发送请求获取。</p>
<p>提高前端性能的方法：</p>
<blockquote>
<p>1、减少页面加载的时间，<br>2、减少网络时间：CDN技术，DNS缓存技术，减少文件的尺寸<br>3、减少发送的请求量：利用浏览器缓存<br>4、让页面尽早的开始显示</p>
</blockquote>
<h4 id="对于前段性能测试的理解：">对于前段性能测试的理解：</h4>
<p>　　由于自己之前有两三个月的时间接触了前端，对于前端的知识点比较熟悉，在这方面理解起来不是很困难，对于http协议，用户响应请求的过程都熟悉，但是那个时候并没有详细的考虑到页面的加载时间问题，只是想着将页面呈现出来，而忽略了对于响应时间的要求。由于自己都是在本机上实现的，所以每次想看结果的时候都要等很久，这就是没有使用性能的思想，去减少页面的加载时间，没有考虑周全。现在对于这方面有了更深的理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于前端性能的文章：<br> <a href="http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html" target="_blank" rel="external">http://www.cnblogs.co]]>
    </summary>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软测" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能测试之需求开发]]></title>
    <link href="http://yoursite.com/2014/12/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2014/12/25/性能测试之需求开发/</id>
    <published>2014-12-25T06:54:52.000Z</published>
    <updated>2014-12-25T08:24:31.000Z</updated>
    <content type="html"><![CDATA[<p>以下内容大多来自jackei的博客，只是整理了下，增加了自己的理解。</p>
<h4 id="一个实际的例子：">一个实际的例子：</h4>
<p> 某证券行业系统中某个业务的实际需求<br>1、系统总容量达到日委托6000万笔，成交9000万笔<br>2、 系统处理速度每秒7300笔，峰值处理能力达到每秒10000笔<br>3、实际股东帐号数3000万</p>
<p>从上面例子中可以看出几个明确的需求：<br>1、最佳并发用户数需求：每秒7300笔<br>2、最大并发用户数需求：峰值处理能力达到每秒10000笔<br>3、基础数据容量：实际股东帐号数3000万<br>4、业务数据容量：日委托6000万笔，成交9000万笔——可以根据这个推算出每周、每月、每年系统容量的增长模型</p>
<h4 id="什么是“有效的”性能需求？">什么是“有效的”性能需求？</h4>
<p>　　要想获得有效的性能需求，就要先了解什么样的需求是“有效的”。有效的性能需求应该符合以下三个条件。</p>
<p>1、 明确的数字，而不是模糊的语句。</p>
<p>　　结合上面的例子来看，相信这个应该不难理解。但是有的时候有了数字未必就不模糊。例如常见的一种需求是“系统需要支持5000用户”，或者“最大在线用户数为8000”。这些有数字的需求仍然不够明确，因为还需要考虑区分系统中不同业务模块的负载，以及区分在线用户和并发用户的区别。</p>
<p>2、有凭有据，合理，有实际意义。</p>
<p>　　通常来说，性能需求要么由客户提出，要么由开发方提出。对于第一种情况，要保证需求是合理的，有现实意义的，不能由着客户使劲往高处说，要让客户明白性能是有成本的。对于第二种情况，性能需求不能简单的来源于项目组成员、PM或者测试工程师的估计或者猜测，要保证性能需求的提出是有根据的，所使用的数据和计算公式是有出处的。</p>
<p>3、相关人员达成一致。</p>
<p>　　如果相关人不能对性能需求达成一致，可能测了也白测——特别是在客户没有提出明确的性能需求而由开发方提出时。这里要注意“相关人员”的识别，通常项目型的项目的需要与客户方的项目经理或负责人进行确认，产品型的项目需要与直属领导或者市场部进行确认。如果实在不知道该找谁确认，那就把这个责任交给你的直属领导。</p>
<h4 id="如何获得有效的性能需求：">如何获得有效的性能需求：</h4>
<p>1、 客户方提出<br>　　这是最理想的一种方式，通常电信、金融、保险、证券以及一些其他运营商级系统的客户——特别是国外的客户都会提出比较明确的性能需求。<br>　　<br>2、根据历史数据来分析<br>　　根据客户以往的业务情况来分析客户的业务量以及每年、每月、每周、每天的峰值业务量。如果客户有旧的系统，可以根据已有系统的访问日志，数据库记录，业务报表来分析。要特别注意的是，不同行业、不同应用、不同的业务是有各自的特点的。例如，购物网站在平时的负载主要集中在晚上，但是节假日时访问量和交易量会是平时的数倍；而地铁的售票系统面临的高峰除了周末，还有周一到周五的一早一晚上下班时间。<br>　　<br>3、参考历史项目的数据<br>　　如果该产品已有其他客户使用，并且规模类似的，可以参考其他客户的需求。例如在线购物网站，或者超市管理系统，各行业的进销存系统。<br>　　<br>4、参考其他同行类似项目的数据<br>　　如果本企业没有做过类似的项目，那么可以参考其他同行企业的公布出来的数据——通常在企业公布的新闻或者成功解决方案中会提到，包括系统容量，系统所能承受的负载以及系统响应能力等。<br>　　<br>5、参考其他类似行业应用的数据<br>　　如果无法找打其他同行的数据，也可以参考类似的应用的需求。例如做IPTV或者DVB计费系统的测试，可以参考电信计费系统的需求——虽然不能完全照搬数据，但是可以通过其他行业成熟的需求来了解需要测试的项目有哪些，应该考虑到的情况有哪些种。<br>　　<br>6、参考新闻或其他资料中的数据<br>　　最后的一招，特别是对于一些当前比较引人关注的行业，涉及到所谓的“政绩”的行业，通常可以通过各种新闻媒体找到一些可供参考的数据，但是需要耐心的寻找。例如我们在IPTV和DVB系统的测试中，可以根据新闻中公布的各省、各市，以及国外各大运营商的用户发展情况和用户使用习惯来估算系统容量和系统各个模块的并发量。</p>
<h4 id="性能测试点选取：">性能测试点选取：</h4>
<ul>
<li>发生频率非常高的（例如：某邮箱核心业务系统中的登录、收发邮件等业务，它们在每天的业务总量中占到90%以上）</li>
<li>关键程度非常高的（产品经理认为绝对不能出现问题的，如登录等）</li>
<li>资源占用非常严重的（导致磁盘I/O非常大的，例如某个业务进行结果提交时需要向数十个表存取数据，或者一个查询提交请求时会检索出大量的数据记录）</li>
</ul>
<h4 id="需求获取的小例子：">需求获取的小例子：</h4>
<p>　　去年全年处理“WEB登录”交易约 100 万笔，考虑到 3 年后交易量递增到每年 200万笔。假设每年交易量集中在 8 个月，每个月 20 个工作日，每个工作日 8 小时，试采用 80～20 原理估算系统服务器高峰期“WEB登录”的交易吞吐量应达到怎样的一个处理能力　<br>200万/8=25万/月<br>25万/20=1.25万/日<br>1.25万<em>80%/(8</em>20%*3600)=1.74TPS</p>
<h4 id="关于性能需求的一点补充：">关于性能需求的一点补充：</h4>
<p>　　在软件开发过程中，需求管理要远远简单于需求开发，CMMI中也体现了这一点，并且实际工作中也常常需要我们为客户来开发这部分的性能需求。考虑一下，如何根据客户的实际使用或粗线条的性能要求来开发满足客户需要的性能需求来。就拿例子来说，客户告诉我们“系统总容量达到日委托6000万笔，成交9000万笔；系统处理速度每秒7300笔，峰值处理能力达到每秒10000笔”，那我们将客户的这个要求管理起来并实现了这一点，这叫需求管理；而如果我们根据以下2个假设：<br>　　<br>1、采用2/8比例，即80%的业务在20%的峰值时间内完成，20%的业务在80%的非峰值时间内完成，那么我们可以得到峰值处理业务量1.5亿的80%为1.2亿，非峰值处理业务量1.5亿的20%为3000万；<br>2、1天系统运行时间为20小时，另4小时为非营业的后台处理时间，那么峰值时间20小时的20%为4小时，非峰值时间20小时的80%为16小时。</p>
<p>我们可以计算到：</p>
<p>3、 平均峰值处理速度1.2亿/4*3600秒接近9000个/秒；<br>4、平均非峰值处理速度3000万/16*3600秒约500个/秒；</p>
<p>　　考虑到特殊情况的发生，我们建议实际峰值处理速度要能达到理论计算的平均峰值处理速度的1.5到2倍，所以最终确定下来的建议峰值处理速度为9000个/ 秒*2=18000个/秒。我们拿这个结果向客户说明，告诉他们原来的需求很可能在发生特殊情况时无法有效处理，客户最终接受了我们的说法并调整了他们的需求。<br>　　<br>　　这叫需求开发，通过分析修正了客户的不合理需求，满足了他们最根本的需要”系统总容量达到日委托6000万笔，成交9000万笔”，而处理速度是他们根据自己的需要估算出来的，并不准确。<br>　　<strong>所谓需求开发，也就是根绝客户的核心需求，为客户设计完整的需求体系，甚至根据客户的业务发展需要，为客户设计核心需求和需求体系。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下内容大多来自jackei的博客，只是整理了下，增加了自己的理解。</p>
<h4 id="一个实际的例子：">一个实际的例子：</h4>
<p> 某证券行业系统中某个业务的实际需求<br>1、系统总容量达到日委托6000万笔，成交9000万笔<br>2、 系统处理速度每]]>
    </summary>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软测" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能测试之主要概念]]></title>
    <link href="http://yoursite.com/2014/12/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2014/12/25/性能测试之主要概念/</id>
    <published>2014-12-25T06:41:07.000Z</published>
    <updated>2014-12-25T06:44:04.000Z</updated>
    <content type="html"><![CDATA[<h4 id="什么是软件性能？">什么是软件性能？</h4>
<p><code>交互式系统</code>：以用户感受到的响应时间来描述系统的性能<br><code>非交互式系统</code>（银行业务处理）：响应时间只系统对事件产生的响应所需要的时间</p>
<h4 id="如何评价性能的好坏：">如何评价性能的好坏：</h4>
<p>　　用户视角：对于用户，最终使用者而言评价系统的性能好坏只有一个字——“快“。最终用户并不需要关心系统当前的状态——即使系统这时正在处理着成千上万的请求，对于用户来说，由他所发出的这个请求是他唯一需要关心的，系统对用户请求的响应速度决定了用户对系统性能的评价。简单点就是，用户单击一个按钮，发出一条指令或是在web页面上单击一个连接考试，到应用系统把本次操作的结果以用户能察觉的方式展示出来的过程所消耗的时间就是用户对软件性能的直观印象。</p>
<p>　　系统的运营商和开发商：期望的是能够让尽可能多的用户在任意时刻都拥有最好的体验，这就要确保系统能够在同一时间内处理更多的用户请求。系统的负载（并发用户数）与吞吐量（每秒事务数）、响应时间以及资源利用率（包括软硬件资源）之间存在着一个“此消彼长”的关系。因此，从系统的运营商和开发商的角度来看，所谓的“性能”是一个整体的概念，<strong>是系统的负载与吞吐量、可接受的响应时间以及资源利用率之间的平衡。</strong></p>
<p><strong>好的系统意味着更大的最佳并发用户数和最大并发用户数。</strong></p>
<p>　　另外，从系统的视角来看，所需要关注的还包括三个与“性能”有关的属性：<code>可靠性（Reliability）</code>，<code>可伸缩性（Scalability）</code>和<code>可恢复性（Recoverability）</code>　</p>
<h4 id="响应时间：">响应时间：</h4>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/xysj.jpg" alt="响应时间"><br>图中是一个请求的响应时间的组成，包括</p>
<p>C1：用户请求发出前在客户端需要完成的预处理所需要的时间；</p>
<p>C2：客户端收到服务器返回的响应后，对数据进行处理并呈现所需要的时间；</p>
<p>A1：Web/App Server 对请求进行处理所需要的时间；</p>
<p>A2：DB Server 对请求进行处理所需的时间；</p>
<p>A3：Web/App Server 对 DB Server 返回的结果进行处理所需的时间；</p>
<p>N1：请求由客户端发出并达到Web/App Server 所需要的时间；</p>
<p>N2：如果需要进行数据库相关的操作，由Web/App Server 将请求发送至DB Server 所需要的时间；</p>
<p>N3：DB Server 完成处理并将结果返回Web/App Server 所需的时间；</p>
<p>N4：Web/App Server 完成处理并将结果返回给客户端所需的时间；</p>
<p>　从用户的角度来看，响应时间＝(C1+C2)+(A1+A2+A3)+(N1+N2+N3+N4)；但是从系统的角度来看，响应时间只包括(A1+A2+A3)+(N1+N2+N3+N4)。理解响应时间的组成可以帮助我们通过对响应时间的分析来更好的识别和定位系统的性能瓶颈。<br>　　从用户的角度看，所体会到的响应时间有主观和客观之分，客观来说就是上面提到的从用户操作开始到所有数据返回完成的整个耗时，主观上说如果采用一种优化的数据呈现策略，当少部分数据返回之后就立马将数据呈现在用户面前，则用户感受到的响应时间就会远远小于实际的实物响应时间。<br>　　对于一个web应用来说，响应时间的标准是2/5/10秒，而对于一个OA系统，每次可能只使用一次该系统，当点击提交时就算系统在20分钟后才响应，用户仍然不会觉得不能接受。所以合理的响应时间取决于<code>实际的用户需求</code>。</p>
<h4 id="吞吐量：">吞吐量：</h4>
<p>单位时间内系统处理的客户请求的数量。在web系统中主要以请求数（单击数）/秒、页面数/秒来体现。</p>
<ol>
<li><p>用户协助设计性能测试场景，以及衡量性能测试场景是否达到了预期的设计目标：在设计性能测试场景时，吞吐量可被用户协助设计性能测试场景，根据估算的吞吐量数据，可以对应到测试场景的事务发生频率，事务发生次数等；另外，在测试完成后，根据实际的吞吐量可以衡量测试是否达到了预期的目标。</p>
</li>
<li><p>用于协助分析性能瓶颈：吞吐量的限制是性能瓶颈的一种重要表现形式，因此，有针对性地对吞吐量设计测试，可以协助尽快定位到性能冰晶所在位置。</p>
</li>
</ol>
<p><strong>并发用户数 ≠ 每秒请求数</strong>：</p>
<p>　　简单说，当你在性能测试工具或者脚本中设置了100并发用户数后，并不能期望着一定会有每秒100个请求发给服务器。事实上，对于一个虚拟用户来说，每秒发出多少请求只跟服务器返回响应的速度有关。如果虚拟用户在0.5秒内就收到了响应，那么它会立即发出第二个请求；而如果要一直等待3秒才能得到响应，它将会一直等到收到响应后才发出第二个请求。也就是说，并发用户数的设置只是保证服务器在任一时刻都有100个请求需要处理，而并不一定是保证每秒中发送100个请求给服务器。<br>　　所以，只有当响应时间恰好是1秒时，并发用户数才会等于每秒请求数；否则，每秒请求数可能大于并发用户数或小于并发用户数。<br>　　<strong>并发用户数取决于具体的业务场景，它体现的时服务器端承受的最大并发访问数。</strong></p>
<h4 id="举个例子：">举个例子：</h4>
<p>　　一个系统有2000用户（系统用户数），最高峰时有500人在线（同时在线人数），那么系统的并发用户数呢？<br>　　500是整个系统使用时最大的业务并发用户数，并不表示服务器实际承受的压力，这与具体的用户访问模式有关。例如这500人中，有40%在看公告，20%在填写表格（表格只有在点击提交时才会对服务器产生负担），20%在发呆，20%在切换页面，这种情况下只有20%的用户真正的对服务器构成了压力。<br>　　<br><strong>性能计数器</strong>：<br>描述服务器或操作系统性能的一些数据指标，在performance test中发挥这监控和分析的关键作用。</p>
<p><strong>性能测试包括</strong>：<br>验收性能测试（acceptance performance testing）<br>负载测试（load testing）<br>压力测试（stress testing）<br>配置测试（configuration testing）<br>并发测试（concurrency testing）<br>可靠性测试（reliability testing）<br>失败恢复测试（failure testing）</p>
<h4 id="对性能测试的一点理解：">对性能测试的一点理解：</h4>
<p>　　性能测试重要的一点在于对需求的理解，如果没有正确的理解需求，而充忙的去搭建环境，配置信息，最后得到的会是不正确的测试结果。而往往一些用户或者客户并不十分明确对性能的要求，他们只会给出一个宽泛的表示，那么这时就需要我们自己去寻找需求，从要求中提炼出准确的需求。明确了需求之后才好进行下一部的操作。<br>　　当然在这之前对于性能测试的主要内容需要掌握，性能的知识点也不是很多，重要的是在实践中的领悟，性能测试并不是功能测试，它是从一个系统，站在更大的立场上去宏观的把握产品，去对系统进行测试，但是并不代表在功能测试的同时不能进行性能测试。性能的要求也会更高，需要了解的知识会更多，对系统的架构要有一定的熟悉度。所以想要真正做好性能测试，任重而道远。加油！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="什么是软件性能？">什么是软件性能？</h4>
<p><code>交互式系统</code>：以用户感受到的响应时间来描述系统的性能<br><code>非交互式系统</code>（银行业务处理）：响应时间只系统对事件产生的响应所需要的时间</p>
<h4 id="如]]>
    </summary>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软测" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能测试（一）---理发店模型]]></title>
    <link href="http://yoursite.com/2014/12/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89---%E7%90%86%E5%8F%91%E5%BA%97%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2014/12/25/性能测试（一）---理发店模型/</id>
    <published>2014-12-25T02:24:38.000Z</published>
    <updated>2014-12-25T05:06:31.000Z</updated>
    <content type="html"><![CDATA[<p>　　这个理发店模型是在网络上看来的，之后对性能测试有了一定的了解之后，感觉写的很好，现在结合自己的一点想法，将理发店模型完整的记录下来。文中很多是来自jackei和虫师的博客，估计这两个博客大家都不陌生。</p>
<h3 id="理发店模型">理发店模型</h3>
<p>　　理发店模型，可以很好的用来理解很多性能测试的概念和理论，以及一些测试中遇到的问题，将本来抽象的概念具体化，联合实际，可能很多地方没有很好的切合，但是这个模型确实帮助我理解了很多点。</p>
<p>在我们的这个理发店中，我们事先做了如下的假设：</p>
<ol>
<li><p>理发店共有3名理发师；</p>
</li>
<li><p>每位理发师剪一个发的时间都是1小时；</p>
</li>
<li><p>我们顾客们都是很有时间观念的人而且非常挑剔，他们对于每次光顾理发店时所能容忍的等待时间+剪发时间是3小时，而且等待时间越长，顾客的满意度越低。如果3个小时还不能剪完头发，顾客会立马生气的走人。</p>
</li>
</ol>
<p>通过上面的假设可以想象出下面的这些场景：</p>
<ol>
<li><p>当理发店内只有1位顾客时，只需要有1名理发师为他提供服务，其他两名理发师可能继续等着，也可能会帮忙打打杂。1小时后，这位顾客剪完头发出门走了。那么在这1个小时里，整个理发店只服务了1位顾客，这位顾客花费在这次剪发的时间是1小时；</p>
</li>
<li><p>当理发店内同时有两位顾客时，就会同时有两名理发师在为顾客服务，另外1位发呆或者打杂帮忙。仍然是1小时后，两位顾客剪完头发出门。在这1小时里，理发店服务了两位顾客，这两位顾客花费在剪发的时间均为1小时；</p>
</li>
<li><p>很容易理解，当理发店内同时有三位顾客时，理发店可以在1小时内同时服务三位顾客，每位顾客花费在这次剪发的时间仍然是均为1小时。</p>
</li>
</ol>
<p>从上面几个场景中我们可以发现，在理发店同时服务的顾客数量从１位增加到3位的过程中，随着顾客数量的增多，理发店的整体工作效率在提高，但是每位顾客在理发店内所呆的时间并未延长。当然，我们可以假设当只有1位顾客和2位顾客时，空闲的理发师可以帮忙打杂，使得其他理发师的工作效率提高，并使每位顾客的剪发时间小于1小时。不过即使根据这个假设，虽然随着顾客数量的增多，每位顾客的服务时间有所延长，但是这个时间始终还被控制在顾客可接受的范围之内，并且顾客是不需要等待的。</p>
<p>　　不过随着理发店的生意越来越好，顾客也越来越多，新的场景出现了。假设有一次顾客A、B、C刚进理发店准备剪发，外面一推门又进来了顾客D、E、F。因为A、B、C三位顾客先到，所以D、E、F三位只好坐在长板凳上等着。1小时后，A、B、C三位剪完头发走了，他们每个人这次剪发所花费的时间均为1小时。可是D、E、F三位就没有这么好运，因为他们要先等A、B、C三位剪完才能剪，所以他们每个人这次剪发所花费的时间均为2小时——包括等待1小时和剪发1小时。<br>　　<br>　　通过上面这个场景我们可以发现，对于理发店来说，都是每小时服务三位顾客——第1个小时是A、B、C，第二个小时是D、E、F；但是对于顾客D、E、F来说，“响应时间”延长了。如果你可以理解上面的这些场景，就可以继续往下看了。<br>　　<br>　　在新的场景中，我们假设这次理发店里一次来了9位顾客，根据我们上面的场景，相信你不难推断，这9位顾客中有3位的“响应时间”为1小时，有3位的“响应时间”为2小时（等待1小时+剪发1小时），还有3位的“响应时间”为3小时（等待2小时+剪发1小时）——已经到达用户所能忍受的极限。假如在把这个场景中的顾客数量改为10，那么我们已经可以断定，一定会有1位顾客因为“响应时间”过长而无法忍受，最终离开理发店走了。<br>　　<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/blogxn1.jpg" alt="性能"></p>
<p>　　这张图中展示的是1个标准的软件性能模型。在图中有三条曲线，分别表示<strong>资源的利用情况</strong>（Utilization，包括硬件资源和软件资源）、<strong>吞吐量</strong>（Throughput，这里是指每秒事务数）以及<strong>响应时间</strong>（Response Time）。图中坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。在这张图中我们可以看到，最开始，随着并发用户数的增长，资源占用率和吞吐量会相应的增长，但是响应时间的变化不大；不过当并发用户数增长到一定程度后，资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长。如果并发用户数继续增长，你会发现软硬件资源占用继续维持在饱和状态，但是吞吐量开始下降，响应时间明显的超出了用户可接受的范围，并且最终导致用户放弃了这次请求甚至离开。</p>
<p>　　根据这种性能表现，图中划分了三个区域，分别是Light Load（较轻的压力）、Heavy Load（较重的压力）和Buckle Zone（用户无法忍受并放弃请求）。在Light Load和Heavy Load 两个区域交界处的并发用户数，我们称为“最佳并发用户数（The Optimum Number of Concurrent Users）”，而Heavy Load和Buckle Zone两个区域交界处的并发用户数则称为“最大并发用户数（The Maximum Number of Concurrent Users）”。</p>
<p>　　当系统的负载等于最佳并发用户数时，系统的整体效率最高，没有资源被浪费，用户也不需要等待；当系统负载处于最佳并发用户数和最大并发用户数之间时，系统可以继续工作，但是用户的等待时间延长，满意度开始降低，并且如果负载一直持续，将最终会导致有些用户无法忍受而放弃；而当系统负载大于最大并发用户数时，将注定会导致某些用户无法忍受超长的响应时间而放弃。</p>
<h3 id="理解：">理解：</h3>
<p><code>最佳并发用户数</code>：每小时3位顾客，即理发店收入最多（理发师傅没有休息时间，一直在理发），顾客满意度最高（顾客随时到随时理，无需要等待）。</p>
<p><code>最大并发用户数</code>：每小时9位顾客，理发店的最大承受状态，理发店收入最多（理发师傅没有休息时间，一直在理发），顾客的最大忍耐度（来的顾客等待+理发需要等上三个小时）。当每小时都有9个顾客到来时，前几个小时来的顾客还可以忍受，但是随着等待的顾客人数越来越多，等待时间越来越长，最终还是会有顾客无法忍受而离开。同时，随着理发店里顾客人数的增多和理发师工作时间的延长，理发师会逐渐产生疲劳，还要多花一些时间来清理环境和维持秩序，这些因素将最终导致理发师的工作效率随着顾客人数的增多和工作的延长而逐渐的下降，到最后可能要1.5小时甚至2个小时才能剪完1个发了。如果一开始就有10个顾客到来，则注定有1位顾客剪不到头发了。当然，理发店还会不断的来新的顾客，不断有等了三小时而没有得到服务的顾客离开，但对于理发店而言，他们在一个时间点上，能服务的最大用户数是9（3位正在接受服务、3位已经等待一小时，3位已经等待两小时）。</p>
<p>　　对于一个确定的被测系统来说，在某个具体的软硬件环境下，它的“最佳并发用户数”和“最大并发用户数”都是客观存在。以“最佳并发用户数”为例，假如一个系统的最佳并发用户数是50，那么一旦并发量超过这个值，系统的吞吐量和响应时间必然会 “此消彼长”；如果系统负载长期大于这个数，必然会导致用户的满意度降低并最终达到一种无法忍受的地步。所以我们应该 保证最佳并发用户数要大于系统的平均负载。要补充的一点是，当我们需要对一个系统长时间施加压力——例如连续加压3-5天，来验证系统的可靠性或者说稳定性时，我们所使用的并发用户数应该等于或小于“最佳并发用户数”</p>
<p> 对于最大并发用户数的识别，需要考虑和鉴别一下以下两种情况：</p>
<blockquote>
<ol>
<li><p>在理发店里很大，可以容纳很多位顾客（大于9），总有一部分在这里等待了三小时而没有得到服务离开，不要把等待了三小时而没有得到服务的顾客纳入最大用户数里。也就是说3小时前理发店内的顾客数量才是我们要找的“最大并发用户数”。而且，这位顾客的离开只是一个开始，可能有会更多的顾客随后也因为无法忍受超长的等待时间而离开；</p>
</li>
<li><p>在响应时间还没有到达用户可忍受的最大限度前，有可能已经出现了用户请求的失败。假如理发店很小，最多只能容纳六位顾客，当第七个顾客来时，虽然，我们知道他只需要等待两小时就可得到服务（这个时间是他可以接受的等待时间），但由于理发店容量有量，这第七个顾客只有改天再来了。</p>
</li>
</ol>
</blockquote>
<p><strong>对于一个系统来说，我们应该确保系统的最大并发用户数要大于系统需要承受的峰值负载。</strong></p>
<h3 id="理发店模型的进一步扩展">理发店模型的进一步扩展</h3>
<blockquote>
<p>扩展场景1：有些顾客已经是理发店的老顾客，他们和理发师已经非常熟悉，理发师可以不用花费太多时间沟通就知道这位顾客的想法。并且理发师对这位顾客的脑袋的形状也很熟悉，所以可以更快的完成一次理发的工作。</p>
</blockquote>
<hr>
<blockquote>
<p>扩展场景2：理发店并不是只有剪发一种业务，还提供了烫发染发之类的业务，那么当顾客提出新的要求时，理发师服务一位顾客的时间可能会超过标准的1小时。而且这时如果要计算每位顾客的等待时间就变得复杂了很多，有些顾客的排队时间会比原来预计的延长，并最终导致他们因为无法忍受而离开。</p>
</blockquote>
<hr>
<blockquote>
<p>扩展场景3：随着烫发和染发业务的增加，理发师们决定分工，两位专门剪发，一位专门负责烫发和染发。</p>
</blockquote>
<hr>
<blockquote>
<p>扩展场景4：理发店的生意越来越好，理发师的数量和理发店的门面已经无法满足顾客的要求，于是理发店的老板决定在旁边再开一家店，并招聘一些工作能力更强的理发师。</p>
</blockquote>
<hr>
<blockquote>
<p>扩展场景5：理发店的生意变得极为火爆了，两家店都无法满足顾客数量增长的需求，并且有些顾客开始反映到理发店的路途太远，到了以后又因为烫发和染发的人太多而等太久。可是理发店的老板也明白烫发和染发的收入要远远高于剪发阿，于是他脑筋一转，决定继续改变策略，在附近的几个大型小区租用小的铺面开设分店，专职剪发业务；再在市区的繁华路段开设旗舰店，专门为烫发、染发的顾客，以及VIP顾客服务。并增设800电话，当顾客想要剪发时，可以拨打这个电话，并由服务人员根据顾客的居住地点，将其指引到距离最近的一家分店去。</p>
</blockquote>
<h4 id="对模型的理解：">对模型的理解：</h4>
<p>　　理发店就相当于我们的系统，顾客就我们向服务器所发送的请求，最佳用户数和最大用户数是我们衡量一个系统的处理能力的一种方法。理发师们的分工就是在对服务器处理不同请求的分工，扩展的场景就是对b/s的系统的一个缩影，随着生意越来越好，网站流量越来越多，系统的整体架构需要发生相应的改变，一满足用户的需求。在遇到难以理解的术语时，时常想想这个理发店模型就可以很好的理解性能测试。一个CPU相当于一个理发师，一个服务器又有几个CPU，当业务扩展的时候，需要增加CPU，再增长的时候需要增加服务器；业务达到一定的水准的时候分成专门的服务器提供具体的服务；电话相当于一个域名解析服务器，根据不同的提交服务转到不同的服务器。 针对不同的用户的性能需求可以将功能分解起来测试。 </p>
<p>　　微观上来说，在单CPU的情况下，并不存在真正意义上的并发响应（并发请求是可能的），那么3个理发师同时工作如何解释上述问题？操作系统实际上是分时处理的系统，CPU 时间被以时间片为单位轮流分配给不同的进程——但是操作系统的这种做法本身也是为了让每个进程都感觉到自己在独占 CPU。从这个角度来说，如果我们的理发师可以以极为快速（例如10ms一个间隔）的速度在三位顾客之间切换，而且这个切换是我们根本无法发现或者识别的，我们是否可以认为相当于有三位理发师同时在为顾客服务呢？ </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这个理发店模型是在网络上看来的，之后对性能测试有了一定的了解之后，感觉写的很好，现在结合自己的一点想法，将理发店模型完整的记录下来。文中很多是来自jackei和虫师的博客，估计这两个博客大家都不陌生。</p>
<h3 id="理发店模型">理发店模型</h3>
<p>　]]>
    </summary>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软测" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E6%B5%8B/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么想做测试之我的测试开端]]></title>
    <link href="http://yoursite.com/2014/10/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%83%B3%E5%81%9A%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%BC%80%E7%AB%AF/"/>
    <id>http://yoursite.com/2014/10/26/为什么想做测试之我的测试开端/</id>
    <published>2014-10-26T02:06:00.000Z</published>
    <updated>2014-12-25T02:03:17.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;这个问题曾经纠结了我很久，开发还是测试？最终出于自己内心的渴望与求知决定我要从事软测这个行业。</p>
<p>&emsp;&emsp;从本科我就开始接触主流的编程语言，也一直以为自己以后会从事软件设计这份工作，直到大三找实习的时候接触到软测，加上身边很多人都说女孩子适合做软测，不累，当初就抱着这么单纯的想法，懵懵懂懂的就想往测试这个方向走了，算是在心里种下了一颗种子。当时也是为了增加项目经历和拥有开发经验（当时觉得有开发经历能找到好工作）就选择了现在所在的实验室，进入实验室后才发现这个环境和我所想的不一样，不到半年，我就对自己的前途感到迷茫了，看不清楚路在哪里。实验室的研究方向变了，周围有很多人都鄙视做软测的，都说测试没有开发的工资高，测试是很low的一个工作，本科生大专生才做的，根本没有技术含量，在一些公司根本不重要，各种不好的话语动摇了我的决心，于是之前种下的种子没有浇水施肥，还忍受着虫害，时间一长，渐渐地快死了。</p>
<p>&emsp;&emsp;就在这纠结的期间，实验室师姐拉了我一把，师姐是想做前端的，跟我介绍了前端的各种技术，于是在我不确定的情况下，我跟着师姐断断续续学习了将近2个月的前端知识，从一点基础都没有的情况下，学到了：</p>
<ul>
<li>了解了什么是前端，前端开发的一整套体系</li>
<li>了解互联网的消息</li>
<li>知道怎么订阅优秀人才的博客</li>
<li>学会怎么获取和学习有用的信息</li>
</ul>
<p>这个过程反而让我对网页性能起了想法：</p>
<ul>
<li>是什么技术让前端写出来的页面可以满足客户的无限次刷屏？</li>
<li>是什么保证了系统不会再大量使用人员的情况下崩溃？就像双十一那样</li>
</ul>
<ul>
<li>淘宝是如何做到在双十一那天，满足几百万笔交易的？</li>
<li>如何在11月11号凌晨的时候保证系统不崩溃的？</li>
<li>想到了12306网站，为什么铁道部的购票系统还是会在春节购票期间崩溃，还是会在抢票的时候刷不进去，让很多人干瞪着屏幕，就是没法点击购买？</li>
<li>为什么我们学校的管理系统，每到学生选课的时候就崩溃（这是学校的十大吐槽点）</li>
</ul>
<hr>
<p>&emsp;&emsp;按每年的招生情况来说最多也就8000多人进行选课，排除一半（因为体育课是两个学期上的）加上部分不重视选课的学生，那么最多就是2000左右的人会有可能同时登入系统，但却不一定在同一个时段，偌大一个学校的管理系统会承受不住2000人同时登入，进入让系统崩溃达一天？研发出来的系统是如何保证一上线后就可以满足高并发量的要求的，就像淘宝双十一？如何确定开发出来的系统可以满足多少人同时进行某一项操作的？这些让我很迷惑。我知道这些问题是属于测试技术范畴的，只有测试人员可以告诉我。于是我就在<code>测试和开发</code>之间两难了。</p>
<p>&emsp;&emsp;就在我不知道如何抉择的时候？小微金服来了。2014年4月20日，阿里旗下的<code>小微金服</code>带着他的测试技术团队，在我们学校开了一堂<code>测试技术大讲堂</code>。一天6个人分享了在测试不同领域的技术和感受，从<strong>测试流程</strong>、<strong>测试设计和测试分析</strong>、<strong>性能测试</strong>、<strong>自动化测试</strong>到<strong>测试架构平台搭建</strong>，让我豁然开朗，让我彻底明白之前我对测试的狭隘认识，是多么的愚蠢，多么的单纯。他们带我见识了真正的测试领域是怎么样的，真正的测试工作是怎样的，让我看到测试的魅力所在。测试是一个技术岗位，而不是简简单单的点击几下鼠标就行的。这一天坚定了我要做软测的决心，让我摇摆不定的心终于有了航行的方向。更加确定自己的目标，我要进阿里，我要进小微金服团队。</p>
<p>&emsp;&emsp;于是我找了很多书看，关注了一些有名的技术博客，留意测试行业的发展，结合自身的兴趣，对互联网web的发展和手机移动端发展的关注，从事web测试、或者移动端测试（app测试）方向，想让我手下的产品能做到让用户不卸载，能做到零体验bug，能承受大量用户对某一业务的同时操作和请求，能让产品更好的服务于用户。<em>所有的这些需要我有扎实的测试知识和理念思想作为基础。</em></p>
<p>&emsp;&emsp;测试人员是第一批接触产品的人，是代表用户使用和反馈产品问题的人，一个产品若最后通不过测试这一关是无法上线的，可以说测试人员握有生杀大权，相应的<strong>身上的责任就很重，给予的成就感于会很强，而我喜欢这样的感觉，开发创造了世界，而我们将拯救世界，让产品要么不上线，要么就永久的在线上获得用户的青睐，而不是短暂的一闪而过，</strong>各种问题导致用户卸载。</p>
<p>&emsp;&emsp;<strong>当接触开发越多的时候，会对测试的重要性有更深的体会，熟知开发流程，知道bug最有可能出现在哪里？分析bug产生因素时有很清晰的流程，可以很好的和开发交流，可以结合测试的需求快速的开发适合的测试工具，可以实现自动化测试。</strong></p>
<p>&emsp;&emsp;当你交付给客户的产品出现性能问题，出现功能需求无响应问题，出现质量问题的时候，你不得不重新返工，不得不遭受用户的质疑，造成用户的流失，公司的损失巨大。<strong>可以用金钱弥补的损失就不算是大损失，但让用户体验差，失去用户，失去用户的信任才是最大的损失，一旦失去用户将很难在将来把用户召集回来。</strong></p>
<p><strong>这些是我对测试的一点浅浅的理解，有不对的或理解错误的望各位指教。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;&emsp;这个问题曾经纠结了我很久，开发还是测试？最终出于自己内心的渴望与求知决定我要从事软测这个行业。</p>
<p>&emsp;&emsp;从本科我就开始接触主流的编程语言，也一直以为自己以后会从事软件设计这份工作，直到大三找实习的时候接触到软测，加上身边]]>
    </summary>
    
      <category term="测试杂感" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95%E6%9D%82%E6%84%9F/"/>
    
      <category term="心路历程" scheme="http://yoursite.com/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="杂感" scheme="http://yoursite.com/categories/%E6%9D%82%E6%84%9F/"/>
    
      <category term="测试" scheme="http://yoursite.com/categories/%E6%9D%82%E6%84%9F/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[opencv函数系列---漫水填充floodfill]]></title>
    <link href="http://yoursite.com/2014/09/16/opencv%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97-fillfood/"/>
    <id>http://yoursite.com/2014/09/16/opencv函数系列-fillfood/</id>
    <published>2014-09-16T13:55:27.000Z</published>
    <updated>2014-09-16T13:57:22.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、floodFill思想">一、floodFill思想</h3>
<p>　　所谓漫水填充，简单来说，就是自动选中了和种子点相连的区域，接着将该区域替换成指定的颜色，这是个非常有用的功能,经常用来标记或者分离图像的一部分进行处理或分析.漫水填充也可以用来从输入图像获取掩码区域,掩码会加速处理过程,或者只处理掩码指定的像素点。操作结果总是某个连续的区域。当邻近像素点位于给定的范围（从lodiff到updiff）内或在原始seedPoint像素值范围内是，floodFill将会为这个点涂上颜色。以此填充算法为基础，类似photoshop的魔术棒选择工具就很容易实现了。<br>　　漫水填充（FloodFill）是查找和种子点联通的颜色相同的点，魔术棒选择工具则是查找和种子点联通的颜色相近的点，将和初始种子像素颜色相近的点压进栈作为新种子。<br>　　泛红填充实现最常见有四邻域像素填充法，八邻域像素填充法，基于扫描线的像素填充方法。根据实现又可以分为递归与非递归（基于栈）。</p>
<h3 id="二、函数介绍">二、函数介绍</h3>
<p>　　</p>
<pre><code>floodFill ( InputOutputArray image,   <span class="comment">//输入/输出1通道或3通道，8位或浮点图像，具体参数由之后的参数具体指明InputOutputArray mask,     </span>
     Point seedPoint,                <span class="comment">//漫水填充算法的起始点</span>
     Scalar newVal,                   <span class="comment">//像素点被染色的值，即在重绘区域像素的新值</span>
     Scalar loDiff=Scalar(), 
     Scalar upDiff=Scalar(), 
     CvConnectedComp*  comp = <span class="keyword">NULL</span>
     <span class="keyword">int</span> flags=<span class="number">4</span> )
</code></pre><p>　　mask：表示操作掩模,（控制被填充的区域）。它应该为单通道、8位、长和宽上都比输入图像 image 大2个像素点的图像（是内部运算简单快速）。floodFill需要使用以及更新掩膜。需要注意的是，漫水填充不会填充掩膜mask的非零像素区域。例如，一个边缘检测算子的输出可以用来作为掩膜，以防止填充到边缘。同样的，也可以在多次的函数调用中使用同一个掩膜，以保证填充的区域不会重叠。另外需要注意的是，掩膜mask会比需填充的图像大，所以mask中与输入图像(x,y)像素点相对应的点的坐标为(x+1,y+1)。<br>　　<br>　　lodiff、updiff：表示当前观察像素值与其部件邻域像素值或者待加入该部件的种子像素之间的亮度或颜色之负差（lower brightness/color difference）或正差的最大值。 如果一个像素点的值不低于被染色的相邻点减去lodiff且不高于其加上updiff，那么该像素点就会被染色。如果flags参数包含FLOODFILL_FIXED_RANGE 这时每个像素点都将于种子点而不是相邻点比较。可以理解成阈值范围，在这个范围里的像素都会被染色。<br>　　<br>　　flags：低8位（第0~7位）用于控制算法的连通性，可取4 (4为缺省值) 或者 8。如果设为4，表示填充算法只考虑当前像素水平方向和垂直方向的相邻点；如果设为 8，除上述相邻点外，还会包含对角线方向的相邻点。高8位部分（16~23位）可以为0 或者如下两种选项标识符的组合：<br>　　（1） FLOODFILL_FIXED_RANGE－如果设置为这个标识符的话，就会考虑当前像素与种子像素之间的差，否则就考虑当前像素与其相邻像素的差。也就是说，这个范围是浮动的。<br>　　（2）FLOODFILL_MASK_ONLY－如果设置为这个标识符的话，函数不会去填充改变原始图像 (也就是忽略第三个参数newVal),而是去填充掩模图像（mask）。中间8位部分，上面关于高八位FLOODFILL_MASK_ONLY标识符中已经说的很明显，需要输入符合要求的掩码。Floodfill的flags参数的中间八位的值就是用于指定填充掩码图像的值的。但如果flags中间八位的值为0，则掩码会用1来填充。<br>　　而所有flags可以用or操作符连接起来，即“|”。例如，如果想用8邻域填充，并填充固定像素值范围，填充掩码而不是填充源图像，以及设填充值为47，那么输入的参数是这样：</p>
<pre><code><span class="attribute">flags</span>=<span class="string">8 | FLOODFILL_MASK_ONLY | FLOODFILL_FIXED_RANGE | （47&lt;&lt;8）</span>
</code></pre><h3 id="三、函数演示">三、函数演示</h3>
<p>待写ing……</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、floodFill思想">一、floodFill思想</h3>
<p>　　所谓漫水填充，简单来说，就是自动选中了和种子点相连的区域，接着将该区域替换成指定的颜色，这是个非常有用的功能,经常用来标记或者分离图像的一部分进行处理或分析.漫水填充也可以用来从输入图像]]>
    </summary>
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/opencv/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[时间管理--小强升职记]]></title>
    <link href="http://yoursite.com/2014/09/16/%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0/"/>
    <id>http://yoursite.com/2014/09/16/小强升职记/</id>
    <published>2014-09-16T13:42:41.000Z</published>
    <updated>2014-09-16T13:47:36.000Z</updated>
    <content type="html"><![CDATA[<p>　　书中已对话的形式，主管老付如何教会小强对自己时间进行管理，如何高效的完成工作，培养其成为主管。<br>　　在我们觉得时间很多的时候，他就偷偷的溜走了，时间对于每个人都是公平的。我们每天在忙忙碌碌的日子里过去，是否过得有意义，浑浑噩噩的日子真的是我们所要的吗？到底我自己追求的是什么？每天工作学习是为了什么？什么样的人生才有意义?我们需要站在一个更高的位置上审视自己。问问自己什么才是真正想要的。<br>　　<br>　　我们的时间总是在无意义的事情上面一点点的浪费掉。确实如此，以前总是每次开电脑的时候。登下QQ，看下新闻什么的，以为这样浪费不了多少时间，可是每次都没有忍住，还有点像滚雪球似的的越滚越长，结果一看时间已经10:00多了，过一会就要吃饭了，自然就没有心思学习了，或者每次时间很轻易的就被同学打断，被QQ消息打断，那么在要集中注意就很难，就是这样的时间黑洞将我们的时间吞噬掉。<br>　　<br>　　有时候也会有同时有很多事情向我袭来，很多时候就应该根据自己的价值观，给他们分出优先级，找出核心事件，及时解决这些问题。时间管理的方法有很多，四象限法则，时间投资法，衣柜整理法等，具体哪一种是适合你的，还是需要自己去摸索，去实践才知道什么是适合自己的。书里的时间资本法，对于时间价值的计算让我忽然醒来，原来我的时间就剩这么一点了，可是我想要的生活还没有实现。。<br>　　<img src="/images/zbjs2.png" alt="资本计算2"><br>    <img src="/images/zbjs.png" alt="资本计算"><br>　　很典型的，在今后工作的日子里，只有8年是在工作，有10年是在睡觉，其他时间是13年，有人曾统计过一个人活得72岁时对时间的消费情况：睡觉21年，工作14奶奶，个人卫生7年，吃饭6年，旅行6年，排队5年，学习4年，开会3年，打电话2年，找东西1年，其他3年。如果加上我们的年新来计算时间资本，那么很廉价。。</p>
<h3 id="目标">目标</h3>
<p>　　时间，是一个非常奇怪的东西，当你想挥霍它的时候，它会尽量的满足你，让你觉得怎么挥霍都用不完。但是当你想要珍惜它的时候，他又会i特别的吝啬，让你觉得时光飞逝，转眼已是尽头。<br>　　对于一个项目或是什么要有明确的目标，具体的下一步行动，一个行动清单。对人生有规划，有明确的目标是很好的，但如果沉迷在未来美好生活的幻想中，而不是执行它，只是做个梦想家，我们要将目标化为行动，做个建筑家，梦想的缔造者。<br>　　当然，目标也不是有了完美的计划就能达成的，我们需要方法避免失败。<br>　　1、找到最大的石头，就是要问问自己实现这个目标最大的石头（障碍）在哪里，如果最大的石头没有移除，你除去了99%的小石头也是没有用的。<br>　　2、有什么想法计划一定要写下来，白字黑子是最好的契约，写到了才可以做到，那么所有的想想就不再只是想想了，而是需要实现的东西了。<br>　　3、拒绝第一次失败，万事开头难，很多目标的夭折都是从第一次失败开始的。所以我们要重视第一次的是吧，摆正心态不让它产生连锁反应。我们有一种很可怕的适应性，不敢是对好习惯还是坏习惯的适应。失败了，我们更应该找出原因，为什么会失败？到底为什么成功？花时间思考这两个问题是非常重要的。</p>
<h3 id="习惯">习惯</h3>
<p>　　习惯是个很可怕的东西，对于长期做在电脑前的上班族，最重要的一点就是要养成健身的习惯，平时我们可能没有大把的时间可以去运动，为了身体的健康，每天坚持一个小时的锻炼。向着你要养成多习惯，每天去做一些你不愿意的事情，这样你就不会为那些真正需要你完成的责任而痛苦。</p>
<h3 id="思维导图">思维导图</h3>
<p><img src="/images/swdt.bmp" alt="思维导图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　书中已对话的形式，主管老付如何教会小强对自己时间进行管理，如何高效的完成工作，培养其成为主管。<br>　　在我们觉得时间很多的时候，他就偷偷的溜走了，时间对于每个人都是公平的。我们每天在忙忙碌碌的日子里过去，是否过得有意义，浑浑噩噩的日子真的是我们所要的吗？到底我自己追]]>
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试之美有感]]></title>
    <link href="http://yoursite.com/2014/09/16/%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%BE%8E%E6%9C%89%E6%84%9F/"/>
    <id>http://yoursite.com/2014/09/16/测试之美有感/</id>
    <published>2014-09-16T13:29:33.000Z</published>
    <updated>2014-12-24T12:55:54.000Z</updated>
    <content type="html"><![CDATA[<p>　　<strong>王小波说：这个世界上有两种人，一类人将有趣的事情做成无趣，一类人把无趣的事情做成有趣。</strong>软件测试原本是件很有趣的事情，可是网上有很多的人或者一些做测试的人很不幸将测试这件有趣的事做成了无趣的事情：觉得是日复一日的手工劳动，不断的和开发人员争执，等等……但其实不是这样的。测试是一个软件项目，公司成功的基石，是一种在成本、质量、效率、周期之间平衡的艺术。</p>
<h3 id="一、性能测试，协作是关键">一、性能测试，协作是关键</h3>
<p>　　性能测试是比较复杂的一个测试环节，比如对一个学生进度跟踪系统，客户会要求“100%的网页在5秒或者是更短的时间内显示出来，应用程序支持1000及以上用户同时使用，98%的情况下，课程将在第一次尝试时就完全正确下载”，等等。虽然这是客户的要求，在这样是不可以写进目标里的，因为这完全无法验证，不能讲模棱两可的性能指标写到合同义务中。性能测试应该做到可度量有价值。将其改为“对于内部版本（出现情况需上报），在任意数量的用户条件下，有超过5%的情况加载网页的时间超过5S，超过2%的情况，课程无法完整或正确的下载……对于外部版附有性能报告，包括在，任意数量的用户条件下，有超过5%的情况加载时间超过5S的网页，超过2%的情况无法完整或正确下载的课程……”。<br>　　<strong>对于性能测试的需求从承诺达到一定水平转变为承诺报告在什么样的条件下目标将无法实现。这个过程就涉及到项目经理，客户，开发人员之间的交流和协作。</strong><br>　　但是面对这样的目标还是无法给出测试用例，那么应该在系统中设置检查点，策略：收集系统性能指标基准，并验证使用模型中包括的每个功能任务，分别在1个用户的负荷下，10个用户，1000甚至更多负荷下载每一个包含该功能任务的性能测试中都达到性能需求，每一个下面都需要列出功能任务清单。一个系统的性能是客户最关注的，但是你无法不能性能测试所有的东西。文中用一个超级杯营销的案例，说明性能测试需要与其他测试人员协作，于项目管理协作，于客户协作，于开发团队协作，于IT人员协作，以及与最终用户协作。</p>
<h3 id="二、模糊测试，让系统更可靠">二、模糊测试，让系统更可靠</h3>
<p>　　模糊测试大多数用于办公软件，<strong>那什么是模糊测试：是通过对输入数据进行随机修改和破坏来测试程序的方法。</strong>他为测试和编程人员在开发软件时面临的棘手问题提供多种优美的解决方案。办公软件需要支持很多种格式，我们或许能找到特定格式的文档，但这些文档可能不准确或有丢失处。例如与其他软件之间的互操作性，我们就需要模拟其他复杂软件，或者用一个模糊器生成范围很广的各种文档来模拟各种应用软件和软件版本的差别。office2007在开发的时候就大量使用了模糊测试。<br>　　在进行模糊测试的时候需要准备一组有代表性的文档，一个模糊器，从常规模型到自定义模型。在测试过程中也要不断的修改你的模糊器，以产生更多的测试用例并去除可能影响输出的偏差。模糊测试擅长发现诸如崩溃和挂起的明显问题，但对判断正确性的作用很小。在办公软件领域，它对开发和测试人员所面临的操作性、安全性、和稳定性在内的许多复杂问题提供有创意且简洁的解决方案。</p>
<h3 id="三、自动化测试">三、自动化测试</h3>
<p>　　自动化测试不仅仅是简单的编写和运行那些不需要人为干预的测试用例。事实上，在很多测试人员看来，自动化这是由一些手动生成的，用来执行特定测试场景或一部分产品功能的测试脚本或代码组成。但是很多时候自动化测试并没有给测试人员带来方便，因为除了实际的执行程序之外，流程中的其他部分没有一个实现了自动化。那么为了实施自动化，特别是规模较大的自动化测试，整个过程从头到尾—从测试人员编写玩测试程序到结果被分析出来给人看，都必须自动化。如果没有这个层次上的自动化，测试人员在监控测试程序运行上所花的时间将会变成难以控制的增长。<br>　　在什么情况下自动化可以帮助测试团队，以及什么情况下自动化会妨碍测试的工作，应该百分百的自动化那些应该被自动化的测试，这一准则本身是简单多额，困难就在于决定那些是应该被自动化的，产品架构，相关参与者，都可以帮助测试团队做出正确的决定。很多自动化之所以失败的原因在在于测试人员花太多的时间进行自动化或者试着去自动化，并把时间花在了根本不值得自动化的目标任务上。<br>　　一个基本的自动化测试流程：编写自动化测试—-选择测试和测试平台—-运行测试—-收集用于报告的测试结果—-报告新的额bug解决已近修复的bug。自动化测试要成功的第一步是：测试代码要写得棒。必须要能够易于维护，要对测试带进行源代码控制，并且集中编译和创建。测试员可以成为设计和实现系统测试框架的专家，这于应用程序开发是不一样的。<strong>编写一个漂亮的测试自动化工具需要对被测系统的理解，需要对可能将要编写的测试的理解，需要知道哪些测试对项目最优价值，还需要知道哪些测试最可能在将来随着被测软件的变化而具有可维护性。</strong><br>　　<em>如果在某一阶段，测试通过率仅为94%，你会怎么做？对于合理的测试通过率目标，与其去设定一个神奇的数字，你真正需要的是100%的失败调研并确保那些失败中没有一个严重到阻碍发布。回答”这要看失败来定了，如果阻碍我么达到目标的错误不满足我们的门槛，我们就让他过去“</em></p>
<h3 id="四、测试随机数发生器">四、测试随机数发生器</h3>
<h3 id="五、QA不是魔鬼">五、QA不是魔鬼</h3>
<p>　　测试人员是好的流程的促进者，能准确的发现（在发布之前）软件需求与实现之间不吻合的人，也是最广泛了解软件开发实践的人，对项目总体状态最了解的人。QA的工作是引导软件开发过程以提高成功率，以及建设性的批判软件开发过程而不是阻碍这个过程并成为拖后腿的人。<br>　　检验：通过重复的操作来确认事情做得正确的过程。<br>　　调查：反馈驱动的过程<br>　　很多人认为测试就是简单的触屏和点击，无聊的文本进行，是一个简单无聊的工作，如果这么想就错了，这样的工作不是调查而是检验。测试不仅仅是这些，测试往往需要和各类人员沟通，测试是对产品质量负责，保证每个产品能满足客户的需求及时上线。</p>
<h3 id="六、高效测试">六、高效测试</h3>
<p>　　软件测试中首要考虑的问题就是：安全性测试。导致用户数据的丢失是一件很糟糕的事情！安全性测试必须最早考虑，因为其贯穿在整个产品的架构之中。即架构上如果有所改动，那么几乎需要重新测试所有的东西，比如如果数据库的权限有问题，那么就不得不重新测试所有与数据库交互有关的测试用例，或者一旦程序和操作系统的交互存在安全问题，所有与操作系统交互有关的测试用例也必须重测。安全性对于应用程序的测试几乎会影响到每一个测试领域，需涉及到整个应用程序，对于安全性要求高的领域最好有相关的信息安全人员提供高级全面的解决方案。<br>　　在互联网应用程序中，可以考虑一下几个问题：跨站脚本、SQL注入、越权访问、信息泄露。</p>
<h3 id="七、查找缺陷">七、查找缺陷</h3>
<p>　　问：如果处于整个软件开发周期的最后一个环节：所有的新功能都实现了所有的测试用例也通过了，那么产品可以发布了吗？<br>　　理论上讲是测试用例都通过了就没有问题了，但是怎么保证你的测试集是完美的，如何才能知道你的测试集能有效的检查出缺陷。在这种情况下，可以系统化的植入认为的缺陷，然后测试集能否发现他们。测试集的代码覆盖率就是量化的度量测试集的质量指标（检查是否执行了程序的每一种状态）、分支覆盖率（保证代码中的分支至少被执行一次）、条件覆盖率（保证代码中每个条件分支子条件都经历过是和否的状态）。80%的缺陷都集中在20%的模块中。<br>　　覆盖率只能告诉你测试执行的情况并没有测试集本身的信息。可以使用变异测试，在程序中植入大量的人为的漏洞，并逐个对他们进行测试看哪些变异没有检测出来。然后系统化的改进这个测试集，知道所有的变异都能被检测出来。但是变异测试非常耗时。变异测试依赖于自动化测试。<br>　　问：怎么对程序进行变异呢？改变常量的值（对某一常量X，尝试用X-1,X+1，0来替换），用常量来替换变量的值，用变量来替换数组的引用，改变操作符，改变调用方法，将某一条件置返（判断条件c为非c）。改变数字操作符+改成-,&gt;&gt;改成&lt;&lt;。省略方法调用(将一个方法调用直接改为0.如果该方法不需要返回值，可以直接删除)。</p>
<h3 id="八、测试分类">八、测试分类</h3>
<p>　　黑盒和白盒测试是软件测试中最普遍的设计方法，在黑盒测试中，软件被看做是一个神秘的对象，他的内部结构和设计是未知的，他接受一些输入数据，对数据进行处理，然后输出结果。如果一个程序能正确处理数据并输出预期的结果，则认为测试师成功的。黑盒测试是以软件说明书为基础的，而白盒测试则需要具有软件内部实现的了解，并关注于程序的某一特定路径的测试。程序员要小心的选择测试用例以覆盖所有重要的代码单元。虽然黑盒和白盒测试方法是互相补充的，但二者都有一些共同的局限。其中主要的一个问题就是他们都不能对程序进行全面的测试。这就要求你富有创造型、有效的进行设计，甚至为了在用户使用软件之前将缺陷找到，还要开发出漂亮的测试来覆盖个整蛊你用例。<br>　　静态分析：白盒测试一种，不需要代码的执行，在于查找一般性错误确保代码满足所有重要的要求和标准。一般自动化执行。例如GCC编译器是静态分析工具。<br>　　单元测试：白盒测试一种，检查代码单元个体单个函数或模块是否正常工作，是否接受和处理数据u，并返回预期的值。<br>　　测试脚本：一系列逐步运行的指令集合，再现各种不同的条件来检查程序各项功能是否正常，模仿日常对应用程序的使用，给定在一系列牌值下下能否输出正确的的结果。不关心程序的内部细节。 </p>
<hr>
<p>　　<br>　　<em>这本书并不适合出学者看，建议有了一定的测试基础之后在过来看本书。以上的只是书里的一些摘录，对于测试的理解还不是很深入，但是对于测试会有一点大概的了解，书中提到的一些经验还是不错的，但是个人感觉这本书有点旧时了，不建议看。当然这个只能我个人的看法。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<strong>王小波说：这个世界上有两种人，一类人将有趣的事情做成无趣，一类人把无趣的事情做成有趣。</strong>软件测试原本是件很有趣的事情，可是网上有很多的人或者一些做测试的人很不幸将测试这件有趣的事做成了无趣的事情：觉得是日复一日的手工劳动，不断的和开发人员]]>
    </summary>
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对艾扬格大师的光耀生命有感]]></title>
    <link href="http://yoursite.com/2014/09/16/%E5%AF%B9%E8%89%BE%E6%89%AC%E6%A0%BC%E5%A4%A7%E5%B8%88%E7%9A%84%E5%85%89%E8%80%80%E7%94%9F%E5%91%BD%E6%9C%89%E6%84%9F/"/>
    <id>http://yoursite.com/2014/09/16/对艾扬格大师的光耀生命有感/</id>
    <published>2014-09-16T13:09:00.000Z</published>
    <updated>2014-09-16T13:14:37.000Z</updated>
    <content type="html"><![CDATA[<p>　　一开始接触这本书的时候，只是纯粹处于对瑜伽的热爱，在瑜伽馆里打发时间之用，只是没有想到，看了几章之后，彻底喜欢了，不仅仅改变了我最初对瑜伽的理解也让我对生活中的一些事情看的更开阔了，对生命的感悟。如果不是抱着喜欢瑜伽的心情估计我不会拿起这本书，而当我放下这本书的时候，对瑜伽的喜爱更甚了，20号看到艾扬格大师去世的消息，感觉这么一位智慧的大师就这么离我们而去了。我不是什么很感性的人，但是艾扬格的睿智真的让我很佩服，他在历经70年的瑜伽修行、瑜伽哲学与瑜伽教育生活之后，已他的经验，以他的睿智。想我们讲述瑜伽的每一种练习方式是如何影响我们的，教授我们在瑜伽修习中，保持何种的醒觉和意识才能更好的通过瑜伽释放生命的创造性潜能，光耀生命。这本书不仅仅是我瑜伽的启蒙，更是我对生活的感悟。<br>　　<br>　　“大多数人修习瑜伽体式都有非常实际的原因，而且往往是身体的原因，极少数人练习瑜伽是为了获得精神的觉悟，这正说明大多数来练瑜伽的人都是讲究实际的人都有着实际的问题和目标，都是置身于<strong>生命现实的人，明白事理的人</strong>”艾扬格大师最初修习瑜伽也是为了追求身体的好处，想要改善身体，正如我的想法一样，我只是想让体型更好，增加气质，正本没有错，在慢慢融入瑜伽的世界里的时候你会对瑜伽有更好的理解，参透瑜伽的远大内涵，从而达到其所谓的三摩地境界。<br>　　<br>　　瑜伽将存在分为五个层面，这五个层面必须完全融合才可能获得圆满，而这本书也是已这五个章节为划分的：<strong>身体之安稳，心体之清明，智体之通达，法体之极乐</strong>。不要低估体式的价值。即便在简单的体式练习忠，我们也会有三个层次的追寻体验：<strong>外在的追寻我们带来身体的强健；内在的追寻给我们带来智性的平和；而深层的追寻给我们带来灵性的仁爱</strong>。初学者在练习体式时未必会体会到这些层面但这些层面仍然存在。<br>　　<br>　　身体是一切的根本，瑜伽是锻炼好身体让他可以更好的迎接将来。<em>一切根本源于当下，努力做好当下的所有的一切，同时痛苦与快乐时并存的，就如同练习的时候会觉得累，而练习过后你将会觉得很轻松，一切是在于平时的积累，过程是辛苦并且伴随快乐，但最后你会有好的结果。</em>这里只是简单的记录下书中的很多好的思想，其实最重要的东西，已经吸收在大脑中了。我一开始以为这本书就是中文版的因为作者对瑜伽理论有着深厚的理解，百度了之后才知道是翻译的，才感觉翻译者很有翻译水平，把YOGA同中国的传统文化，比如道家、儒家，融会贯通在一块讲解，文中也有很多的注释体现了瑜伽和中国传统文化的融合和相同之处。<br>　　<img src="/images/yujia.jpg" alt="瑜伽"></p>
<p>1、瑜伽从崇拜身体开始，但最终趋向于心之修炼。<br>2、你要爱你的身体，感怀它给予你的一切。<br>3、瑜伽是生命游戏的规则法典，但这是一场无人会输的游戏。<br>4、我们需要健康的身体才能培养健康的心灵。<br>5、身体的平衡是生活平衡的基础。<br>6、身体的平衡是精神安宁的表现。<br>7、我们真正要做的是把活跃的能量注入迟滞的物体。 8、瑜伽对于健康三重功用：让健康的人保持健康，抑制疾病的发展，协助疾病的康复。<br>9、头脑是智性之器官，心脏是感性之器官。<br>10、做瑜伽时，是身体告诉我们让该如何做，而不是大脑。<br>11、要让身体成为行动者，让大脑成为观察者。<br>12、醒觉的憩息可以让心灵复苏，让身体净化。<br>13、如果你无法让身体寂静，你也不会懂得心之寂静。<br>14、如果我说：“让你的大脑放松”，你可能做不到。如果我让你进入某一体式，你的大脑就会放松下来，你也会变得安静。这正是瑜伽的魅力所在。<br>15、就技术层面而言，任何身处压力的人、身体虚弱的人，或肺部虚弱、肌肉僵硬、脊柱坍塌、心事不定、精神焦虑、胆小怯懦的人都不可能达到瑜伽意义上的真正禅定状态。<br>16、我们需要的是敏捷的头脑，而不是躁动的头脑。<br>17、瑜伽的挑战性在于超越我们我们的极限——但要在理性的限度之内。我们用身体的画布不断扩展我们的心灵的框架，就像你把一张画布不断拉伸，以获得更大的绘画空间。<br>18、意志力不仅仅是精神的，也是身体的。<br>19、我一旦自问：“今天与昨天是否有所不同。”我就有了进步。<br>20、大家都想要更多的生命能量。如果能量可以在店里打包销售，这会是世上最成功的生意。哪怕只是谈论能量也会让人激动，给人增添能量。人们想知道，我们从哪里获得能量！能量当然不会在店里，不在商品的包装里，因为能量不仅无所不在而且取之无禁。<br>21、能量本身就是颇具魅力的品性。<br>22、要让气与心同时而动，若心先动，你就是在勉强。<br>23、眼睛离大脑很近，其紧张与过敏的状态可以反映出大脑神经过载的的严重程度。<br>24、为驯服你的大脑，你需要驯服你的呼吸。<br>25、瑜伽反对的是心为物役。<br>26、心识不住过去，亦不住未来，而居于当下此刻。<br>27、体式让我们用心内视自己的身体，调息开始让我们把心念与感官与外界脱离，由此我们的意识与能量才被运用于身心之内。<br>28、以譬喻而言，良性的睡眠如同开放的玫瑰花回归于花蕾。<br>29、下学许多小事，最终可以上达一件大事。<br>30、以身修心<br>31、瑜伽体式的修习帮助我们学会使用“身体”这一奇妙的天赋资具。<br>32、体式修行的目标是产生并稳定我们的能量，养护能量，而不是毫无必要地浪费能量。<br>33、让你的舌头柔软，大脑就不会有任何紧张。<br>34、你一旦学会如何放松舌头与喉咙，你就会懂得如何放松大脑，因为舌、喉与大脑之间也有联系。<br>35、去观察一下猫，猫是伸展大师和放松大师。<br>36、胸膛的各个角落就像支柱，支柱必须保持稳健。<br>37、塌陷的胸腔会把自性投入牢笼。<br>38、在动作中，肌肉应该像花瓣一样，开放而柔和。<br>39、双脚就像树根一样，如果一个人立脚不稳，他对生命的态度会变得消极，他做的瑜伽也不会稳健。<br>40、通过放松太阳穴和眼睛就可以解除大脑的负担。<br>41、后仰可以强健脊柱的内部肌肉，而向前伸展可以增强其外部的肌肉。<br>43、正常呼吸时，全身吸气，全身呼气。<br>44、简单而言，调息就是呼吸的延长与控制。<br>45、既然生命本有的能量就是气，调息就意味着生命能量的扩展。<br>46、在瑜伽式呼吸时，大脑和身体的四肢保持安静，而只有肺部被启动。<br>47、呼吸系统得到充分利用，但不会造成神经系统紧张。呼吸可以静心。吸气时会紧张，呼气时自在。呼气时可清除体内的压力与紧张。气之所以特殊是因为它承载意念。呼吸的存在就是生命的天赋。<br>48、如果你想把你的意念带到你的大脚趾最末端的细胞，气就可以将其送到。49、我们需要产生大量的“气”。而要产生“气”，我们就必须对我们的正常呼吸进行扩展，控制与约束。气息就是生命。宇宙能量是通过呼吸的载体与我们相通。<br>50、调息是把心与感官从外界收回的开端，调息让人安静也是这个原因。<br>51、心本身也是一种空间的振动。<br>52、心振动的声音只有耳朵能够听到。<br>53、耳朵的重要功能是倾听心中振荡之声并调谐其状态。<br>54、若吸气时以脑的意念为主，你所行的是自我本位的调息。若脑的意念下降，而心成为主导，你就是在修习真正的、谦卑的调息。<br>55、你掌握了自己的气，你也掌握了自己的灵。<br>56、在吸气达到最大限度时屏息，你也将神性之无限囿于己身。<br>57、通过呼气，你慷慨地将自我交付给天地宇宙。<br>58、吸气让生命充满全身。<br>59、压力造成的呼吸短促会消耗我们的生命能量。<br>60、意识随呼吸波动，而屏息让意识从欲望中解脱。<br>61、呼气后屏息可给我们的心境与情感带来平静与安静。<br>62、试一下，缓慢充分呼气，暂停，然后呼气。<br>63、吸气后之圆满，呼气后之空寂。<br>64、生命自身寻找完满，恰如植物寻找阳光。呼气后毫无期必而出现的屏息在时间之帘幕中打开了缝隙。无过去，无未来，也无现在之消逝可以感知。只有当下之刹那。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　一开始接触这本书的时候，只是纯粹处于对瑜伽的热爱，在瑜伽馆里打发时间之用，只是没有想到，看了几章之后，彻底喜欢了，不仅仅改变了我最初对瑜伽的理解也让我对生活中的一些事情看的更开阔了，对生命的感悟。如果不是抱着喜欢瑜伽的心情估计我不会拿起这本书，而当我放下这本书的时候，对]]>
    </summary>
    
      <category term="瑜伽" scheme="http://yoursite.com/tags/%E7%91%9C%E4%BC%BD/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新的开始]]></title>
    <link href="http://yoursite.com/2014/09/12/born/"/>
    <id>http://yoursite.com/2014/09/12/born/</id>
    <published>2014-09-12T03:15:12.000Z</published>
    <updated>2014-09-13T12:03:26.000Z</updated>
    <content type="html"><![CDATA[<p>这是新的开始，我用hexo创建的第一篇文章。</p>
<p>通过下面的命令就可以创建新文章</p>
<a id="more"></a>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:<span class="command">\workspace</span><span class="command">\javascript</span><span class="command">\nodejs</span>-hexo&gt;hexo new 新的开始</div><div class="line"><span class="special">[</span>info<span class="special">]</span> File created at D:<span class="command">\workspace</span><span class="command">\javascript</span><span class="command">\nodejs</span>-hexo<span class="command">\source</span><span class="command">\_</span>posts<span class="command">\新</span>的开始.md</div></pre></td></tr></table></figure>

<p>感觉非常好。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是新的开始，我用hexo创建的第一篇文章。</p>
<p>通过下面的命令就可以创建新文章</p>
]]>
    
    </summary>
    
      <category term="开始" scheme="http://yoursite.com/tags/%E5%BC%80%E5%A7%8B/"/>
    
      <category term="日记" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2014/09/12/hello-world/"/>
    <id>http://yoursite.com/2014/09/12/hello-world/</id>
    <published>2014-09-12T02:57:48.000Z</published>
    <updated>2014-09-12T14:17:00.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
]]>
    
    </summary>
    
  </entry>
  
</feed>
