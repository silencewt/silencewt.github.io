<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silence 婷婷 Blog]]></title>
  <subtitle><![CDATA[既然选择远方，便风雨兼程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2014-12-25T14:04:31.672Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Wangt]]></name>
    <email><![CDATA[wangt_hust@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[简单Xpath入门]]></title>
    <link href="http://yoursite.com/2014/12/25/%E7%AE%80%E5%8D%95Xpath%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2014/12/25/简单Xpath入门/</id>
    <published>2014-12-25T13:54:52.000Z</published>
    <updated>2014-12-25T14:01:04.000Z</updated>
    <content type="html"><![CDATA[<p>　　XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。XPath 是 XML 的查询语言，和 SQL 的角色很类似。以下面 XML 为例，介绍 XPath 的语法。</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span>
<span class="tag">&lt;<span class="title">catalog</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"USA"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Empire Burlesque<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bob Dylan<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>10.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"UK__time"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"UK"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"USA"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Greatest Hits<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Dolly Parton<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span><span class="tag">&lt;/<span class="title">catalog</span>&gt;</span>
</code></pre><p><strong>定位节点</strong></p>
<p>　　XML 是树状结构，类似档案系统内数据夹的结构，XPath 也类似档案系统的路径命名方式。不过 XPath 是一种模式(Pattern)，可以选出 XML 档案中，路径符合某个模式的所有节点出来。<br>1）要选 catalog 底下的 cd 中所有 price 元素可以用：<br>　　 /catalog/cd/price<br> 　 如果 XPath 的开头是一个斜线（/）代表这是绝对路径。如果开头是两个斜线（//）表示文件中所有符合模式的元素都会被选出来，即使是处于树中不同的层级也会被选出来。</p>
<p>2）选出文件中所有叫做 cd 的元素（在树中的任何层级都会被选出来）：<br>　　//cd　　使用星号（Wildcards,＊）可以选择未知的元素。</p>
<p>3）选出/catalog/cd 的所有子元素：<br>　　/catalog/cd/*</p>
<p>4）选出所有 catalog 的子元素中，包含有 price 作为子元素的元素。<br>　　/catalog/*/price</p>
<p>5）选出有两层父节点，叫做 price 的所有元素。<br>　　/<em>/</em>/price</p>
<p>6）选择出文件中的所有元素。<br>　　//<em>　<br>　　要注意的是，想要存取不分层级的元素，XPath 语法必须以两个斜线开头(//)，想要存取未知元素才用星号(</em>)，星号只能代表未知名称的元素，不能代表未知层级的元素。</p>
<p><strong>选择分支</strong><br>使用中括号可以选择分支。</p>
<p>1）从 catalog 的子元素中取出第一个叫做 cd 的元素。XPath 的定义中没有第0元素<br>　　/catalog/cd[1]</p>
<p>2）选择 catalog 中的最后一个 cd 元素： XPath 没有定义 first() 这种函式，用上例的 [1]就可以取出第一个元素。<br>　　/catalog/cd[last()]</p>
<p>3）选出含有 price 子元素的所有/catalog/cd 元素。<br>　　/catalog/cd[price]</p>
<p>4）选出 price 元素的值等于10.90的所有/catalog/cd 元素<br>　　/catalog/cd[price=10.90]</p>
<p>5）选出 price 元素的值等于10.90的所有/catalog/cd 元素 的 price 元素<br>　　/catalog/cd[price=10.90]/price</p>
<p><strong>选择一个以上的路径</strong></p>
<p>使用 Or 操作数(|)就可以选择一个以上的路径</p>
<p>1）选择所有 title 以及 artist 元素<br>　　//title | //artist</p>
<p>2）选择所有 title 以及 artist 以及 price 元素<br>　　//title | //artist | //price</p>
<p><strong>选择属性</strong> </p>
<p>在XPath的属性。除了选择元素以外，也可以选择属性，属性都是以@开头。</p>
<p>1）选择文件中所有叫做 country的属性。<br>　　//@conutry</p>
<p>2）选择所有含有country 这个属性的 cd元素。<br>　　//cd[@country]</p>
<p>3) 选择出country属性值为UK的cd元素<br>　　//country[@country==’UK’]</p>
<p><strong>部分匹配</strong></p>
<p>有些属性的值具有一定的规律，例如上面的UK就是前缀，一部分是不变的。也可以用start-with</p>
<p>1）定位属性值前缀为UK<em>的元素<br>　　//cd[containers(@country，’UK</em>‘)]<br>　　//cd[start-with(@country，’UK_’)]  </p>
<p>这是在某个文档里面学习来的，感觉简单又易上手，故摘录于此。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。XPath 是 XML 的查询语言，和 SQL 的角色很类似。以下面 XML 为例，介绍 XPath ]]>
    </summary>
    
      <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
      <category term="selenium" scheme="http://yoursite.com/categories/selenium/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[selenium--大家庭介绍]]></title>
    <link href="http://yoursite.com/2014/12/25/selenium-%E5%A4%A7%E5%AE%B6%E5%BA%AD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2014/12/25/selenium-大家庭介绍/</id>
    <published>2014-12-25T13:29:10.000Z</published>
    <updated>2014-12-25T14:01:20.000Z</updated>
    <content type="html"><![CDATA[<p>安装好配置环境后，开始我的selenium之旅。简单的了解一下色，selenium大家庭的组成。</p>
<p>Selenium是ThoughtWorks专门为Web应用而开发的功能测试工具。Selenium使用JavaScript和Iframes在浏览器嵌入自动化测试引擎，可以在任何支持JavaScript的浏览器中进行工作，模拟用户在浏览器中进行的操作。Selenium的强大之处就在于可以使用集成开发环境，让用户使用自己最熟悉的开发语言进行调试操作。</p>
<p><strong>Selenium的优势</strong>：<br>1）它是开源的    </p>
<p>2）简单，易于安装，易于工作    </p>
<p>3）提供Selenium IDE ，一个FireFox plugin，能自动记录用户的操作，生成测试脚本。生成的测试脚本可以基于Selenium RC放入Java，C#，Ruby的单元测试用例中自动运行。selenium ide是selenium的唯一可以在浏览器窗口上记录用户行为的组件     </p>
<p>4）除了火狐上的事件外不会记录你电脑上的任何其他事件    </p>
<p>5）Selenium支持多种浏览器，能够运行与多种操作系统，因此更容易帮助测试人员发现应用程序在不同浏览器上的兼容性问题。通过在不同浏览器中运行测试，更容易发现浏览器的不兼容性. </p>
<p>6）通过编写模仿用户操作的 Selenium 测试脚本，可以从终端用户的角度来测试应用程序；可以操作 Web 页面上的各种元素，诸如：点击按钮、输入文本框，以及断言 Web 页面上存在某些文本与 Web 元素等。<br><br>7）测试用例调用实际的浏览器(如IE、FireFox)来执行测试。和有些开源方案自行实现Web解释引擎相比，实际的浏览器能模拟更多用户交互和JS语法。    </p>
<p> 8） SELENIUM录制的脚本比较灵活，因为它生成的是PERL的脚本程序。作为几乎最为强大和最广泛使用语言之一，PERL这种程序给予我最大的灵活性和控制度。</p>
<p><strong>Selenium IDE</strong> 支持并且只支持 Firefox 浏览器，支持的浏览器太少，而依附于 Firefox 也不便于日后开展自动化测试，但是，它的录制快捷好用！并且有代码 转换功能，可以把 Selenium 语言测试案例转为 C#,Java 等语言的测试案例，使用 Selenium IDE + FireBug 进行测试案例的编写，然后转为其他语言的测试案例后，再调用 Selenium RC运行测试案例。</p>
<p><strong>Selenium RC</strong> 它支持很多浏览器，可以使用 C#，Java 等语言编写测试案例，易于维护，同时提供了很好的扩展性，将使用Selenium RC 测试工具。</p>
<p>selenium 和 WebDriver 合幵后创建了一个新的 Selenium 2 框架。 Selenium 是一个针对网页应用测试非常好的框架。他有着一些积极的影响。WebDriver 也不像 Selenium 1 一样需要一个代理。你可以直接和浏览器进行对话。这也非常受人们欢迎的，因为可以加快测试的执行速度，不需要一个“中间人”进行传递消息。</p>
<p><strong>Selenium IDE</strong>：右Command、target、value组成的表格就是脚本，每个脚本都是一条条的action行为组成，action有CTV 三者组成，command就是api中的各种函数，target就是web中的某个目标对象，比如：输入框、按钮等，使用xpath选取对象。Value：根据实际内容填写。</p>
<p>　　在这里可以手动的增加两种页面校验：verify和assert。他们都能对显示内容，输出内等做验证，区别在于：</p>
<ul>
<li>verify：验证失败了，会抛出期望结果不存在的错误，但是测试过程会继续执行下面的步骤，但会显示成淡红的。</li>
<li>assert：验证失败，测试不会继续执行下去。</li>
</ul>
<p>Selenium 没有指明会等到需要交互的元素出现，所以你最好等到需要交互元素出现时再迕行交互，即利用wait指令。如带有下拉菜单，带有ajax的页面都要有所等待，等页面元素准备好了再进行下一步的操作。</p>
<p>Selenium RC：有两部分组成</p>
<ul>
<li>Selenium Server：负责控制浏览器行为，包括三个部分：launcher、http proxy、Selenium core，其中Selenium core是Selenium server嵌入到浏览器页面中的，Selenium core是一堆JS函数的集合，从而实现对浏览器的操作。</li>
<li>Selenium Clientlibrary：写测试案例时用来控制server的库。</li>
</ul>
<p>支持很多浏览器，可以使用C#，Java 等语言编写测试案例，易于维护，同时提供了很好的扩展性。</p>
<p><strong>Selenium Grid</strong>允许创建很多个 Selenium RC实例，由一个中心来发送 Selenium RC命令。拥有一个中心点 Hub， 测试可以连接到此点，  测试命令会推送到连接在此集线器上的Remote RC 实例上。 这个中心有一个 web 界面（localhost：4444/console）， 告诉你连接在此集线器上的Selenium RC 实例，和返些实例是否正在使用的状态。</p>
<blockquote>
<p>启动Selenium Server<br>java –jar selenium-server-standalone-2.22.0.jar -port 4444<br>启动Selenium Grid的Hub<br>java –jar selenium-server-standalone-2.22.0.jar -port 4000 -role hub<br>启动Selenium Grid的Node，其中的-hub参数，是Selenium Grid的Hub的URL<br>java -jar selenium-server-standalone-2.22.0.jar -port 4001 -role node -hub <a href="http://127.0.0.1:4000/grid/register" target="_blank" rel="external">http://127.0.0.1:4000/grid/register</a></p>
</blockquote>
<p>显然，可以启动多个Node：<br>java -jar selenium-server-standalone-2.22.0.jar -port 4002 -role node -hub <a href="http://127.0.0.1:4000/grid/register" target="_blank" rel="external">http://127.0.0.1:4000/grid/register</a></p>
<h4 id="WebDriver">WebDriver</h4>
<p>　　WebDriver 提供一个先进技术来定位 web 页面元素。其实WebDriver就是基于Selenium的一个自动化测试类库，但它不再是运行在浏览器内的JS程序，而是自己可以控制浏览器。webdriver提供了很多方式来定位元素，对于不同平台的语言都有相关的api，如C#、java、python、ruby等等。</p>
<p>　　前段时间利用空余的时间学习这方面的知识，现将其一点点的整理出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>安装好配置环境后，开始我的selenium之旅。简单的了解一下色，selenium大家庭的组成。</p>
<p>Selenium是ThoughtWorks专门为Web应用而开发的功能测试工具。Selenium使用JavaScript和Iframes在浏览器嵌入自动化测试引擎]]>
    </summary>
    
      <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
      <category term="selenium" scheme="http://yoursite.com/categories/selenium/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个网页的测试用例]]></title>
    <link href="http://yoursite.com/2014/12/25/%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://yoursite.com/2014/12/25/一个网页的测试用例/</id>
    <published>2014-12-25T13:23:58.000Z</published>
    <updated>2014-12-25T14:03:45.000Z</updated>
    <content type="html"><![CDATA[<p>　　今天在看51testing的博客时，看到这么一个网页登录的测试用例，想到自己之前写的那个关于登录页面的简单的功能测试用例真的是太弱了，感觉很多都没有考虑进去。特此在这里记录下来，参考。具体需求： 有一个登陆页面， （假如上面有2个textbox, 一个提交按钮。 请针对这个页面设计30个以上的TestCase.）</p>
<p>　　此题的考察目的：面试者是否熟悉各种测试方法，是否有丰富的web测试经验， 是否了解Web开发，以及设计Test case的能力<br>首先，你要了解用户的需求，比如这个登录界面应该是弹出窗口式的，还是直接在网页里面。对用户名的长度，和密码的强度（就是是不是必须多少位，大小写，特殊字符混搭）等。还有比如用户对界面的美观是不是有特殊的要求？（即是否要进行UI测试）。剩下的就是设计用例了 ，等价类，边界值等等。<br>　　请你记住一点，<strong>任何测试，不管测什么都是从了解需求开始的。</strong></p>
<p><strong>功能测试(Function test)</strong><br>　　0.  什么都不输入，点击提交按钮，看提示信息。（非空检查）<br>　　1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。（正常输入）<br>　　2.输入错误的用户名或者密码, 验证登录会失败，并且提示相应的错误信息。（错误校验）<br>　　3.登录成功后能否能否跳转到正确的页面（低）<br>　　4.用户名和密码，如果太短或者太长，应该怎么处理（安全性，密码太短时是否有提示）<br>　　5.用户名和密码，中有特殊字符（比如空格），和其他非英文的情况（是否做了过滤）<br>　　6.记住用户名的功能<br>　　7.登陆失败后，不能记录密码的功能<br>　　8.用户名和密码前后有空格的处理<br>　　9.密码是否加密显示（星号圆点等）<br>　　10.牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个按钮是否好用<br>　　11.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确<br>　　12.输入密码的时候，大写键盘开启的时候要有提示信息。</p>
<p><strong>界面测试(UI Test)</strong><br>　　1.布局是否合理，2个testbox 和一个按钮是否对齐<br>　　2.testbox和按钮的长度，高度是否复合要求<br>　　3. 界面的设计风格是否与UI的设计风格统一<br>　　4. 界面中的文字简洁易懂，没有错别字。</p>
<p><strong>性能测试(performance test)</strong><br>　　1.打开登录页面，需要几秒<br>　　2.输入正确的用户名和密码后，登录成功跳转到新页面，不超过5秒</p>
<p><strong>安全性测试(Security test)</strong><br>　　1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)<br>　　2.用户名和密码是否通过加密的方式，发送给Web服务器<br>　　3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript验证<br>　　4.用户名和密码的输入框，应该屏蔽SQL注入攻击<br>　　5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）<br>　　6.错误登陆的次数限制（防止暴力破解）<br>　　7. 考虑是否支持多用户在同一机器上登录；<br>　　8. 考虑一用户在多台机器上登录</p>
<p><strong>可用性测试(Usability Test)</strong><br>　　1. 是否可以全用键盘操作，是否有快捷键<br>　　2. 输入用户名，密码后按回车，是否可以登陆<br>　　3. 输入框能否可以以Tab键切换</p>
<p><strong>兼容性测试（Compatibility Test）</strong><br>　　1.主流的浏览器下能否显示正常已经功能正常（IE,6,7,8,9, Firefox, Chrome, Safari,等）<br>　　2.不同的平台是否能正常工作，比如Windows, Mac<br>　　3.移动设备上是否正常工作，比如Iphone, Andriod<br>　　4.不同的分辨率</p>
<p><strong>本地化测试（Localization test）</strong><br>　　1. 不同语言环境下，页面的显示是否正确。<br>　　软件辅助性测试 （Accessibility test）<br>　　软件辅助功能测试是指测试软件是否向残疾用户提供足够的辅助功能<br>　　2. 高对比度下能否显示正常 （视力不好的人使用）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　今天在看51testing的博客时，看到这么一个网页登录的测试用例，想到自己之前写的那个关于登录页面的简单的功能测试用例真的是太弱了，感觉很多都没有考虑进去。特此在这里记录下来，参考。具体需求： 有一个登陆页面， （假如上面有2个textbox, 一个提交按钮。 请针对]]>
    </summary>
    
      <category term="测试用例" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试用例" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[9本java程序员必读的书]]></title>
    <link href="http://yoursite.com/2014/12/25/9%E6%9C%ACjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB%E7%9A%84%E4%B9%A6/"/>
    <id>http://yoursite.com/2014/12/25/9本java程序员必读的书/</id>
    <published>2014-12-25T13:11:05.000Z</published>
    <updated>2014-12-25T13:22:59.000Z</updated>
    <content type="html"><![CDATA[<p>来源：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scene=1#rd" target="_blank" rel="external">http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scene=1#rd</a></p>
<p>　　本文列出的9本书在Java程序员界都是被认为很棒的书。当一个程序员开始初学Java时，他的第一个问题应该是如何选择一本书来作为指导学习Java。这个问题也就表明，相对于其他的教程和博客，Java书籍还是很重要的参考，主要表现在以下两点</p>
<p>●通常书籍是由比较权威的程序员来撰写的。</p>
<p>●相比其他媒介，书籍对于内容的描述更加详细，解释更加明确。</p>
<p>　　本文列出的九本书是我个人非常喜欢的Java书籍，当我有时间的时候，我就会将它们捧在手里阅读。甚至有些书我反复读过很多遍，每次重新读的时候总会有新的收获。因此这些书也是大部分Java程序员喜欢的书籍。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java1.jpg" alt="javabook1"><br>　　Head　First Java是所有编程或者Java初学者最适合的书籍，我很喜欢轻松和寓教于乐的Head First风格，这应该是最有意思的关于Java的书。无论是初级，中级还是高级都能从中有所收获。学习本书，你可以了解到类，对象，线程，集合等编程知识，还可以了解到泛型，枚举，可变参数和自动装箱等语言特性。本书中还涉及到了Java高级编程中的Swing，网络编程，IO操作等，可以让初学者对Java有比较完整地概念。如果你是一位Java初学者，不要犹豫，这本书最适合你了。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java2.jpg" alt="javabook２"><br>　　Head First设计模式又是一部Head First系列的书籍。作者为Kathy Sierra及其团队。当我在2006年开始读这本书的时候，我对设计模式并不是很了解。设计模式解决什么问题，怎么解决问题，如何使用设计模式，设计模式有什么好处，这些问题我几乎都无法回答出来。但是当我读完这本书的时候，一切都豁然开朗。在本书介绍继承和组合一章，使用简单有趣的例子，一步一步提出问题并解决问题，最终得出最优解。本书中会有很多要点总结，幽默对话，练习题还有有名的单词接龙等帮助你更好地了解设计模式。如果你想了解Java中的设计模式，请带走这本书。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java3.jpg" alt="javabook3"><br>　　Effective Java这本书也是一本我最喜欢的。本书为领导开发Java集合框架和并发API包的 约书亚·布洛克 大神所著。本书适合于有着数年开发经验Java程序员，通过本书我们可以很多编程中的最佳实践，并且可以从JDK贡献者布洛克大神这里汲取经验。Effective Java从质量，内容和问题解答方式上来说都是一本评价很高的书，因此读这本书会是一种感觉很棒的体验。另外本书的章节相对比较轻量，与其他章节耦合度较低，因此在旅行或者闲暇时间阅读也是可以的。在内容方面，Effective Java包含了从静态工厂，序列化，equals和hashcode到泛型，枚举，可变参数以及反射的最佳解决方法。本书对Java各方面知识点的讲解会让你受益匪浅。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java4.jpg" alt="enter image description here"><br>又一部 约书亚·布洛克 大神的经典之作，当然本书的另一位主作者为 Doug Lea（影响两次Java历史上的大变革的大神）。这本书几乎就是Java并发和多线程编程方面的权威，同时也是核心Java开发人员必读的一本书。本书的强大主要表现在</p>
<ul>
<li>本书非常详细地描述了多线程和并发中的诸多(小)细节。</li>
<li>本书并非聚焦于核心Java代码的实现，而是关注并发引起的问题，比如死锁，饥饿，线程安全，竞争条件，然后提供可行的方法来解决这些问题。因此这本书可以很好地帮助开发者了解并掌握并发包以及其中的CountDownLatch，CyclicBarrier，BlockingQueue，Semaphore这些类。这也是我一遍一遍阅读这本书的原因。</li>
<li>书中的例子简明扼要清晰，很能描述问题。</li>
<li>解释明确：本书很好地解释了什么是错的，为什么错，怎样改正。这也是本书畅销的原因之一。</li>
</ul>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/java5.jpg" alt="enter image description here"><br>　　这本书是来自O’Reilly的一本成功之作，作者为Naftalin和Philip Wadler。正如书名可知，这本书的内容关注于泛型和集合这两个Java语言的核心方面。本书对于那些有编程经验的程序员加强对集合和泛型的理解和掌握有很大的帮助。本书详细介绍了每一个集合的API，Set, List, Map, Queue，以及他们的实现，对比不同场景下它们的性能优劣。每个章节最后的对比图表很不错。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java6.jpg" alt="enter image description here"><br>　　本书为我个人的最爱，本书重点关注性能监视，性能剖析以及如何使用工具对性能分析。本书不同于其他的编程书籍，因为本书中涉及到很多Java虚拟机的细节，垃圾回收机制，Java堆内存监视以及对程序性能剖析。其中讲述JVM的章节写的很不错，很值得咀嚼。注意，这本书属于编程高级层次，阅读需要具有足够的Java编程经验。初级和中级Java开发者也可以阅读本书也会学到不同程度的干货。所以，你想进行性能调优，把这本书放到你的书架上吧。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java7.jpg" alt="enter image description here"><br>　　再介绍一本 约书亚·布洛克 大神写的书。本书的另一位作者为Neal Gafter（已转到微软做Donet Compiler技术Lead）。本书讲述了Java语言中的极端情况和陷阱。相对于C++，Java更加安全低风险，JVM有着垃圾回收机制，让Java程序员不用关心内存分配和释放，大大提高了程序的开发效率。但是有些时候，即便是经验丰富的程序员也会被Java中的极端情况或陷阱给绊倒。本书列举并详细描述了Java中的这些陷阱。如果你喜欢刨根问底，钻牛角尖，这本书就是为你而写。通过本书，你可以了解很多java的核心知识并对自己的Java水平有所知晓。本人更加喜欢上面提到的 约书亚·布洛克 的 Effective Java 和 Concurrency Practice in Java。但是如果你感兴趣，还是可以去尝试的。为了让收获最大化，你可以先尝试解决书中的问题，然后对着书中的解释进行比较。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java8.jpg" alt="enter image description here"><br>　　这是一本属于Head First系列的关于面向对象编程的书。本书建议和Head First设计模式结合阅读，效果更佳。本书关注于面向对象设计原则，比如多用组合少用继承，针对接口编程而非针对实现编程，不要重复你自己等。这本书可以帮助你写出好代码并且参考最佳实践进行优化改善。当然本书中的内容也适合使用其他面向对象的语言的程序员。想学好面向对象编码和设计规则，现在就开始读这本书哈。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java9.jpg" alt="enter image description here"><br> 　　Thinking in Java book应该是Java中文界最有名的书籍了，中文又名 Java编程思想。作者为Bruce Eckel，他也是Thinking in C++的作者，他用自己很独特的观点讲述了Java。据我所知，这本书获得了很高的认可，本书是一本介绍齐全的Java学习参考书。如果你不喜欢Head First类似小人书那样的讲解，可以尝试这本书。本书的内容讲解详细，成熟（相对Head First有种教科书的感觉）。</p>
<p>　　这就是我的关于Java编程相关的推荐的书，这些都可以说是看成经典中的经典。像Effective Java 和 Head First 系列我已经反复阅读了很多遍。相信看完本文，根据自己的水平和想要提升的知识侧重，你应该能选出最适合自己的书了。<br>　　Mark下，以后慢慢看。。。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来源：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scen]]>
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java--面向抽象编程]]></title>
    <link href="http://yoursite.com/2014/12/25/java-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2014/12/25/java-面向抽象编程/</id>
    <published>2014-12-25T13:09:48.000Z</published>
    <updated>2014-12-25T13:10:15.000Z</updated>
    <content type="html"><![CDATA[<p>　　所谓面向抽象编程是指当设计某种重要的类时，不让该类面向具体的类，而是面向抽象类，及所设计类中的重要数据是抽象类声明的对象，而不是具体类声明的对象。就是利用abstract来设计实现用户需求。</p>
<p>比如：我们有一个Circle圆类，计算其面积。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Geometry</span></span>{
<span class="keyword">double</span> r;
Circle(<span class="keyword">double</span> r){
    <span class="keyword">this</span>.r = r;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span>(){
    <span class="keyword">return</span> (<span class="number">3.14</span>*r*r);
}
}
</code></pre><p>现在要设计一个Pillar（柱类），getvolume（）可以计算柱体的体积。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Pillar{
Circle bottom;
<span class="keyword">double</span> height;
Pillar(Circle bottom, <span class="keyword">double</span> height){
    <span class="keyword">this</span>.bottom = bottom;
    <span class="keyword">this</span>.height = height;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVolume</span>(){
    <span class="keyword">return</span> bottom.getArea() * height;
}
}
</code></pre><p>　　在Pillar（柱类）中，bottom是用具体类Circle声明的对象，如果不涉及用户需求的变化，上面Pillar（柱类）的设计没有什么不妥，但是在某个时候，用户希望Pillar（柱类）能创建出底部是三角形的柱体。显然上面的Pillar（柱类）就无法创建出这样的柱体，即上述设计的Pillar（柱类）不能应对用户的这中需求。</p>
<p>　　重新修改Pillar（柱类）。注意到柱体的计算体积的关键是计算出底面积，一个柱体在计算底面积是不应该关心他的底是社么形状的具体图案，应该只关心这种图像是否具有计算出面积的方法。因此，在设计Pillar（柱类）的时候不应当让他的底是某个具体类的声明的对象，一旦这么做，Pillar（柱类）就会依赖具体类，缺乏弹性，难以应对需求的变化。</p>
<p><strong>第一步</strong>：定义一个抽象类Geometry，类中定义一个抽象的getArea（）方法，Geometry类如下。这个抽象类将所有计算面积的方法都抽象为一个标识：getArea（）无需考虑算法细节。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Geometry{
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getArea</span>();
}
</code></pre><p><strong>第二步</strong>：Pillar（柱类）可以面向Geometry类编写代码，即Pillar（柱类）应当把Geometry类作为自己的成员，该成员可以调用Geometry的子类重写的getArea（）方法。这样，Pillar（柱类）就将计算底面积的任务指派个Geometry类的子类的实例，不再依赖于某一个具体的类，而是面向Geometry类的，即Pillar（柱类）的bottom是用抽象类Geometry声明的对象，而不是具体的某一类，新的Pillar（柱类）如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Pillar{
Geometry botom;
<span class="keyword">double</span> height;
Pillar(Geometry bottom, <span class="keyword">double</span> height){
    <span class="keyword">this</span>.bottom = bottom;
    <span class="keyword">this</span>.height = height;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVolume</span>(){
    <span class="keyword">return</span> bottom.getArea() * height;
}
}
</code></pre><p>在新增Geometry的子类时就不需要修改Pillar（柱类）的任何代码，只需要增加一个Triangle类（三角形）。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Geometry</span></span>{
<span class="keyword">double</span> a,b;
Circle(<span class="keyword">double</span> a, <span class="keyword">double</span> b){
    <span class="keyword">this</span>.a = a;
    <span class="keyword">this</span>.b = b;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span>(){
    <span class="keyword">return</span> (a*b);
}
}
</code></pre><p>应用：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Application{
<span class="keyword">public</span> state <span class="keyword">void</span> <span class="title">main</span>(String args[]){
    Pillar pillar;
    Geometry bottom;
    bottom = <span class="keyword">new</span> Circle(<span class="number">10</span>);             <span class="comment">//子类的上转型对象</span>
    pillar = <span class="keyword">new</span> Pillar(bottom, <span class="number">10</span>);
    System.<span class="keyword">out</span>.println(<span class="string">"圆柱体的体积"</span> + pillar.getVolume());
    bottom = <span class="keyword">new</span> Rectangle(<span class="number">10</span>,<span class="number">10</span>);
    pillar = <span class="keyword">new</span> Pillar(bottom, <span class="number">10</span>);
    System.<span class="keyword">out</span>.println(<span class="string">"矩形底的体积"</span> + pillar.getVolume());
}
}
</code></pre><p><strong>总结</strong>：面向抽象编程目的是为了应对用户需求的变化，将某个类中经常因需求变化而需要改变的代码从类中分离出去。其核心是让类中每种可能的变化对应的交给抽象类的一个子类去负责，从而让该类的设计者不去关心具体的实现，避免所设计的类依赖于具体的实现。</p>
<p><strong>关于抽象类</strong>：</p>
<ul>
<li>对于抽象类不能用new创建该类的对象，但可以成为其子类的上转型对象，从而该对象可以调用子类重写的方法。</li>
<li>一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法，给出方法体。</li>
</ul>
<p>　　</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　所谓面向抽象编程是指当设计某种重要的类时，不让该类面向具体的类，而是面向抽象类，及所设计类中的重要数据是抽象类声明的对象，而不是具体类声明的对象。就是利用abstract来设计实现用户需求。</p>
<p>比如：我们有一个Circle圆类，计算其面积。</p>
<pre]]>
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java--面向接口编程]]></title>
    <link href="http://yoursite.com/2014/12/25/java-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2014/12/25/java-面向接口编程/</id>
    <published>2014-12-25T12:58:46.000Z</published>
    <updated>2014-12-25T13:05:55.000Z</updated>
    <content type="html"><![CDATA[<p>　　之前看的一本书的笔记，上周再看设计模式的时候，想到了这篇之前在看某本书时候的笔记。</p>
<p>　　面向接口编程很重要的一点就是接口回调，用接口声明的变量称作接口变量，属于引用型变量，可以存放实现该接口的类的实例的引用，对象引用。<strong>接口回调</strong>：可以把实现某一接口的类创建的对象的引用赋值给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口方法。</p>
<p>Com com;      //接口<br>ImplCom object;    //实现接口的对象<br>com = object;        //接口回调，com会根据对象的不同而实现不同的接口方法，回调类重写的接口方法<br>接口和abstract类的比较如下：<br>abstract类和接口都可以有abstract方法。<br>接口中只可以有常量，不能有变量；而abstract类中既可以有常量也可以有变量。abstract类中也可以有非abstract方法，接口不可以。</p>
<p>　　在设计程序时应当根据具体的分析来确定是使用抽象类还是接口。abstract类除了提供重要的需要重写的abstract方法外，也提供了子类可以继承的变量和非abstract方法。如果某个重要问题需要使用继承才能更好地解决，比如，子类需要重写父类的abstract方法，还需要从父类继承一些变量或继承一些重要的非abstract方法，就可以考虑用abstract类。如果某个问题不需要继承，只是需要若干个类给出某些重要的abstract方法的实现细节，就可以考虑使用接口。<br>　　使用接口编程的最重要的<strong>核心思想就是使用接口回调</strong>，及接口变量存放实现该接口的类的对象的引用，从而接口变量就可以回调类实现的接口方法。<br>　　<img src="http://7te8s4.com1.z0.glb.clouddn.com/jiekou.jpg" alt="接口编程">　　</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Advertisement {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAdvertisement</span>();
    <span class="keyword">public</span> String <span class="title">getCorpName</span>();
}
</code></pre><p>2、设计AdvertisementBoard类（广告牌），该类有一个show（Advertisement adver）方法，该方法的参数是接口Advertisement的类型，显然该参数adver可以存放任何实现Advertisement接口的类的对象的引用，并回调类重写的接口方法showAdvertisement()来显示公司的广告词，回调类重写的接口方法getCorpName来获取公司名称。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> AdvertisementBoard{
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> (Advertisement adver){
    System.<span class="keyword">out</span>.println(adver.getCorpName()+<span class="string">"广告词"</span>);
    adver.showAdvertisement（）; <span class="comment">//接口回调</span>
}
}
</code></pre><p>实现接口的A公司类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Acorp implement Advertisement {
<span class="keyword">public</span> <span class="keyword">void</span> showAdvertisement（）{
    System.<span class="keyword">out</span>.println(<span class="string">"AAAAAAAAAAAAAAAAA"</span>);
}
<span class="keyword">public</span> String getCorpName（）{
    <span class="keyword">return</span> <span class="string">"A Corp"</span>;
}
}
</code></pre><p>实现接口的B公司类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Bcorp implement Advertisement {
<span class="keyword">public</span> <span class="keyword">void</span> showAdvertisement（）{
    System.<span class="keyword">out</span>.println(<span class="string">"BBBBBBBBBBBBBBBBB"</span>);
}
<span class="keyword">public</span> String getCorpName（）{
    <span class="keyword">return</span> <span class="string">"B Corp"</span>;
}
}
</code></pre><p>运行住程序：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> test （）{
<span class="keyword">public</span> state <span class="keyword">void</span> main （<span class="keyword">string</span> args[]）{
    AdvertisementBoard board = <span class="keyword">new</span> AdvertisementBoard();
    board.show(<span class="keyword">new</span> Acorp());
    board.show(<span class="keyword">new</span> Bcorp());
}
}
</code></pre><p>最后程序会根据对象的不同调用不同的方法。若想要添加C公司，只要实现接口的方法就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　之前看的一本书的笔记，上周再看设计模式的时候，想到了这篇之前在看某本书时候的笔记。</p>
<p>　　面向接口编程很重要的一点就是接口回调，用接口声明的变量称作接口变量，属于引用型变量，可以存放实现该接口的类的实例的引用，对象引用。<strong>接口回调</stron]]>
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式----建造者模式]]></title>
    <link href="http://yoursite.com/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2014/12/25/设计模式-建造者模式/</id>
    <published>2014-12-25T12:50:32.000Z</published>
    <updated>2014-12-25T12:57:37.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong></p>
<p>建造者模式：又叫生成器模式，就是对流程的抽象，一步一步的去创建一个复杂的对象。</p>
<p>举个实例，有一个化学老师需要在公开课上向校长等人演示摸个试管实验，老师请了两个同学A和B上台演示，ＡＢ的操作顺序都是一样的，只是试剂所放的量不一样而已，那么老师要如何控制这个学生呢？如果我们只是简单地定义两个学生类A和B的话，由于两个人的实验顺序（方法）是一样的，那么就很容易出错，搞错了顺序？或者漏掉某个步骤？</p>
<p><strong>解决</strong>：因为他们具有一样的组成成分，那么就可以让他们同时继承一个抽象接口，该接口提供他们所需要的步骤，以确保不会漏掉某步。因为子类必须实现抽象接口里的所有方法。</p>
<p>抽象接口类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Student {
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou1</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou2</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou3</span>();
}
</code></pre><p>学生A：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentA</span> <span class="keyword">extends</span> <span class="title">Student</span></span>{

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou1</span>() {
    System.out.println(<span class="string">"AAAAA"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou2</span>() {
    System.out.println(<span class="string">"BBBBBB"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou3</span>() {
    System.out.println(<span class="string">"CCCCCC"</span>);
}
}
</code></pre><p>学生B：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">Student</span></span>{
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou1</span>() {
    System.out.println(<span class="string">"OOOOO"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou2</span>() {
    System.out.println(<span class="string">"PPPPP"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou3</span>() {
    System.out.println(<span class="string">"QQQQQQ"</span>);
}
}
</code></pre><p>虽然保证了不会漏掉某部，但是还是无法保证学生能正确操作？这是就可以使用建造者模式，有老师来控制。</p>
<p>teacher类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Teacher {
<span class="keyword">private</span> Student student;
<span class="keyword">public</span> <span class="title">Teacher</span>(Student student) {
    <span class="keyword">this</span>.student = student;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DirectEx</span>() {
    student.buZou1();
    student.buZou2();
    student.buZou3();
}
}
</code></pre><p>主函数：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]) {
    Student studentA = <span class="keyword">new</span> StudentA();
    Student studentB = <span class="keyword">new</span> StudentB();
    Teacher teacher = <span class="keyword">new</span> Teacher(studentA);
    teacher.DirectEx();
    teacher = <span class="keyword">new</span> Teacher(studentB);
    teacher.DirectEx();
}
</code></pre><p>   <strong>总结</strong>：建造者模式就是当需要一个复杂对象的构建或者造作过程和这个对象的表示相分离，就可以使用了。就相当于A和 B是具体的创建者，知道怎么操作，但是学生不知道完成一次实验需要按照何种步骤来进行，而老师作为指挥者，了解实验步骤，可以指挥学生（按一定顺序调用学生类提供的方法）来实验，客户端就只需要关心结果就好了。使用这个模式，用户只要制定要创建的类型就可以得到对应的对象，为具体的过程被direct和builder影藏了。而这正体现了依赖倒转的原则，抽象不依赖于细节，细节依赖于抽象。</p>
<hr>
<p>建造者模式的<code>标准代码</code>：<br>Builder：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Builder {
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPartA</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPartB</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">getResult</span>();   
}
</code></pre><p>product：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Product {
    ArrayList&lt;String&gt; parts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(String part) {
        parts.add(part);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"create product"</span>);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.size(); i++) {
            String part = parts.<span class="keyword">get</span>(i) ;
            System.<span class="keyword">out</span>.println(part);
        }
    }
}
</code></pre><p>建造者类A：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilderA</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>{
<span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartA</span>() {
    product.add(<span class="string">"part A"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartB</span>() {
    product.add(<span class="string">"part B"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> Product <span class="title">getResult</span>() {
    <span class="keyword">return</span> product;
}
}
</code></pre><p>建造者B:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilderB</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>{

<span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartA</span>() {
    product.add(<span class="string">"part W"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartB</span>() {
    product.add(<span class="string">"part Q"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> Product <span class="title">getResult</span>() {
    <span class="keyword">return</span> product;
}
}
</code></pre><p>指挥者：这里控制之行动的顺序</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Director {
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span>(Builder builder){
    builder.builderPartA();
    builder.builderPartB();
}
}
</code></pre><p>客户端：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]) {
    Director director = <span class="keyword">new</span> Director();
    Builder builder = <span class="keyword">new</span> ConcreteBuilderA();
    Builder builder2 = <span class="keyword">new</span> ConcreteBuilderB();

    director.construct(builder);
    Product productA = builder.getResult();
    productA.show();
    director.construct(builder2);
    Product productB = builder2.getResult();
    productB.show();
}
</code></pre><p>  建造者优点：</p>
<p>1）在建造者模式中，客户端不必知道产品内部组成的具体细节，将产品本身于产品的创建过程进行解耦，是的相同的创建过程可以创建不同的产品对象。</p>
<p>2）每一个具体的建造者都是独立的，而与其他的具体建造者没有关系，可以很方便的去增加或者删除一个建造者，用户用不同的建造者就可以获得不同的产品。</p>
<p>3）可以更加精细的控制产品创建的具体过程，将复杂的产品步骤分解在不同的方法当中，是的创建过程更加清晰。</p>
<p>4）增加新的建造者不用修改原有类库的代码，指挥者类是针对抽象建造者类编写的，扩展方便，符合开放封闭原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong></p>
<p>建造者模式：又叫生成器模式，就是对流程的抽象，一步一步的去创建一个复杂的对象。</p>
<p>举个实例，有一个化学老师需要在公开课上向校长等人演示摸个试管实验，老师请了两个同学A和B上台演示，ＡＢ的操作顺序都是一样]]>
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式----原型模式]]></title>
    <link href="http://yoursite.com/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2014/12/25/设计模式-原型模式/</id>
    <published>2014-12-25T12:49:44.000Z</published>
    <updated>2014-12-25T12:50:02.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong></p>
<p><strong>原型模式</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。就是依托一个已经实例化的对象去创建另外一个可以进行定制的对象，而不需要知道创建过程的具体细节。本质特点：在不重新初始化的情况下动态获取对象在运行时的状态。</p>
<p>在Java中直接实现接口Cloneable接口就可以了，override其中clone方法，</p>
<p><strong>举个例子</strong>：在我们考证的时候，都要填写报名信息，每次都一样的，如果每次都要填写一样的信息会很烦，能不能写好一份后，以后不管什么考试都只要复制过去就好了呢？</p>
<p>报名信息类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestrationInfo</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>{
<span class="keyword">private</span> String name;
<span class="keyword">private</span> String birthday;
<span class="keyword">private</span> String school;
<span class="keyword">private</span> String ID;

<span class="keyword">public</span> <span class="title">RestrationInfo</span>(String name){
    <span class="keyword">this</span>.name = name;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span>(String birthday) {
    <span class="keyword">this</span>.birthday = birthday;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchool</span>(String school) {
    <span class="keyword">this</span>.school = school;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setID</span>(String iD) {
    ID = iD;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>(){
    System.out.println(<span class="string">"name:"</span>+name);
    System.out.println(<span class="string">" birthday:"</span>+ birthday);
    System.out.println(<span class="string">"school:"</span>+school);
    System.out.println(<span class="string">"ID:"</span>+ID);
}
<span class="annotation">@Override</span>
<span class="keyword">protected</span> Object <span class="title">clone</span>() <span class="keyword">throws</span> CloneNotSupportedException {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> <span class="keyword">super</span>.clone();
    } <span class="keyword">catch</span> (CloneNotSupportedException e) {
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

}
}
</code></pre><p>客户端：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> MyMain {

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    System.<span class="keyword">out</span>.println(<span class="string">"cet 4"</span>);
    RestrationInfo restrationInfo = <span class="keyword">new</span> RestrationInfo(<span class="string">"wang"</span>);
    restrationInfo.setBirthday(<span class="string">"XXXx"</span>);
    restrationInfo.setID(<span class="string">"dfd"</span>);
    restrationInfo.setSchool(<span class="string">"dfd"</span>);
    restrationInfo.show();

    System.<span class="keyword">out</span>.println(<span class="string">"cet 6"</span>);
    RestrationInfo restrationInfo2 = (RestrationInfo) restrationInfo.clone();
    restrationInfo2.show();
}
}
</code></pre><p>　　这样就实现了一份信息，一直使用。如果我们只是简单的每次new一个对象的，就每次都要执行构造函数，如果构造函数复杂，就会影响到性能。在信息没有变化的情况下，复制是最好的解决方案。</p>
<p>　　<strong>问题</strong>：调用一个函数操作某对象的时候，常常会使得改对象陷入不可用的状态（不稳定状态），等操作结束后才会重新回到完全可用的状态。如果有线程企图访问一个处于不可用状态的对象，改对象会发生不能正确不相应的情况，由此会产生无法预料的后果。对一个实力对象进行克隆的时候，如果恰巧在多线程的情况下且该对象处于不稳定状态，那么克隆可能就会失败。所以说原型模式在实现时不是线程安全的。一定要在其属于稳定的情况下克隆。</p>
<p>　　<strong>问题</strong>：复制的深度，clone对于值类型的字段会逐位复制，而对于引用型的变量会复制引用但是不复制引用的对象，所以原始的对象和它的副本都引用同一个对象。这就是浅复制——被复制的对象的变量都与原来对象有相同的值，而所有的其他对象的引用都依然指向原来的对象。</p>
<p>　　也就是说如果我在报名信息里添加了地址信息，地址是一个单独的类，在复制报名信息的同时也要复制报名信息所引用的地址对象，使得报名信息对象的副本引用的是原国籍对象的副本。即让地址类也实现原型模式，实现Cloneable接口。</p>
<p>地址类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>{
<span class="keyword">private</span> String city;

<span class="keyword">public</span> String <span class="title">getCity</span>() {
    <span class="keyword">return</span> city;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span>(String city) {
    <span class="keyword">this</span>.city = city;
}
<span class="annotation">@Override</span>
<span class="keyword">protected</span> Object <span class="title">clone</span>() {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> <span class="keyword">super</span>.clone();
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

}
}
</code></pre><p>修改后报名信息类：</p>
<pre><code><span class="keyword">protected</span> Object <span class="title">clone</span>()  {
<span class="comment">//      try {</span>
<span class="comment">//          return super.clone();</span>
<span class="comment">//      } catch (CloneNotSupportedException e) {</span>
<span class="comment">//          return null;</span>
<span class="comment">//      }</span>
    RestrationInfo objInfo = <span class="keyword">new</span> RestrationInfo(<span class="keyword">this</span>.address);
    objInfo.name = <span class="keyword">this</span>.name;
    objInfo.ID = <span class="keyword">this</span>.ID;
    objInfo.birthday=<span class="keyword">this</span>.birthday;
    objInfo.school = <span class="keyword">this</span>.school;
    <span class="keyword">return</span> (Object)objInfo;
}

<span class="keyword">private</span> Address address;
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span>(Address address){
    <span class="keyword">this</span>.address = address;
}
<span class="comment">//just for clone private gouzao</span>
<span class="keyword">private</span> <span class="title">RestrationInfo</span>(Address address) {
    <span class="keyword">this</span>.address = address;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong></p>
<p><strong>原型模式</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。就是依托一个已经实例化的对象去创建另外一个可以进行定制的对象，而不需要知道创建过程的具体细节。本质特点：在]]>
    </summary>
    
      <category term="Design pattern" scheme="http://yoursite.com/tags/Design-pattern/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式----单例模式]]></title>
    <link href="http://yoursite.com/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2014/12/25/设计模式-单例模式/</id>
    <published>2014-12-25T12:38:02.000Z</published>
    <updated>2014-12-25T12:45:46.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong></p>
<p>　　单例模式是某个类只需要一个实例，保证一个类有且只有一个实例，并提供一个访问他的全局访问点。比如对于一个统一的数据库的访问，在整个项目中只使用同一个实例。对于这种情况有个比较好的例子，就是一夫一妻制。</p>
<p>　　比如某个男子需要娶个女子结婚，那么就有下面的程序：wife类，代表女子，husband类，代表男子　</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Wife {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"the girl show themself"</span>);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"the girl gets married"</span>);
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> Husband {
    <span class="keyword">private</span> Wife myWife = <span class="keyword">null</span>;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chooseGirl</span>() {
    myWife = <span class="keyword">new</span> Wife();
    myWife.show();
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMarry</span>() {
        myWife.marry();
    }
}
</code></pre><p>在主程序里就可以实例化husband类，然后依次调用chooseGirl()和getmarry（）方法，就可以正常运行。但是如果先调用getMarry（）呢？由于wife在choose里面实例化的，这是就会报错，将husband类修改如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chooseGirl</span>() {
    <span class="keyword">if</span> (myWife == <span class="keyword">null</span>) {
        myWife = <span class="keyword">new</span> Wife();
    }
    myWife.show();
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMarry</span>() {
    <span class="keyword">if</span> (myWife == <span class="keyword">null</span>) {
        myWife = <span class="keyword">new</span> Wife();
    }
    myWife.marry();
}
</code></pre><p>　　这样一来就可以保证一个丈夫只能有一个妻子了。而且两个函数没有调用的先后关系。</p>
<p><strong>问题一</strong>：如果婆婆想要看儿媳妇呢？那就会有一个婆婆类，婆婆类里面又需要实例化一个wife类，这个实例化的wife类和husband的里面实例化的wife类是不同的，出现了多个实例化的问题，也就是婆婆看到的和儿子娶的不是同一个姑娘，这怎么行呢？这就需要修改wife类的代码，保证只有一个实例出现。<br>wife类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Wife {
    <span class="keyword">public</span> <span class="keyword">static</span> Wife wife;  <span class="comment">//静态变量</span>
    <span class="keyword">private</span> <span class="title">Wife</span>(){          <span class="comment">//私有构造方法，是的外部无法访问</span>
    }
    <span class="keyword">public</span> <span class="keyword">static</span> Wife <span class="title">getInstance</span>(){  <span class="comment">//静态方法来实例化</span>
        <span class="keyword">if</span> (wife == <span class="keyword">null</span>) {
            wife = <span class="keyword">new</span> Wife();
        }
        <span class="keyword">return</span> wife;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"the girl show themself"</span>);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"the girl gets married"</span>);
    }
}
</code></pre><p>　　将构造函数设为私有，声明静态变量wife和静态方法getinstance来进行实例化。在需要实例化的地方用Wife wife=Wife.getInstance()来获得实例，就可以保证大家看到的是同一个姑娘。</p>
<p><strong>问题二</strong>：如果婚礼现场需要直播，怎么办？可以使用多线程技术，一个线程A作为实地的婚礼，在wife中调用marry方法，另一个线程B作为直播，同样在线程中调用marry的，那么怎么能确定getInstance得到的是同一个新娘呢？如果线程A先运行到此，这是wife为null，那么进入到分支实例化wife，在未完成实例化的时候，线程B也来到了分支内，此时wife依然为null，线程B又会进行一次实例化，最终还是产生了两个实例，就是两个不同的新娘。</p>
<p><strong>解决</strong>：引入<code>锁</code>的概念，lock的作用就是构造出一块临界区来控制线程对代码的访问，确保每次只有一个线程运行到临界区的代码，其他线程运行到临界区时，将会一直等待直到前面的线程运行出临界区为止。</p>
<p>在wife中修改代码：在if前加锁</p>
<pre><code><span class="keyword">lock</span>.<span class="keyword">lock</span>();
<span class="keyword">if</span> (wife == <span class="keyword">null</span>) {
    wife = <span class="keyword">new</span> Wife();
}
<span class="keyword">lock</span>.unlock();
</code></pre><p>这样就能保证在A实例化之前B不会进行null的判断。这样虽然满足了功能的要求，可是每次调用的getInstance的时候都要进行加锁工作，这将会影响程序的性能。所以对其进行改良。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> Wife <span class="title">getInstance</span>(){  <span class="comment">//静态方法来实例化</span>
    <span class="keyword">if</span> (wife == <span class="keyword">null</span>) {
        <span class="keyword">lock</span>.<span class="keyword">lock</span>();
        <span class="keyword">if</span> (wife == <span class="keyword">null</span>) {
            wife = <span class="keyword">new</span> Wife();
        }
        <span class="keyword">lock</span>.unlock();
    }
    <span class="keyword">return</span> wife;
}
</code></pre><p>在临界区内在进行一次null的判断，只有wife为null的时候才会进入初始化。<br><strong>单例模式本身的代码</strong>：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">public</span> <span class="keyword">static</span> Singleton singleton;  <span class="comment">//静态变量</span>
    <span class="keyword">private</span> <span class="title">Singleton</span>(){ 
               <span class="comment">//私有构造方法，是的外部无法访问  </span>
    }
    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(){  <span class="comment">//静态方法来实例化</span>
        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {
            singleton = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> singleton;
    }
}
</code></pre><p>客户端代码：</p>
<pre><code>Singleton <span class="variable">singleton1 =</span> Singleton.getInstance();
Singleton <span class="variable">singleton2 =</span> Singleton.getInstance();
<span class="keyword">if</span>(<span class="variable">singleton1 =</span>= singleton2){
    System.out.printle(<span class="string">"the teo object are the same one"</span>);
}
</code></pre><p>单例模式虽然很简单，但很实用，以下情况都适合实用：</p>
<p>1）当类只能有一个实例而且第三方可以从一个公共的访问点访问它时</p>
<p>2）当一个唯一的实例可以通过子类化来扩展，而且第三方需要在不更改代码的情况下就能实用一个扩展的实例时。</p>
<p>单例模式<strong>优点</strong>：</p>
<p>1）队唯一的实例做出访问控制</p>
<p>2）允许改变实例的个数，可以增加一个计数器来控制实例的个数，从而有双例模式，三利模式等。</p>
<p><strong>总结</strong></p>
<p>　　单例并不是上面写的这么简单，里面涉及到很多的知识点，多线程、加锁、私有构造函数，静态构造函数，静态字段，readonly和const的区别等等。</p>
<p>　　向这里给出的单例版本就涉及到线程安全的问题，当2个请求同时方式这个类的实例的时候，可以会在同一时间点上都创建一个实例，虽然一般不会出异常错误，但是起码不是我们谈论的只保证一个实例了。每一个设计模式都值得我们深入的研究下去，有时间一定回头看看。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong></p>
<p>　　单例模式是某个类只需要一个实例，保证一个类有且只有一个实例，并提供一个访问他的全局访问点。比如对于一个统一的数据库的访问，在整个项目中只使用同一个实例。对于这种情况有个比较好的例子，就是一夫一妻制。</p>
<]]>
    </summary>
    
      <category term="Design pattern" scheme="http://yoursite.com/tags/Design-pattern/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式---工厂模式]]></title>
    <link href="http://yoursite.com/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2014/12/25/设计模式-工厂模式/</id>
    <published>2014-12-25T12:36:42.000Z</published>
    <updated>2014-12-25T12:37:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong>       </p>
<p>　　工厂方法模式属于类的创建行模式又被称为多态工厂模式。工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，核心工厂类将不在负责产品的创建，这昂核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口。</p>
<p>　　简单工厂模式又叫静态工厂模式，由一个工厂决定创建出哪一种商品的实例。只要输入想要的产品代号，就会实例化合适的对象。</p>
<p>　　这里举个简单的例子：<br>　　小张开了一家面包店，根据客人的不同需求提供不同的面包，这里就有不同的面包师傅做不同的面包，这些个面包师傅（HoneyBread、BlackBread）等又归一个总师傅管理BreadMaker，也就是这些师傅的手艺都是继承自该师傅，这个厨房后台呢，就相当于一个工厂（IFactory），不同的种类就由不同的工厂（HoneyFactory）生产，工厂会根据需求将不同的种类产品分给不同种类的总师傅（PizzaMaker、BreadMaker），在由师傅分配任务给不同的制作师。上诉流程就将整个工厂模型的思路理清了。</p>
<p>简单工厂类：</p>
<pre><code>package com.hust.SimpleFactory;
<span class="keyword">public</span> <span class="keyword">class</span> BreadFactory {
    <span class="keyword">public</span> <span class="keyword">static</span> BreadMaker <span class="title">MakeBread</span>(<span class="keyword">int</span> breadType){
         BreadMaker breadMaker = <span class="keyword">null</span>;
        <span class="keyword">switch</span> (breadType) {
        <span class="keyword">case</span> <span class="number">1</span>:
            breadMaker = <span class="keyword">new</span> BlackBread();
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">2</span>:
            breadMaker =  <span class="keyword">new</span> HoneyBread();
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">3</span>:
            breadMaker =  <span class="keyword">new</span> WhiteBread();
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="keyword">break</span>;
        }
        <span class="keyword">return</span> breadMaker;
    }
}
</code></pre><p>总师傅：</p>
<pre><code>package com.hust.SimpleFactory;
<span class="keyword">public</span> <span class="keyword">class</span> BreadMaker {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetBread</span>(){
    <span class="comment">//nothing</span>
    }
}
</code></pre><p>不同的面包师傅：</p>
<pre><code><span class="keyword">package</span> com.hust.SimpleFactory;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackBread</span> <span class="keyword">extends</span> <span class="title">BreadMaker</span> </span>{
    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">GetBread</span>() {
        System.out.println(<span class="string">"做出黑面包"</span>);;
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneyBread</span> <span class="keyword">extends</span> <span class="title">BreadMaker</span> </span>{
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetBread</span>() {
        System.out.println(<span class="string">"做出蜂蜜面包"</span>);
    }
}
</code></pre><p>商店前台：</p>
<pre><code>public static void main(String args[]) {
    B<span class="built_in">read</span>Maker breadMaker;
    System.out.println(<span class="string">"面包店开业！"</span>);
    System.out.println(<span class="string">"开始制作黑面包"</span>);
    breadMaker = B<span class="built_in">read</span>Factory.MakeB<span class="built_in">read</span>(<span class="number">1</span>);
    breadMaker.GetB<span class="built_in">read</span>();
    System.out.println(<span class="string">"开始制作蜂蜜面包"</span>);
    breadMaker = B<span class="built_in">read</span>Factory.MakeB<span class="built_in">read</span>(<span class="number">2</span>);
    breadMaker.GetB<span class="built_in">read</span>();
    System.out.println(<span class="string">"开始制作白面包"</span>);
    breadMaker = B<span class="built_in">read</span>Factory.MakeB<span class="built_in">read</span>(<span class="number">3</span>);
    breadMaker.GetB<span class="built_in">read</span>();
}
</code></pre><p>工厂模式：除了上诉内容外增加了一个总工厂负责类：</p>
<pre><code><span class="keyword">package</span> com.hust.Factory;
<span class="keyword">import</span> com.hust.AbstractFactory.PizzaMaker;
<span class="keyword">import</span> com.hust.SimpleFactory.BreadMaker; 
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>{
    BreadMaker createBread();
    PizzaMaker createPizza();
}
</code></pre><p>不同的工厂类：如果增加pizza这个产品，就在总工厂里增加一个函数负责pizza（这就是抽象工厂模式）</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneyFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> BreadMaker <span class="title">createBread</span>() {
        <span class="keyword">return</span> <span class="keyword">new</span> HoneyBread();
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> PizzaMaker <span class="title">createPizza</span>() {
        <span class="keyword">return</span> <span class="keyword">new</span> HoneyPizza();
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> BreadMaker <span class="title">createBread</span>() {
        <span class="keyword">return</span> <span class="keyword">new</span> BlackBread();
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> PizzaMaker <span class="title">createPizza</span>() {
        <span class="keyword">return</span> <span class="keyword">new</span> BlackPizza();
    }
 }
</code></pre><p>工厂模式时的柜台操作：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]) {
    BreadMaker breadMaker;
    System.<span class="keyword">out</span>.println(<span class="string">"面包店开业！"</span>);
    System.<span class="keyword">out</span>.println(<span class="string">"开始制作黑面包"</span>);
    IFactory breadFactory = <span class="keyword">new</span> BlackBreadFactory();
    breadMaker = breadFactory.createBread();
    breadMaker.GetBread();
    System.<span class="keyword">out</span>.println(<span class="string">"开始制作蜂蜜面包"</span>);
    breadFactory = <span class="keyword">new</span> HoneyBreadFactory();
    breadMaker = breadFactory.createBread();
    breadMaker.GetBread();
    system.<span class="keyword">out</span>.println(<span class="string">"开始制作蜂蜜pizza"</span>);
    breadFactory = <span class="keyword">new</span> HoneyBreadFactory();
    PizzaMaker pizzaMaker = breadFactory.createPizza();
    pizzaMaker.GetPizza();
}
</code></pre><p>不同的产品的师傅：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaMaker</span> </span>{
    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">GetPizza</span>() {
        <span class="comment">//nothing</span>
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneyPizza</span> <span class="keyword">extends</span> <span class="title">PizzaMaker</span> </span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPizza</span>() {
    <span class="comment">// TODO Auto-generated method stub</span>
    System.out.println(<span class="string">"做出蜂蜜披萨"</span>);
    }
}
</code></pre><p>　　问题：假设小张有很多分店，每个分店有不同的柜台，那天小张决定将黑巧克力面包改成抹牛油的，在修改了工厂之后，必须相应的修改柜台的代码，级每一个申明过breadMaker和pizzaMaker的地方都要修改，那么工作量将恨大。这就体现了抽象模式的缺点，便于交换产品的同时，也需要改动产品声明过的地方。如何避免呢？一种方法就是根据前台用户的输入，使用if switch语句进行判断，但随着产品的增长，分支会越来越多。那么客户端还是需要大量的修改。另一种方法就是——反射。对客户端代码修改如下：</p>
<pre><code><span class="keyword">try</span> {
    <span class="keyword">Class</span>&lt;?&gt; c = <span class="keyword">Class</span>.forName(<span class="string">"HoneyBreadFactory"</span>);
    <span class="keyword">try</span> {
        breadFactory = (IFactory) c.newInstance();
        pizzaMaker = breadFactory.createPizza();
        pizzaMaker.GetPizza();
    } <span class="keyword">catch</span> (Exception e) {
            <span class="comment">// TODO: handle exception</span>
    }
} <span class="keyword">catch</span> (ClassNotFoundException e) {
        <span class="comment">// TODO: handle exception</span>
}
</code></pre><p>这样就避免了分支的出现。<br>这里提到了三个工厂模式：<strong>简单工厂</strong>、<strong>工厂方法</strong>、<strong>抽象工厂</strong>。他们的优缺点如下：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/gcmsdb.jpg" alt="工厂模式"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong>       </p>
<p>　　工厂方法模式属于类的创建行模式又被称为多态工厂模式。工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，核心工厂类将不在负责产品的创建，这昂核心类成为一个抽象工厂角]]>
    </summary>
    
      <category term="Design pattern" scheme="http://yoursite.com/tags/Design-pattern/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式---设计原则]]></title>
    <link href="http://yoursite.com/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2014/12/25/设计模式-设计原则/</id>
    <published>2014-12-25T09:42:49.000Z</published>
    <updated>2014-12-25T09:57:16.000Z</updated>
    <content type="html"><![CDATA[<p>　　设计模式是一种设计思想，一种解决方案，能够做到代码的可复用性。这段时间利用空余的时间，在复习java的同时，学习设计模式。记录过程的一点体会。<br>　　<br>1）<strong>单一职责原则</strong></p>
<p>　　<em>问题由来</em>：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p>
<p>　　<em>解决方案</em>：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p>
<p>　　如果一个类具有很多不同的功能，比如超人拥有很多的技能，当我们想对其中一种技能进行修改或者升级的时候就不得不停止超人其他的功能，而这期间如果有事情发生，超人是无法提供帮助的，那么是否可以让超人简单点呢？在维护世界和平的时候，也能够帮助人们除草呢？</p>
<p>　　这就是单一职责——对于一个类，应该只有一个引起她变化的原因。实际上，往往会碰到职责分块的问题，会遇到将职责A划分为职责A1和A2，这时就需要重新设计类，尽量降低类的复杂度，提高类的可读性。</p>
<p><em>遵循单一职责原的优点有</em>：</p>
<p>（1）可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</p>
<p>（2）提高类的可读性，提高系统的可维护性；</p>
<p>（3）变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<p>2）<strong>里氏代换原则</strong></p>
<p>　　<em>问题由来</em>：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p>　　<em>解决方案</em>：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>
<p>　　反映父类和子类的关系。B类继承A类，属于B的对象就具有A类的全部属性和方法。里氏代换的原则就是：子类型必须能够完全替换掉他们的父类型。即子类可以以父类的身份出现，并且不影响程序的功能时父类才能真正得到复用。所有引用基类的地方必须能透明地使用其子类的对象。通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>3）<strong>开放-封闭原则</strong></p>
<p>　　<em>问题由来</em>：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<p>　　<em>解决方案</em>：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>　　在面向对象编程时，如果要实现一个新的功能，添加一个新类来完成往往要比修改现有的类更加方便和安全。封装变化，降低耦合。OCP的原则是：程序的实体对象（模块、类、函数）应该可以进行扩张，但不应该可以修改。对于扩展是开放的，对于修改是封闭的。绝对的封闭很难做到，那么在面对需求变化时，设计人员就应该对自己设计的模块决定选择哪种变化封闭，保证无需对原码进行修改。</p>
<p>　　具体的实现就是<code>面向抽象编程</code>，继承抽象父类，通过重写其方法来改变固有行为，从实现新的扩展方法。</p>
<p>4）<strong>依赖倒转原则</strong></p>
<p>　　<em>问题由来</em>：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
<p> 　　<em>解决方案</em>：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<p>　　定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。核心思想是面向接口编程。</p>
<p>　　程序的高层模块不应该依赖于低层模块，但两者都应依赖于抽象：抽象不应该依赖于具体细节，而细节应该依赖于抽象，简而言之就是针对接口编程，不应该是针对实现编程。即通过抽象（接口或抽象类）是各个类或模块的实现彼此独立，不互相影响。程序的依赖关系终止于接口或抽象。</p>
<p>5）<strong>合成聚合复用原则</strong></p>
<p>　　尽量不使用类继承，而尽量使用合成/聚合。聚合是一种比较弱的拥有关系，具体表现是甲对象中可以包括乙对象，但乙对象不是甲对象的一部分；合成则是一种比较强的拥有关系，体现的是严格整体和部分的关系，并且整体和部分有相同的生命周期。如果两个类的关系是Has-a，则不应该设计成继承。这个原则有一个去缺点，就是系统中会有很多对象需要管理。</p>
<p>6）<strong>迪米特法则</strong></p>
<p>　　也叫做最少知识原则，一个对象尽可能少的了解其他对象，不和陌生人说话。每个类要尽可能的减少对其他类的依赖，不希望类之间建立直接的接触，如果需要接触则希望通过友元类（第三方）来传达（转发调用），这样会导致系统中存在大量的友元类。</p>
<p>　　<em>问题由来</em>：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>　　<em>解决方案</em>：尽量降低类与类之间的耦合。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　设计模式是一种设计思想，一种解决方案，能够做到代码的可复用性。这段时间利用空余的时间，在复习java的同时，学习设计模式。记录过程的一点体会。<br>　　<br>1）<strong>单一职责原则</strong></p>
<p>　　<em>问题由来</em>：类T负责两]]>
    </summary>
    
      <category term="Design pattern" scheme="http://yoursite.com/tags/Design-pattern/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JUnit单元测试--小试牛刀]]></title>
    <link href="http://yoursite.com/2014/12/25/JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://yoursite.com/2014/12/25/JUnit单元测试-小试牛刀/</id>
    <published>2014-12-25T07:51:46.000Z</published>
    <updated>2014-12-25T14:03:37.000Z</updated>
    <content type="html"><![CDATA[<p>单元测试更多的是在开发阶段完成，开发人员每写一个函数的时候都会写相应的单元测试。对于java代码，普遍使用的是jUnit，根据jUnit可以自己相应的开发一套自动化测试框架。这个的前提是要学会junit，先知道怎么用，才能知道怎么为我所用。</p>
<p>学习JUnit的操作很简单，JUnit是一个敏捷编程的开发框架，他的设计很值得学习。这也是我学习JUnit的原因。</p>
<p>JUnit最大的特点就是：各个方法之间是独立的，一个方法的失败不会影响另一个方法的执行。</p>
<p>JUnit 3：是基于反射机制的方法，有命名的约束，必须以test开头。每一个类都继承了TestCase类，而TestCase的父类是Assert类。即所有测试类都是TestCase类的子类。</p>
<p>JUnit 4：引入了注解(annotation)，通过解析注解就可以为测试提供相应的信息。@Test表明这是要执行的测试方法，不管测试方法的名字是什么，都会执行。每一个类可以不继承任何类，可以是一个普通类也可以去继承一个类或实现一个接口，要实现测试只需要在要测试的方法之前加@Test注释就可以了，但是仍然可以直接使用断言，静态导入import static org.junit.Assert.*；</p>
<p>为了更好地理解junit测试用例，我找了一个简单的例子来练习：</p>
<p>例如有这么一个类Greeting，根据每天不同的时间来返回不同的问候语：</p>
<pre><code><span class="keyword">package</span> com.test.one;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>{
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_MORNING = <span class="string">"Good Morning Sunshine!"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_AFTERNOON = <span class="string">"Just a few more hours before quiting time!"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING_EVENING = <span class="string">"I am outta here"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HOUR_MORNING = <span class="number">12</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HOUR_AFTERNOON = <span class="number">17</span>;
  <span class="keyword">private</span> java.sql.Timestamp iGreetingTime = <span class="keyword">null</span>;
  <span class="keyword">public</span> <span class="title">Greeting</span>(){
    <span class="keyword">this</span>(System.currentTimeMillis());
  }
  <span class="keyword">public</span> <span class="title">Greeting</span>(<span class="keyword">long</span> greetingTime) {
    <span class="keyword">super</span>();
    iGreetingTime = <span class="keyword">new</span>  java.sql.Timestamp(greetingTime);
}
  <span class="keyword">public</span> String <span class="title">getGreeting</span>(){

    <span class="keyword">if</span>(iGreetingTime.getHours()&lt;MAX_HOUR_MORNING){
        <span class="keyword">return</span> GREETING_MORNING;
    }<span class="keyword">else</span> <span class="keyword">if</span> (iGreetingTime.getHours()&lt;MAX_HOUR_AFTERNOON) {
        <span class="keyword">return</span> GREETING_AFTERNOON;
    }<span class="keyword">else</span> {
        <span class="keyword">return</span> GREETING_EVENING;
    }
  }
}
</code></pre><p>我们需要测试这个类，看是否可以根据时间的不同，来呈现不同的问候语。创建junit的测试用例需要遵循一下几点：</p>
<p>1、Junit类需继承TestCase<br>2、setUp（）和setDown（）为每个方法准备或销毁测试装备<br>3、创建public的方法，方法名为test开头，如testMorningGreeting（），使用assert判断实际返回的值和期望。<br>4、super（testMethod）为每个测试方法生成实例。首先执行setUp()，然后执行testMethod ，最后执行tearDown（）。</p>
<pre><code><span class="keyword">package</span> com.test.test;

<span class="keyword">import</span> java.sql.Time;

<span class="keyword">import</span> com.test.one.Greeting;

<span class="keyword">import</span> junit.framework.TestCase;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>{

    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span>() <span class="keyword">throws</span> Exception {
        <span class="keyword">super</span>.setUp();
    }

    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span>() <span class="keyword">throws</span> Exception{
        <span class="keyword">super</span>.tearDown();
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMorningGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the morning greeting expected"</span>, Greeting.GREETING_MORNING, greeting.getGreeting());
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAfternoonGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the Afternoon greeting expected"</span>, Greeting.GREETING_AFTERNOON, greeting.getGreeting());
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEveningGreeting</span>() <span class="keyword">throws</span> Exception {
        Time time = <span class="keyword">new</span> Time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>);
        Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
        assertEquals(<span class="string">"the Evening greeting expected"</span>, Greeting.GREETING_EVENING, greeting.getGreeting());
    }

    <span class="keyword">public</span> <span class="title">GreetingTest</span>(String testMethod){
        <span class="keyword">super</span>(testMethod);
    }
}
</code></pre><p>这个只是单个测试用例，junit也提供了测试套件组织想要执行的测试用例。</p>
<p>如果你已经有了两个测试用例，AddJobCmdImpTest、RemoveJobCmdImpTest等TestCase的子类别，如果想一次运行这两个测试，需要使用AllTest的类，代表一个测试套件。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> AllTest {
<span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span>(){
    TestSuite suite = <span class="keyword">new</span> TestSuite(<span class="string">"Test for XXXX"</span>);
    suite.addTest(<span class="keyword">new</span> TestSuite(AddJobCmdImpTest.class));
    suite.addTest(<span class="keyword">new</span> TestSuite(RemoveJobCmdImpTest.class));
    <span class="keyword">return</span> suite;
}
}
</code></pre><p>以下是JUnit4的代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>{

<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span>() <span class="keyword">throws</span> Exception {
    <span class="keyword">super</span>.setUp();

}
<span class="annotation">@After</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span>() <span class="keyword">throws</span> Exception{
    <span class="keyword">super</span>.tearDown();
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ttrestMorningGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the morning greeting expected"</span>, Greeting.GREETING_MORNING, greeting.getGreeting());
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAfternoonGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the Afternoon greeting expected"</span>, Greeting.GREETING_AFTERNOON, greeting.getGreeting());
}
 <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEveningGreeting</span>() <span class="keyword">throws</span> Exception {
    Time time = <span class="keyword">new</span> Time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>);
    Greeting greeting  = <span class="keyword">new</span> Greeting(time.getTime());
    assertEquals(<span class="string">"the Evening greeting expected"</span>, Greeting.GREETING_EVENING, greeting.getGreeting());
}
}
</code></pre><p>关于JUnit4的一些知识点：<br>1）、<strong>注释</strong></p>
<p>@Before    ：用于方法注释，表示该方法在每个测试方法执行前执行一次，可用于一些初始工作<br>@BeforeClass    ：用于方法注释，该方法在所有测试方法运行前运行，且只运行一次，添加该注释的方法必须修饰为 public static void 且没有参数。<br>@Test    ：方法注释，表示测试方法。该方法有两个属性 </p>
<ul>
<li>expected :该属性表示测试方法必须抛出一个异常，且异常的类型必须是该属性要求的类型，否则表示测试方法失败。也叫做异常测试。 例如：@Test(expected=IndexOutOfBoundsException.class) </li>
<li>b:timeout 用于超时测试，表示该测试方法的执行时间如果超过了要求的时间则失败 单位为毫秒<br>例如：@Test(timeout=100)</li>
</ul>
<p>@Ignore    ：方法注释，表示会被忽略的测试方法<br>@After    ：方法注释，被注释的方法会在每个测试方法执行完成之后执行一次，如果其它的方法抛出了异常，该方法同样会被执行。主要用于释放在@Before：方法中初始化的资源。<br>@AfterClass    ：方法注释，功能同@After，只不过是该方法释放的是@BeforeClass ：初始化的资源。且在所有的测试方法执行完成之后，只执行一次。</p>
<p>一个JUnit 4 的单元测试用例执行顺序为：<br>@BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass </p>
<p>2）、<strong>failure 和error</strong><br>　　failure：是由于预期的结果和实际运行结果不同而导致的，例如当使用assertEqual（）或其它assertXXX（）方法断言失败时，就会报出failure，如果发现failure，你就要去检查你的测试方法或者是被测试方法中的填写的逻辑是否有误。简单点，就是预想到的。</p>
<p>　　error：是填写程序是没有考虑到的问题，在执行测试的断言之前，程序就因为某种类型的意外而停止，比如说我们在操作数组的时候，因为存取超出索引就会引发ArrayIndexOutOfBoundsException，这时程序就会报error，程序将无法运行下去，提前结束，这个时候就要检查被测试方法中是否由欠缺考虑的地方。简单点，就是预想不到的，没有执行到断言。</p>
<p>　　JUnit4是JUnit框架有史以来的最大改进，其主要目标便是利用Java5的Annotation特性简化测试用例的编写。Annotation翻译成元数据。元数据是什么？元数据就是描述数据的数据。也就是说，这个东西在Java里面可以用来和public、static等关键字一样来修饰类名、方法名、变量名。修饰的作用描述这个数据是做什么用的，差不多和public描述这个数据是公有的一样。</p>
<p>@Test(expected=*.class)<br>　　在JUnit4.0之前，对错误的测试，我们只能通过fail来产生一个错误，并在try块里面assertTrue（true）来测试。现在，通过@Test元数据中的expected属性。expected属性的值是一个异常的类型</p>
<p>@Test(timeout=xxx):<br>　　该元数据传入了一个时间（毫秒）给测试方法，如果测试方法在制定的时间之内没有运行完，则测试也失败。</p>
<p>@ignore：<br>　　该元数据标记的测试方法在测试中会被忽略。当测试的方法还没有实现，或者测试的方法已经过时，或者在某种条件下才能测试该方法（比如需要一个数据库联接，而在本地测试的时候，数据库并没有连接），那么使用该标签来标示这个方法。同时，你可以为该标签传递一个String的参数，来表明为什么会忽略这个测试方法。比如：@lgnore(“该方法还没有实现”)，在执行的时候，仅会报告该方法没有实现，而不会运行测试方法。</p>
<p>@RunWith(Parameterized.class) 参数化测试。<br>　　你可能遇到过这样的函数，它的参数有许多特殊值，或者说他的参数分为很多个区域。比如，一个对考试分数进行评价的函数，返回值分别为“优秀，良好，一般，及格，不及格”，因此你在编写测试的时候，至少要写5个测试，把这5中情况都包含了，这确实是一件很麻烦的事情。只写一个测试函数，把这若干种情况作为参数传递进去，一次性的完成测试。</p>
<pre><code>@RunWith(Parameterized.class)
public class SquareTest <span class="keyword">...</span>{
    private static Calculator calculator = new Calculator();
    private int param;
    private int result;    
    @Parameters   
    public static Collection data() <span class="keyword">...</span>{
       <span class="keyword">return</span> Arrays.asList(new Object[][]<span class="keyword">...</span>{
            <span class="keyword">...</span>{<span class="number">2</span>, <span class="number">4</span>},
            <span class="keyword">...</span>{<span class="number">0</span>, <span class="number">0</span>},
            <span class="keyword">...</span>{－<span class="number">3</span>, <span class="number">9</span>},
        });
    }
    //构造函数，对变量进行初始化
    public SquareTest(int param, int result) <span class="keyword">...</span>{
        this.param = param;
        this.result = result;
    }
    @Test   
    public void square() <span class="keyword">...</span>{
      　calculator.square(param);
        assertEquals(result, calculator.getResult());
    }
}
</code></pre><p>　　下面我们对上述代码进行分析。<br>　　首先，你要为这种测试专门生成一个新的类，而不能与其他测试共用同一个类，此例中我们定义了一个SquareTest类。然后，你要为这个类指定一个Runner，而不能使用默认的Runner了，因为特殊的功能要用特殊的Runner嘛。@RunWith(Parameterized.class)这条语句就是为这个类指定了一个ParameterizedRunner。<br>　　第二步，定义一个待测试的类，并且定义两个变量，一个用于存放参数，一个用于存放期待的结果。接下来，定义测试数据的集合，也就是上述的data()方法，该方法可以任意命名，但是必须使用@Parameters标注进行修饰。这个方法的框架就不予解释了，大家只需要注意其中的数据，是一个二维数组，数据两两一组，每组中的这两个数据，一个是参数，一个是你预期的结果。比如我们的第一组{2,4}，2就是参数，4就是预期的结果。这两个数据的顺序无所谓，谁前谁后都可以。之后是构造函数，其功能就是对先前定义的两个参数进行初始化。在这里你可要注意一下参数的顺序了，要和上面的数据集合的顺序保持一致。如果前面的顺序是{参数，期待的结果}，那么你构造函数的顺序也要是“构造函数(参数， 期待的结果)”，反之亦然。</p>
<h4 id="打包测试">打包测试</h4>
<p>在一个项目中，只写一个测试类是不可能的，我们会写出很多很多个测试类。可是这些测试类必须一个一个的执行，也是比较麻烦的事情。鉴于此，JUnit提供了打包测试的功能，将所有需要运行的测试类集中起来，一次性的运行完毕，大大的方便了我们的测试工作。具体代码如下：</p>
<pre><code>@RunWith(Suite.class)
@Suite.SuiteClasses(<span class="keyword">...</span>{CalculatorTest.class, SquareTest.class})
public class AllCalculatorTests <span class="keyword">...</span>{}
</code></pre><p>　　大家可以看到，这个功能也需要使用一个特殊的Runner，因此我们需要向@RunWith标注传递一个参数Suite.class。同时，我们还需要另外一个标注@Suite.SuiteClasses，来表明这个类是一个打包测试类。我们把需要打包的类作为参数传递给该标注就可以了。有了这两个标注之后，就已经完整的表达了所有的含义，因此下面的类已经无关紧要，随便起一个类名，内容全部为空既可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>单元测试更多的是在开发阶段完成，开发人员每写一个函数的时候都会写相应的单元测试。对于java代码，普遍使用的是jUnit，根据jUnit可以自己相应的开发一套自动化测试框架。这个的前提是要学会junit，先知道怎么用，才能知道怎么为我所用。</p>
<p>学习JUnit的操]]>
    </summary>
    
      <category term="JUnit" scheme="http://yoursite.com/tags/JUnit/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[功能测试用例编写]]></title>
    <link href="http://yoursite.com/2014/12/25/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99/"/>
    <id>http://yoursite.com/2014/12/25/功能测试用例编写/</id>
    <published>2014-12-25T07:42:30.000Z</published>
    <updated>2014-12-25T14:03:44.000Z</updated>
    <content type="html"><![CDATA[<p>由于还不熟悉怎么用markdown来展现表格的内容，若想查看请移步我的博客园：<br><a href="http://www.cnblogs.com/silence-hust/p/4112055.html" target="_blank" rel="external">http://www.cnblogs.com/silence-hust/p/4112055.html</a></p>
<p>感谢大家的关注，我会继续努力的……</p>
<p>下面是幅我很喜欢的图片：人为什么要怎么努力，分享给大家<br>一定要看到最后哦！<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/人为什么要努力1.jpg" alt="人为什么要怎么努力"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于还不熟悉怎么用markdown来展现表格的内容，若想查看请移步我的博客园：<br><a href="http://www.cnblogs.com/silence-hust/p/4112055.html" target="_blank" rel="external">ht]]>
    </summary>
    
      <category term="测试用例" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试用例" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[web前端性能测试小点]]></title>
    <link href="http://yoursite.com/2014/12/25/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%82%B9/"/>
    <id>http://yoursite.com/2014/12/25/web前端性能测试小点/</id>
    <published>2014-12-25T06:57:34.000Z</published>
    <updated>2014-12-25T14:03:35.000Z</updated>
    <content type="html"><![CDATA[<p>关于前端性能的文章：<br> <a href="http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html</a></p>
<p>　　web应用的前端性能响应时间指浏览器的页面加载时间。浏览器的页面加载时间包括对html的解析，对页面图片及css等文件的获取和加载、客户端脚本的执行时间以及对你页面进行展现所花费的时间。这个与并发用户量的大小并没有直接的关系，主要关注：如何提高浏览器下载和执行资源的并发性，如何让浏览器尽快开始渲染页面，如何让浏览器尽可能充分的利用缓存。在yahoo中，到少50个团队通过纯粹的前端性能相关的技巧，将最终用户的响应时间减少了25%以上。<br>　　<br>在了解web前端性能时，我们应该知道http协议。</p>
<p>　　http协议采用请求/响应模型，客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本等信息，服务器以一个状态行作为响应，响应的内容包括消息协议的版本、成功或者错误编码加上包含服务器的信息、实体元信息等内容。该协议是一种非面向连接的协议，每个http请求都是独立的。<br>　　<code>请求报文的格式</code>：请求行 | 通用信息头 | 请求头 | 实体头 | 报文主体   Method     Request-URI  HTTP-versionCRIF<br>　　<code>响应报文的格式</code>：状态行 | 通用信息头 | 响应头 | 实体头 | 报文主体</p>
<p>响应报文的状态码如下：</p>
<blockquote>
<p>1XX：信息响应类，表示接收到请求并继续处<br>2XX：处理成功响应类，表示动作被成功接收、理解和接收<br>3XX：重定向响应类，表示为了完成指定的动作，必须接收进一步处理<br>4XX：客户端错误，表示客户请求包含语法错误或不能正确的执行<br>5XX：服务端错误，表示服务器不能正确执行一个正确的请求</p>
</blockquote>
<p>与前端性能相关的头信息：</p>
<p> 1、accept-encoding：告诉服务器所接受的页面的编码方式，gzip使用gzip压缩，deflate不压缩，压缩可以减少下载所需的时间。</p>
<p>2、connection：因为HTTP是费面向连接的，无状态的协议，每一个HTTP请求都会经过“建立连接—请求页面或资源—获得资源—断开连接”的过程。对于小的资源可能建立连接的时间都会超过对资源的处理时间，为了减少时间引入了持久连接。当浏览器和服务器约定好后，当某个资源传输完成后并不立即断开连接，而是等待一段时间，在这段时间内若传输其他的资源就复用该连接，否则就关闭。当值为keep-alive时有持久连接。</p>
<p>3、expires：用于只是返回数据的到期时间。到期时间之前都是从缓存处直接获取相应的资源，之后才会向服务器发送请求获取。</p>
<p>提高前端性能的方法：</p>
<blockquote>
<p>1、减少页面加载的时间，<br>2、减少网络时间：CDN技术，DNS缓存技术，减少文件的尺寸<br>3、减少发送的请求量：利用浏览器缓存<br>4、让页面尽早的开始显示</p>
</blockquote>
<h4 id="对于前段性能测试的理解：">对于前段性能测试的理解：</h4>
<p>　　由于自己之前有两三个月的时间接触了前端，对于前端的知识点比较熟悉，在这方面理解起来不是很困难，对于http协议，用户响应请求的过程都熟悉，但是那个时候并没有详细的考虑到页面的加载时间问题，只是想着将页面呈现出来，而忽略了对于响应时间的要求。由于自己都是在本机上实现的，所以每次想看结果的时候都要等很久，这就是没有使用性能的思想，去减少页面的加载时间，没有考虑周全。现在对于这方面有了更深的理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于前端性能的文章：<br> <a href="http://www.cnblogs.com/fnng/archive/2011/09/19/2181894.html" target="_blank" rel="external">http://www.cnblogs.co]]>
    </summary>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能测试之需求开发]]></title>
    <link href="http://yoursite.com/2014/12/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2014/12/25/性能测试之需求开发/</id>
    <published>2014-12-25T06:54:52.000Z</published>
    <updated>2014-12-25T14:03:42.000Z</updated>
    <content type="html"><![CDATA[<p>以下内容大多来自jackei的博客，只是整理了下，增加了自己的理解。</p>
<h4 id="一个实际的例子：">一个实际的例子：</h4>
<p> 某证券行业系统中某个业务的实际需求<br>1、系统总容量达到日委托6000万笔，成交9000万笔<br>2、 系统处理速度每秒7300笔，峰值处理能力达到每秒10000笔<br>3、实际股东帐号数3000万</p>
<p>从上面例子中可以看出几个明确的需求：<br>1、最佳并发用户数需求：每秒7300笔<br>2、最大并发用户数需求：峰值处理能力达到每秒10000笔<br>3、基础数据容量：实际股东帐号数3000万<br>4、业务数据容量：日委托6000万笔，成交9000万笔——可以根据这个推算出每周、每月、每年系统容量的增长模型</p>
<h4 id="什么是“有效的”性能需求？">什么是“有效的”性能需求？</h4>
<p>　　要想获得有效的性能需求，就要先了解什么样的需求是“有效的”。有效的性能需求应该符合以下三个条件。</p>
<p>1、 明确的数字，而不是模糊的语句。</p>
<p>　　结合上面的例子来看，相信这个应该不难理解。但是有的时候有了数字未必就不模糊。例如常见的一种需求是“系统需要支持5000用户”，或者“最大在线用户数为8000”。这些有数字的需求仍然不够明确，因为还需要考虑区分系统中不同业务模块的负载，以及区分在线用户和并发用户的区别。</p>
<p>2、有凭有据，合理，有实际意义。</p>
<p>　　通常来说，性能需求要么由客户提出，要么由开发方提出。对于第一种情况，要保证需求是合理的，有现实意义的，不能由着客户使劲往高处说，要让客户明白性能是有成本的。对于第二种情况，性能需求不能简单的来源于项目组成员、PM或者测试工程师的估计或者猜测，要保证性能需求的提出是有根据的，所使用的数据和计算公式是有出处的。</p>
<p>3、相关人员达成一致。</p>
<p>　　如果相关人不能对性能需求达成一致，可能测了也白测——特别是在客户没有提出明确的性能需求而由开发方提出时。这里要注意“相关人员”的识别，通常项目型的项目的需要与客户方的项目经理或负责人进行确认，产品型的项目需要与直属领导或者市场部进行确认。如果实在不知道该找谁确认，那就把这个责任交给你的直属领导。</p>
<h4 id="如何获得有效的性能需求：">如何获得有效的性能需求：</h4>
<p>1、 客户方提出<br>　　这是最理想的一种方式，通常电信、金融、保险、证券以及一些其他运营商级系统的客户——特别是国外的客户都会提出比较明确的性能需求。<br>　　<br>2、根据历史数据来分析<br>　　根据客户以往的业务情况来分析客户的业务量以及每年、每月、每周、每天的峰值业务量。如果客户有旧的系统，可以根据已有系统的访问日志，数据库记录，业务报表来分析。要特别注意的是，不同行业、不同应用、不同的业务是有各自的特点的。例如，购物网站在平时的负载主要集中在晚上，但是节假日时访问量和交易量会是平时的数倍；而地铁的售票系统面临的高峰除了周末，还有周一到周五的一早一晚上下班时间。<br>　　<br>3、参考历史项目的数据<br>　　如果该产品已有其他客户使用，并且规模类似的，可以参考其他客户的需求。例如在线购物网站，或者超市管理系统，各行业的进销存系统。<br>　　<br>4、参考其他同行类似项目的数据<br>　　如果本企业没有做过类似的项目，那么可以参考其他同行企业的公布出来的数据——通常在企业公布的新闻或者成功解决方案中会提到，包括系统容量，系统所能承受的负载以及系统响应能力等。<br>　　<br>5、参考其他类似行业应用的数据<br>　　如果无法找打其他同行的数据，也可以参考类似的应用的需求。例如做IPTV或者DVB计费系统的测试，可以参考电信计费系统的需求——虽然不能完全照搬数据，但是可以通过其他行业成熟的需求来了解需要测试的项目有哪些，应该考虑到的情况有哪些种。<br>　　<br>6、参考新闻或其他资料中的数据<br>　　最后的一招，特别是对于一些当前比较引人关注的行业，涉及到所谓的“政绩”的行业，通常可以通过各种新闻媒体找到一些可供参考的数据，但是需要耐心的寻找。例如我们在IPTV和DVB系统的测试中，可以根据新闻中公布的各省、各市，以及国外各大运营商的用户发展情况和用户使用习惯来估算系统容量和系统各个模块的并发量。</p>
<h4 id="性能测试点选取：">性能测试点选取：</h4>
<ul>
<li>发生频率非常高的（例如：某邮箱核心业务系统中的登录、收发邮件等业务，它们在每天的业务总量中占到90%以上）</li>
<li>关键程度非常高的（产品经理认为绝对不能出现问题的，如登录等）</li>
<li>资源占用非常严重的（导致磁盘I/O非常大的，例如某个业务进行结果提交时需要向数十个表存取数据，或者一个查询提交请求时会检索出大量的数据记录）</li>
</ul>
<h4 id="需求获取的小例子：">需求获取的小例子：</h4>
<p>　　去年全年处理“WEB登录”交易约 100 万笔，考虑到 3 年后交易量递增到每年 200万笔。假设每年交易量集中在 8 个月，每个月 20 个工作日，每个工作日 8 小时，试采用 80～20 原理估算系统服务器高峰期“WEB登录”的交易吞吐量应达到怎样的一个处理能力　<br>200万/8=25万/月<br>25万/20=1.25万/日<br>1.25万<em>80%/(8</em>20%*3600)=1.74TPS</p>
<h4 id="关于性能需求的一点补充：">关于性能需求的一点补充：</h4>
<p>　　在软件开发过程中，需求管理要远远简单于需求开发，CMMI中也体现了这一点，并且实际工作中也常常需要我们为客户来开发这部分的性能需求。考虑一下，如何根据客户的实际使用或粗线条的性能要求来开发满足客户需要的性能需求来。就拿例子来说，客户告诉我们“系统总容量达到日委托6000万笔，成交9000万笔；系统处理速度每秒7300笔，峰值处理能力达到每秒10000笔”，那我们将客户的这个要求管理起来并实现了这一点，这叫需求管理；而如果我们根据以下2个假设：<br>　　<br>1、采用2/8比例，即80%的业务在20%的峰值时间内完成，20%的业务在80%的非峰值时间内完成，那么我们可以得到峰值处理业务量1.5亿的80%为1.2亿，非峰值处理业务量1.5亿的20%为3000万；<br>2、1天系统运行时间为20小时，另4小时为非营业的后台处理时间，那么峰值时间20小时的20%为4小时，非峰值时间20小时的80%为16小时。</p>
<p>我们可以计算到：</p>
<p>3、 平均峰值处理速度1.2亿/4*3600秒接近9000个/秒；<br>4、平均非峰值处理速度3000万/16*3600秒约500个/秒；</p>
<p>　　考虑到特殊情况的发生，我们建议实际峰值处理速度要能达到理论计算的平均峰值处理速度的1.5到2倍，所以最终确定下来的建议峰值处理速度为9000个/ 秒*2=18000个/秒。我们拿这个结果向客户说明，告诉他们原来的需求很可能在发生特殊情况时无法有效处理，客户最终接受了我们的说法并调整了他们的需求。<br>　　<br>　　这叫需求开发，通过分析修正了客户的不合理需求，满足了他们最根本的需要”系统总容量达到日委托6000万笔，成交9000万笔”，而处理速度是他们根据自己的需要估算出来的，并不准确。<br>　　<strong>所谓需求开发，也就是根绝客户的核心需求，为客户设计完整的需求体系，甚至根据客户的业务发展需要，为客户设计核心需求和需求体系。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下内容大多来自jackei的博客，只是整理了下，增加了自己的理解。</p>
<h4 id="一个实际的例子：">一个实际的例子：</h4>
<p> 某证券行业系统中某个业务的实际需求<br>1、系统总容量达到日委托6000万笔，成交9000万笔<br>2、 系统处理速度每]]>
    </summary>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能测试之主要概念]]></title>
    <link href="http://yoursite.com/2014/12/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2014/12/25/性能测试之主要概念/</id>
    <published>2014-12-25T06:41:07.000Z</published>
    <updated>2014-12-25T14:03:43.000Z</updated>
    <content type="html"><![CDATA[<h4 id="什么是软件性能？">什么是软件性能？</h4>
<p><code>交互式系统</code>：以用户感受到的响应时间来描述系统的性能<br><code>非交互式系统</code>（银行业务处理）：响应时间只系统对事件产生的响应所需要的时间</p>
<h4 id="如何评价性能的好坏：">如何评价性能的好坏：</h4>
<p>　　用户视角：对于用户，最终使用者而言评价系统的性能好坏只有一个字——“快“。最终用户并不需要关心系统当前的状态——即使系统这时正在处理着成千上万的请求，对于用户来说，由他所发出的这个请求是他唯一需要关心的，系统对用户请求的响应速度决定了用户对系统性能的评价。简单点就是，用户单击一个按钮，发出一条指令或是在web页面上单击一个连接考试，到应用系统把本次操作的结果以用户能察觉的方式展示出来的过程所消耗的时间就是用户对软件性能的直观印象。</p>
<p>　　系统的运营商和开发商：期望的是能够让尽可能多的用户在任意时刻都拥有最好的体验，这就要确保系统能够在同一时间内处理更多的用户请求。系统的负载（并发用户数）与吞吐量（每秒事务数）、响应时间以及资源利用率（包括软硬件资源）之间存在着一个“此消彼长”的关系。因此，从系统的运营商和开发商的角度来看，所谓的“性能”是一个整体的概念，<strong>是系统的负载与吞吐量、可接受的响应时间以及资源利用率之间的平衡。</strong></p>
<p><strong>好的系统意味着更大的最佳并发用户数和最大并发用户数。</strong></p>
<p>　　另外，从系统的视角来看，所需要关注的还包括三个与“性能”有关的属性：<code>可靠性（Reliability）</code>，<code>可伸缩性（Scalability）</code>和<code>可恢复性（Recoverability）</code>　</p>
<h4 id="响应时间：">响应时间：</h4>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/xysj.jpg" alt="响应时间"><br>图中是一个请求的响应时间的组成，包括</p>
<p>C1：用户请求发出前在客户端需要完成的预处理所需要的时间；</p>
<p>C2：客户端收到服务器返回的响应后，对数据进行处理并呈现所需要的时间；</p>
<p>A1：Web/App Server 对请求进行处理所需要的时间；</p>
<p>A2：DB Server 对请求进行处理所需的时间；</p>
<p>A3：Web/App Server 对 DB Server 返回的结果进行处理所需的时间；</p>
<p>N1：请求由客户端发出并达到Web/App Server 所需要的时间；</p>
<p>N2：如果需要进行数据库相关的操作，由Web/App Server 将请求发送至DB Server 所需要的时间；</p>
<p>N3：DB Server 完成处理并将结果返回Web/App Server 所需的时间；</p>
<p>N4：Web/App Server 完成处理并将结果返回给客户端所需的时间；</p>
<p>　从用户的角度来看，响应时间＝(C1+C2)+(A1+A2+A3)+(N1+N2+N3+N4)；但是从系统的角度来看，响应时间只包括(A1+A2+A3)+(N1+N2+N3+N4)。理解响应时间的组成可以帮助我们通过对响应时间的分析来更好的识别和定位系统的性能瓶颈。<br>　　从用户的角度看，所体会到的响应时间有主观和客观之分，客观来说就是上面提到的从用户操作开始到所有数据返回完成的整个耗时，主观上说如果采用一种优化的数据呈现策略，当少部分数据返回之后就立马将数据呈现在用户面前，则用户感受到的响应时间就会远远小于实际的实物响应时间。<br>　　对于一个web应用来说，响应时间的标准是2/5/10秒，而对于一个OA系统，每次可能只使用一次该系统，当点击提交时就算系统在20分钟后才响应，用户仍然不会觉得不能接受。所以合理的响应时间取决于<code>实际的用户需求</code>。</p>
<h4 id="吞吐量：">吞吐量：</h4>
<p>单位时间内系统处理的客户请求的数量。在web系统中主要以请求数（单击数）/秒、页面数/秒来体现。</p>
<ol>
<li><p>用户协助设计性能测试场景，以及衡量性能测试场景是否达到了预期的设计目标：在设计性能测试场景时，吞吐量可被用户协助设计性能测试场景，根据估算的吞吐量数据，可以对应到测试场景的事务发生频率，事务发生次数等；另外，在测试完成后，根据实际的吞吐量可以衡量测试是否达到了预期的目标。</p>
</li>
<li><p>用于协助分析性能瓶颈：吞吐量的限制是性能瓶颈的一种重要表现形式，因此，有针对性地对吞吐量设计测试，可以协助尽快定位到性能冰晶所在位置。</p>
</li>
</ol>
<p><strong>并发用户数 ≠ 每秒请求数</strong>：</p>
<p>　　简单说，当你在性能测试工具或者脚本中设置了100并发用户数后，并不能期望着一定会有每秒100个请求发给服务器。事实上，对于一个虚拟用户来说，每秒发出多少请求只跟服务器返回响应的速度有关。如果虚拟用户在0.5秒内就收到了响应，那么它会立即发出第二个请求；而如果要一直等待3秒才能得到响应，它将会一直等到收到响应后才发出第二个请求。也就是说，并发用户数的设置只是保证服务器在任一时刻都有100个请求需要处理，而并不一定是保证每秒中发送100个请求给服务器。<br>　　所以，只有当响应时间恰好是1秒时，并发用户数才会等于每秒请求数；否则，每秒请求数可能大于并发用户数或小于并发用户数。<br>　　<strong>并发用户数取决于具体的业务场景，它体现的时服务器端承受的最大并发访问数。</strong></p>
<h4 id="举个例子：">举个例子：</h4>
<p>　　一个系统有2000用户（系统用户数），最高峰时有500人在线（同时在线人数），那么系统的并发用户数呢？<br>　　500是整个系统使用时最大的业务并发用户数，并不表示服务器实际承受的压力，这与具体的用户访问模式有关。例如这500人中，有40%在看公告，20%在填写表格（表格只有在点击提交时才会对服务器产生负担），20%在发呆，20%在切换页面，这种情况下只有20%的用户真正的对服务器构成了压力。<br>　　<br><strong>性能计数器</strong>：<br>描述服务器或操作系统性能的一些数据指标，在performance test中发挥这监控和分析的关键作用。</p>
<p><strong>性能测试包括</strong>：<br>验收性能测试（acceptance performance testing）<br>负载测试（load testing）<br>压力测试（stress testing）<br>配置测试（configuration testing）<br>并发测试（concurrency testing）<br>可靠性测试（reliability testing）<br>失败恢复测试（failure testing）</p>
<h4 id="对性能测试的一点理解：">对性能测试的一点理解：</h4>
<p>　　性能测试重要的一点在于对需求的理解，如果没有正确的理解需求，而充忙的去搭建环境，配置信息，最后得到的会是不正确的测试结果。而往往一些用户或者客户并不十分明确对性能的要求，他们只会给出一个宽泛的表示，那么这时就需要我们自己去寻找需求，从要求中提炼出准确的需求。明确了需求之后才好进行下一部的操作。<br>　　当然在这之前对于性能测试的主要内容需要掌握，性能的知识点也不是很多，重要的是在实践中的领悟，性能测试并不是功能测试，它是从一个系统，站在更大的立场上去宏观的把握产品，去对系统进行测试，但是并不代表在功能测试的同时不能进行性能测试。性能的要求也会更高，需要了解的知识会更多，对系统的架构要有一定的熟悉度。所以想要真正做好性能测试，任重而道远。加油！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="什么是软件性能？">什么是软件性能？</h4>
<p><code>交互式系统</code>：以用户感受到的响应时间来描述系统的性能<br><code>非交互式系统</code>（银行业务处理）：响应时间只系统对事件产生的响应所需要的时间</p>
<h4 id="如]]>
    </summary>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能测试（一）---理发店模型]]></title>
    <link href="http://yoursite.com/2014/12/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89---%E7%90%86%E5%8F%91%E5%BA%97%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2014/12/25/性能测试（一）---理发店模型/</id>
    <published>2014-12-25T02:24:38.000Z</published>
    <updated>2014-12-25T14:03:41.000Z</updated>
    <content type="html"><![CDATA[<p>　　这个理发店模型是在网络上看来的，之后对性能测试有了一定的了解之后，感觉写的很好，现在结合自己的一点想法，将理发店模型完整的记录下来。文中很多是来自jackei和虫师的博客，估计这两个博客大家都不陌生。</p>
<h3 id="理发店模型">理发店模型</h3>
<p>　　理发店模型，可以很好的用来理解很多性能测试的概念和理论，以及一些测试中遇到的问题，将本来抽象的概念具体化，联合实际，可能很多地方没有很好的切合，但是这个模型确实帮助我理解了很多点。</p>
<p>在我们的这个理发店中，我们事先做了如下的假设：</p>
<ol>
<li><p>理发店共有3名理发师；</p>
</li>
<li><p>每位理发师剪一个发的时间都是1小时；</p>
</li>
<li><p>我们顾客们都是很有时间观念的人而且非常挑剔，他们对于每次光顾理发店时所能容忍的等待时间+剪发时间是3小时，而且等待时间越长，顾客的满意度越低。如果3个小时还不能剪完头发，顾客会立马生气的走人。</p>
</li>
</ol>
<p>通过上面的假设可以想象出下面的这些场景：</p>
<ol>
<li><p>当理发店内只有1位顾客时，只需要有1名理发师为他提供服务，其他两名理发师可能继续等着，也可能会帮忙打打杂。1小时后，这位顾客剪完头发出门走了。那么在这1个小时里，整个理发店只服务了1位顾客，这位顾客花费在这次剪发的时间是1小时；</p>
</li>
<li><p>当理发店内同时有两位顾客时，就会同时有两名理发师在为顾客服务，另外1位发呆或者打杂帮忙。仍然是1小时后，两位顾客剪完头发出门。在这1小时里，理发店服务了两位顾客，这两位顾客花费在剪发的时间均为1小时；</p>
</li>
<li><p>很容易理解，当理发店内同时有三位顾客时，理发店可以在1小时内同时服务三位顾客，每位顾客花费在这次剪发的时间仍然是均为1小时。</p>
</li>
</ol>
<p>从上面几个场景中我们可以发现，在理发店同时服务的顾客数量从１位增加到3位的过程中，随着顾客数量的增多，理发店的整体工作效率在提高，但是每位顾客在理发店内所呆的时间并未延长。当然，我们可以假设当只有1位顾客和2位顾客时，空闲的理发师可以帮忙打杂，使得其他理发师的工作效率提高，并使每位顾客的剪发时间小于1小时。不过即使根据这个假设，虽然随着顾客数量的增多，每位顾客的服务时间有所延长，但是这个时间始终还被控制在顾客可接受的范围之内，并且顾客是不需要等待的。</p>
<p>　　不过随着理发店的生意越来越好，顾客也越来越多，新的场景出现了。假设有一次顾客A、B、C刚进理发店准备剪发，外面一推门又进来了顾客D、E、F。因为A、B、C三位顾客先到，所以D、E、F三位只好坐在长板凳上等着。1小时后，A、B、C三位剪完头发走了，他们每个人这次剪发所花费的时间均为1小时。可是D、E、F三位就没有这么好运，因为他们要先等A、B、C三位剪完才能剪，所以他们每个人这次剪发所花费的时间均为2小时——包括等待1小时和剪发1小时。<br>　　<br>　　通过上面这个场景我们可以发现，对于理发店来说，都是每小时服务三位顾客——第1个小时是A、B、C，第二个小时是D、E、F；但是对于顾客D、E、F来说，“响应时间”延长了。如果你可以理解上面的这些场景，就可以继续往下看了。<br>　　<br>　　在新的场景中，我们假设这次理发店里一次来了9位顾客，根据我们上面的场景，相信你不难推断，这9位顾客中有3位的“响应时间”为1小时，有3位的“响应时间”为2小时（等待1小时+剪发1小时），还有3位的“响应时间”为3小时（等待2小时+剪发1小时）——已经到达用户所能忍受的极限。假如在把这个场景中的顾客数量改为10，那么我们已经可以断定，一定会有1位顾客因为“响应时间”过长而无法忍受，最终离开理发店走了。<br>　　<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/blogxn1.jpg" alt="性能"></p>
<p>　　这张图中展示的是1个标准的软件性能模型。在图中有三条曲线，分别表示<strong>资源的利用情况</strong>（Utilization，包括硬件资源和软件资源）、<strong>吞吐量</strong>（Throughput，这里是指每秒事务数）以及<strong>响应时间</strong>（Response Time）。图中坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。在这张图中我们可以看到，最开始，随着并发用户数的增长，资源占用率和吞吐量会相应的增长，但是响应时间的变化不大；不过当并发用户数增长到一定程度后，资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长。如果并发用户数继续增长，你会发现软硬件资源占用继续维持在饱和状态，但是吞吐量开始下降，响应时间明显的超出了用户可接受的范围，并且最终导致用户放弃了这次请求甚至离开。</p>
<p>　　根据这种性能表现，图中划分了三个区域，分别是Light Load（较轻的压力）、Heavy Load（较重的压力）和Buckle Zone（用户无法忍受并放弃请求）。在Light Load和Heavy Load 两个区域交界处的并发用户数，我们称为“最佳并发用户数（The Optimum Number of Concurrent Users）”，而Heavy Load和Buckle Zone两个区域交界处的并发用户数则称为“最大并发用户数（The Maximum Number of Concurrent Users）”。</p>
<p>　　当系统的负载等于最佳并发用户数时，系统的整体效率最高，没有资源被浪费，用户也不需要等待；当系统负载处于最佳并发用户数和最大并发用户数之间时，系统可以继续工作，但是用户的等待时间延长，满意度开始降低，并且如果负载一直持续，将最终会导致有些用户无法忍受而放弃；而当系统负载大于最大并发用户数时，将注定会导致某些用户无法忍受超长的响应时间而放弃。</p>
<h3 id="理解：">理解：</h3>
<p><code>最佳并发用户数</code>：每小时3位顾客，即理发店收入最多（理发师傅没有休息时间，一直在理发），顾客满意度最高（顾客随时到随时理，无需要等待）。</p>
<p><code>最大并发用户数</code>：每小时9位顾客，理发店的最大承受状态，理发店收入最多（理发师傅没有休息时间，一直在理发），顾客的最大忍耐度（来的顾客等待+理发需要等上三个小时）。当每小时都有9个顾客到来时，前几个小时来的顾客还可以忍受，但是随着等待的顾客人数越来越多，等待时间越来越长，最终还是会有顾客无法忍受而离开。同时，随着理发店里顾客人数的增多和理发师工作时间的延长，理发师会逐渐产生疲劳，还要多花一些时间来清理环境和维持秩序，这些因素将最终导致理发师的工作效率随着顾客人数的增多和工作的延长而逐渐的下降，到最后可能要1.5小时甚至2个小时才能剪完1个发了。如果一开始就有10个顾客到来，则注定有1位顾客剪不到头发了。当然，理发店还会不断的来新的顾客，不断有等了三小时而没有得到服务的顾客离开，但对于理发店而言，他们在一个时间点上，能服务的最大用户数是9（3位正在接受服务、3位已经等待一小时，3位已经等待两小时）。</p>
<p>　　对于一个确定的被测系统来说，在某个具体的软硬件环境下，它的“最佳并发用户数”和“最大并发用户数”都是客观存在。以“最佳并发用户数”为例，假如一个系统的最佳并发用户数是50，那么一旦并发量超过这个值，系统的吞吐量和响应时间必然会 “此消彼长”；如果系统负载长期大于这个数，必然会导致用户的满意度降低并最终达到一种无法忍受的地步。所以我们应该 保证最佳并发用户数要大于系统的平均负载。要补充的一点是，当我们需要对一个系统长时间施加压力——例如连续加压3-5天，来验证系统的可靠性或者说稳定性时，我们所使用的并发用户数应该等于或小于“最佳并发用户数”</p>
<p> 对于最大并发用户数的识别，需要考虑和鉴别一下以下两种情况：</p>
<blockquote>
<ol>
<li><p>在理发店里很大，可以容纳很多位顾客（大于9），总有一部分在这里等待了三小时而没有得到服务离开，不要把等待了三小时而没有得到服务的顾客纳入最大用户数里。也就是说3小时前理发店内的顾客数量才是我们要找的“最大并发用户数”。而且，这位顾客的离开只是一个开始，可能有会更多的顾客随后也因为无法忍受超长的等待时间而离开；</p>
</li>
<li><p>在响应时间还没有到达用户可忍受的最大限度前，有可能已经出现了用户请求的失败。假如理发店很小，最多只能容纳六位顾客，当第七个顾客来时，虽然，我们知道他只需要等待两小时就可得到服务（这个时间是他可以接受的等待时间），但由于理发店容量有量，这第七个顾客只有改天再来了。</p>
</li>
</ol>
</blockquote>
<p><strong>对于一个系统来说，我们应该确保系统的最大并发用户数要大于系统需要承受的峰值负载。</strong></p>
<h3 id="理发店模型的进一步扩展">理发店模型的进一步扩展</h3>
<blockquote>
<p>扩展场景1：有些顾客已经是理发店的老顾客，他们和理发师已经非常熟悉，理发师可以不用花费太多时间沟通就知道这位顾客的想法。并且理发师对这位顾客的脑袋的形状也很熟悉，所以可以更快的完成一次理发的工作。</p>
</blockquote>
<hr>
<blockquote>
<p>扩展场景2：理发店并不是只有剪发一种业务，还提供了烫发染发之类的业务，那么当顾客提出新的要求时，理发师服务一位顾客的时间可能会超过标准的1小时。而且这时如果要计算每位顾客的等待时间就变得复杂了很多，有些顾客的排队时间会比原来预计的延长，并最终导致他们因为无法忍受而离开。</p>
</blockquote>
<hr>
<blockquote>
<p>扩展场景3：随着烫发和染发业务的增加，理发师们决定分工，两位专门剪发，一位专门负责烫发和染发。</p>
</blockquote>
<hr>
<blockquote>
<p>扩展场景4：理发店的生意越来越好，理发师的数量和理发店的门面已经无法满足顾客的要求，于是理发店的老板决定在旁边再开一家店，并招聘一些工作能力更强的理发师。</p>
</blockquote>
<hr>
<blockquote>
<p>扩展场景5：理发店的生意变得极为火爆了，两家店都无法满足顾客数量增长的需求，并且有些顾客开始反映到理发店的路途太远，到了以后又因为烫发和染发的人太多而等太久。可是理发店的老板也明白烫发和染发的收入要远远高于剪发阿，于是他脑筋一转，决定继续改变策略，在附近的几个大型小区租用小的铺面开设分店，专职剪发业务；再在市区的繁华路段开设旗舰店，专门为烫发、染发的顾客，以及VIP顾客服务。并增设800电话，当顾客想要剪发时，可以拨打这个电话，并由服务人员根据顾客的居住地点，将其指引到距离最近的一家分店去。</p>
</blockquote>
<h4 id="对模型的理解：">对模型的理解：</h4>
<p>　　理发店就相当于我们的系统，顾客就我们向服务器所发送的请求，最佳用户数和最大用户数是我们衡量一个系统的处理能力的一种方法。理发师们的分工就是在对服务器处理不同请求的分工，扩展的场景就是对b/s的系统的一个缩影，随着生意越来越好，网站流量越来越多，系统的整体架构需要发生相应的改变，一满足用户的需求。在遇到难以理解的术语时，时常想想这个理发店模型就可以很好的理解性能测试。一个CPU相当于一个理发师，一个服务器又有几个CPU，当业务扩展的时候，需要增加CPU，再增长的时候需要增加服务器；业务达到一定的水准的时候分成专门的服务器提供具体的服务；电话相当于一个域名解析服务器，根据不同的提交服务转到不同的服务器。 针对不同的用户的性能需求可以将功能分解起来测试。 </p>
<p>　　微观上来说，在单CPU的情况下，并不存在真正意义上的并发响应（并发请求是可能的），那么3个理发师同时工作如何解释上述问题？操作系统实际上是分时处理的系统，CPU 时间被以时间片为单位轮流分配给不同的进程——但是操作系统的这种做法本身也是为了让每个进程都感觉到自己在独占 CPU。从这个角度来说，如果我们的理发师可以以极为快速（例如10ms一个间隔）的速度在三位顾客之间切换，而且这个切换是我们根本无法发现或者识别的，我们是否可以认为相当于有三位理发师同时在为顾客服务呢？ </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这个理发店模型是在网络上看来的，之后对性能测试有了一定的了解之后，感觉写的很好，现在结合自己的一点想法，将理发店模型完整的记录下来。文中很多是来自jackei和虫师的博客，估计这两个博客大家都不陌生。</p>
<h3 id="理发店模型">理发店模型</h3>
<p>　]]>
    </summary>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么想做测试之我的测试开端]]></title>
    <link href="http://yoursite.com/2014/10/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%83%B3%E5%81%9A%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%BC%80%E7%AB%AF/"/>
    <id>http://yoursite.com/2014/10/26/为什么想做测试之我的测试开端/</id>
    <published>2014-10-26T02:06:00.000Z</published>
    <updated>2014-12-25T14:01:50.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;这个问题曾经纠结了我很久，开发还是测试？最终出于自己内心的渴望与求知决定我要从事软测这个行业。</p>
<p>&emsp;&emsp;从本科我就开始接触主流的编程语言，也一直以为自己以后会从事软件设计这份工作，直到大三找实习的时候接触到软测，加上身边很多人都说女孩子适合做软测，不累，当初就抱着这么单纯的想法，懵懵懂懂的就想往测试这个方向走了，算是在心里种下了一颗种子。当时也是为了增加项目经历和拥有开发经验（当时觉得有开发经历能找到好工作）就选择了现在所在的实验室，进入实验室后才发现这个环境和我所想的不一样，不到半年，我就对自己的前途感到迷茫了，看不清楚路在哪里。实验室的研究方向变了，周围有很多人都鄙视做软测的，都说测试没有开发的工资高，测试是很low的一个工作，本科生大专生才做的，根本没有技术含量，在一些公司根本不重要，各种不好的话语动摇了我的决心，于是之前种下的种子没有浇水施肥，还忍受着虫害，时间一长，渐渐地快死了。</p>
<p>&emsp;&emsp;就在这纠结的期间，实验室师姐拉了我一把，师姐是想做前端的，跟我介绍了前端的各种技术，于是在我不确定的情况下，我跟着师姐断断续续学习了将近2个月的前端知识，从一点基础都没有的情况下，学到了：</p>
<ul>
<li>了解了什么是前端，前端开发的一整套体系</li>
<li>了解互联网的消息</li>
<li>知道怎么订阅优秀人才的博客</li>
<li>学会怎么获取和学习有用的信息</li>
</ul>
<p>这个过程反而让我对网页性能起了想法：</p>
<ul>
<li>是什么技术让前端写出来的页面可以满足客户的无限次刷屏？</li>
<li>是什么保证了系统不会再大量使用人员的情况下崩溃？就像双十一那样</li>
</ul>
<ul>
<li>淘宝是如何做到在双十一那天，满足几百万笔交易的？</li>
<li>如何在11月11号凌晨的时候保证系统不崩溃的？</li>
<li>想到了12306网站，为什么铁道部的购票系统还是会在春节购票期间崩溃，还是会在抢票的时候刷不进去，让很多人干瞪着屏幕，就是没法点击购买？</li>
<li>为什么我们学校的管理系统，每到学生选课的时候就崩溃（这是学校的十大吐槽点）</li>
</ul>
<hr>
<p>&emsp;&emsp;按每年的招生情况来说最多也就8000多人进行选课，排除一半（因为体育课是两个学期上的）加上部分不重视选课的学生，那么最多就是2000左右的人会有可能同时登入系统，但却不一定在同一个时段，偌大一个学校的管理系统会承受不住2000人同时登入，进入让系统崩溃达一天？研发出来的系统是如何保证一上线后就可以满足高并发量的要求的，就像淘宝双十一？如何确定开发出来的系统可以满足多少人同时进行某一项操作的？这些让我很迷惑。我知道这些问题是属于测试技术范畴的，只有测试人员可以告诉我。于是我就在<code>测试和开发</code>之间两难了。</p>
<p>&emsp;&emsp;就在我不知道如何抉择的时候？小微金服来了。2014年4月20日，阿里旗下的<code>小微金服</code>带着他的测试技术团队，在我们学校开了一堂<code>测试技术大讲堂</code>。一天6个人分享了在测试不同领域的技术和感受，从<strong>测试流程</strong>、<strong>测试设计和测试分析</strong>、<strong>性能测试</strong>、<strong>自动化测试</strong>到<strong>测试架构平台搭建</strong>，让我豁然开朗，让我彻底明白之前我对测试的狭隘认识，是多么的愚蠢，多么的单纯。他们带我见识了真正的测试领域是怎么样的，真正的测试工作是怎样的，让我看到测试的魅力所在。测试是一个技术岗位，而不是简简单单的点击几下鼠标就行的。这一天坚定了我要做软测的决心，让我摇摆不定的心终于有了航行的方向。更加确定自己的目标，我要进阿里，我要进小微金服团队。</p>
<p>&emsp;&emsp;于是我找了很多书看，关注了一些有名的技术博客，留意测试行业的发展，结合自身的兴趣，对互联网web的发展和手机移动端发展的关注，从事web测试、或者移动端测试（app测试）方向，想让我手下的产品能做到让用户不卸载，能做到零体验bug，能承受大量用户对某一业务的同时操作和请求，能让产品更好的服务于用户。<em>所有的这些需要我有扎实的测试知识和理念思想作为基础。</em></p>
<p>&emsp;&emsp;测试人员是第一批接触产品的人，是代表用户使用和反馈产品问题的人，一个产品若最后通不过测试这一关是无法上线的，可以说测试人员握有生杀大权，相应的<strong>身上的责任就很重，给予的成就感于会很强，而我喜欢这样的感觉，开发创造了世界，而我们将拯救世界，让产品要么不上线，要么就永久的在线上获得用户的青睐，而不是短暂的一闪而过，</strong>各种问题导致用户卸载。</p>
<p>&emsp;&emsp;<strong>当接触开发越多的时候，会对测试的重要性有更深的体会，熟知开发流程，知道bug最有可能出现在哪里？分析bug产生因素时有很清晰的流程，可以很好的和开发交流，可以结合测试的需求快速的开发适合的测试工具，可以实现自动化测试。</strong></p>
<p>&emsp;&emsp;当你交付给客户的产品出现性能问题，出现功能需求无响应问题，出现质量问题的时候，你不得不重新返工，不得不遭受用户的质疑，造成用户的流失，公司的损失巨大。<strong>可以用金钱弥补的损失就不算是大损失，但让用户体验差，失去用户，失去用户的信任才是最大的损失，一旦失去用户将很难在将来把用户召集回来。</strong></p>
<p><strong>这些是我对测试的一点浅浅的理解，有不对的或理解错误的望各位指教。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;&emsp;这个问题曾经纠结了我很久，开发还是测试？最终出于自己内心的渴望与求知决定我要从事软测这个行业。</p>
<p>&emsp;&emsp;从本科我就开始接触主流的编程语言，也一直以为自己以后会从事软件设计这份工作，直到大三找实习的时候接触到软测，加上身边]]>
    </summary>
    
      <category term="测试杂感" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95%E6%9D%82%E6%84%9F/"/>
    
      <category term="心路历程" scheme="http://yoursite.com/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="杂感" scheme="http://yoursite.com/categories/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[opencv函数系列---漫水填充floodfill]]></title>
    <link href="http://yoursite.com/2014/09/16/opencv%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97-fillfood/"/>
    <id>http://yoursite.com/2014/09/16/opencv函数系列-fillfood/</id>
    <published>2014-09-16T13:55:27.000Z</published>
    <updated>2014-09-16T13:57:22.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、floodFill思想">一、floodFill思想</h3>
<p>　　所谓漫水填充，简单来说，就是自动选中了和种子点相连的区域，接着将该区域替换成指定的颜色，这是个非常有用的功能,经常用来标记或者分离图像的一部分进行处理或分析.漫水填充也可以用来从输入图像获取掩码区域,掩码会加速处理过程,或者只处理掩码指定的像素点。操作结果总是某个连续的区域。当邻近像素点位于给定的范围（从lodiff到updiff）内或在原始seedPoint像素值范围内是，floodFill将会为这个点涂上颜色。以此填充算法为基础，类似photoshop的魔术棒选择工具就很容易实现了。<br>　　漫水填充（FloodFill）是查找和种子点联通的颜色相同的点，魔术棒选择工具则是查找和种子点联通的颜色相近的点，将和初始种子像素颜色相近的点压进栈作为新种子。<br>　　泛红填充实现最常见有四邻域像素填充法，八邻域像素填充法，基于扫描线的像素填充方法。根据实现又可以分为递归与非递归（基于栈）。</p>
<h3 id="二、函数介绍">二、函数介绍</h3>
<p>　　</p>
<pre><code>floodFill ( InputOutputArray image,   <span class="comment">//输入/输出1通道或3通道，8位或浮点图像，具体参数由之后的参数具体指明InputOutputArray mask,     </span>
     Point seedPoint,                <span class="comment">//漫水填充算法的起始点</span>
     Scalar newVal,                   <span class="comment">//像素点被染色的值，即在重绘区域像素的新值</span>
     Scalar loDiff=Scalar(), 
     Scalar upDiff=Scalar(), 
     CvConnectedComp*  comp = <span class="keyword">NULL</span>
     <span class="keyword">int</span> flags=<span class="number">4</span> )
</code></pre><p>　　mask：表示操作掩模,（控制被填充的区域）。它应该为单通道、8位、长和宽上都比输入图像 image 大2个像素点的图像（是内部运算简单快速）。floodFill需要使用以及更新掩膜。需要注意的是，漫水填充不会填充掩膜mask的非零像素区域。例如，一个边缘检测算子的输出可以用来作为掩膜，以防止填充到边缘。同样的，也可以在多次的函数调用中使用同一个掩膜，以保证填充的区域不会重叠。另外需要注意的是，掩膜mask会比需填充的图像大，所以mask中与输入图像(x,y)像素点相对应的点的坐标为(x+1,y+1)。<br>　　<br>　　lodiff、updiff：表示当前观察像素值与其部件邻域像素值或者待加入该部件的种子像素之间的亮度或颜色之负差（lower brightness/color difference）或正差的最大值。 如果一个像素点的值不低于被染色的相邻点减去lodiff且不高于其加上updiff，那么该像素点就会被染色。如果flags参数包含FLOODFILL_FIXED_RANGE 这时每个像素点都将于种子点而不是相邻点比较。可以理解成阈值范围，在这个范围里的像素都会被染色。<br>　　<br>　　flags：低8位（第0~7位）用于控制算法的连通性，可取4 (4为缺省值) 或者 8。如果设为4，表示填充算法只考虑当前像素水平方向和垂直方向的相邻点；如果设为 8，除上述相邻点外，还会包含对角线方向的相邻点。高8位部分（16~23位）可以为0 或者如下两种选项标识符的组合：<br>　　（1） FLOODFILL_FIXED_RANGE－如果设置为这个标识符的话，就会考虑当前像素与种子像素之间的差，否则就考虑当前像素与其相邻像素的差。也就是说，这个范围是浮动的。<br>　　（2）FLOODFILL_MASK_ONLY－如果设置为这个标识符的话，函数不会去填充改变原始图像 (也就是忽略第三个参数newVal),而是去填充掩模图像（mask）。中间8位部分，上面关于高八位FLOODFILL_MASK_ONLY标识符中已经说的很明显，需要输入符合要求的掩码。Floodfill的flags参数的中间八位的值就是用于指定填充掩码图像的值的。但如果flags中间八位的值为0，则掩码会用1来填充。<br>　　而所有flags可以用or操作符连接起来，即“|”。例如，如果想用8邻域填充，并填充固定像素值范围，填充掩码而不是填充源图像，以及设填充值为47，那么输入的参数是这样：</p>
<pre><code><span class="attribute">flags</span>=<span class="string">8 | FLOODFILL_MASK_ONLY | FLOODFILL_FIXED_RANGE | （47&lt;&lt;8）</span>
</code></pre><h3 id="三、函数演示">三、函数演示</h3>
<p>待写ing……</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、floodFill思想">一、floodFill思想</h3>
<p>　　所谓漫水填充，简单来说，就是自动选中了和种子点相连的区域，接着将该区域替换成指定的颜色，这是个非常有用的功能,经常用来标记或者分离图像的一部分进行处理或分析.漫水填充也可以用来从输入图像]]>
    </summary>
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/opencv/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[时间管理--小强升职记]]></title>
    <link href="http://yoursite.com/2014/09/16/%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0/"/>
    <id>http://yoursite.com/2014/09/16/小强升职记/</id>
    <published>2014-09-16T13:42:41.000Z</published>
    <updated>2014-09-16T13:47:36.000Z</updated>
    <content type="html"><![CDATA[<p>　　书中已对话的形式，主管老付如何教会小强对自己时间进行管理，如何高效的完成工作，培养其成为主管。<br>　　在我们觉得时间很多的时候，他就偷偷的溜走了，时间对于每个人都是公平的。我们每天在忙忙碌碌的日子里过去，是否过得有意义，浑浑噩噩的日子真的是我们所要的吗？到底我自己追求的是什么？每天工作学习是为了什么？什么样的人生才有意义?我们需要站在一个更高的位置上审视自己。问问自己什么才是真正想要的。<br>　　<br>　　我们的时间总是在无意义的事情上面一点点的浪费掉。确实如此，以前总是每次开电脑的时候。登下QQ，看下新闻什么的，以为这样浪费不了多少时间，可是每次都没有忍住，还有点像滚雪球似的的越滚越长，结果一看时间已经10:00多了，过一会就要吃饭了，自然就没有心思学习了，或者每次时间很轻易的就被同学打断，被QQ消息打断，那么在要集中注意就很难，就是这样的时间黑洞将我们的时间吞噬掉。<br>　　<br>　　有时候也会有同时有很多事情向我袭来，很多时候就应该根据自己的价值观，给他们分出优先级，找出核心事件，及时解决这些问题。时间管理的方法有很多，四象限法则，时间投资法，衣柜整理法等，具体哪一种是适合你的，还是需要自己去摸索，去实践才知道什么是适合自己的。书里的时间资本法，对于时间价值的计算让我忽然醒来，原来我的时间就剩这么一点了，可是我想要的生活还没有实现。。<br>　　<img src="/images/zbjs2.png" alt="资本计算2"><br>    <img src="/images/zbjs.png" alt="资本计算"><br>　　很典型的，在今后工作的日子里，只有8年是在工作，有10年是在睡觉，其他时间是13年，有人曾统计过一个人活得72岁时对时间的消费情况：睡觉21年，工作14奶奶，个人卫生7年，吃饭6年，旅行6年，排队5年，学习4年，开会3年，打电话2年，找东西1年，其他3年。如果加上我们的年新来计算时间资本，那么很廉价。。</p>
<h3 id="目标">目标</h3>
<p>　　时间，是一个非常奇怪的东西，当你想挥霍它的时候，它会尽量的满足你，让你觉得怎么挥霍都用不完。但是当你想要珍惜它的时候，他又会i特别的吝啬，让你觉得时光飞逝，转眼已是尽头。<br>　　对于一个项目或是什么要有明确的目标，具体的下一步行动，一个行动清单。对人生有规划，有明确的目标是很好的，但如果沉迷在未来美好生活的幻想中，而不是执行它，只是做个梦想家，我们要将目标化为行动，做个建筑家，梦想的缔造者。<br>　　当然，目标也不是有了完美的计划就能达成的，我们需要方法避免失败。<br>　　1、找到最大的石头，就是要问问自己实现这个目标最大的石头（障碍）在哪里，如果最大的石头没有移除，你除去了99%的小石头也是没有用的。<br>　　2、有什么想法计划一定要写下来，白字黑子是最好的契约，写到了才可以做到，那么所有的想想就不再只是想想了，而是需要实现的东西了。<br>　　3、拒绝第一次失败，万事开头难，很多目标的夭折都是从第一次失败开始的。所以我们要重视第一次的是吧，摆正心态不让它产生连锁反应。我们有一种很可怕的适应性，不敢是对好习惯还是坏习惯的适应。失败了，我们更应该找出原因，为什么会失败？到底为什么成功？花时间思考这两个问题是非常重要的。</p>
<h3 id="习惯">习惯</h3>
<p>　　习惯是个很可怕的东西，对于长期做在电脑前的上班族，最重要的一点就是要养成健身的习惯，平时我们可能没有大把的时间可以去运动，为了身体的健康，每天坚持一个小时的锻炼。向着你要养成多习惯，每天去做一些你不愿意的事情，这样你就不会为那些真正需要你完成的责任而痛苦。</p>
<h3 id="思维导图">思维导图</h3>
<p><img src="/images/swdt.bmp" alt="思维导图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　书中已对话的形式，主管老付如何教会小强对自己时间进行管理，如何高效的完成工作，培养其成为主管。<br>　　在我们觉得时间很多的时候，他就偷偷的溜走了，时间对于每个人都是公平的。我们每天在忙忙碌碌的日子里过去，是否过得有意义，浑浑噩噩的日子真的是我们所要的吗？到底我自己追]]>
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
