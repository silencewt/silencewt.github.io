<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silence 婷婷 Blog]]></title>
  <subtitle><![CDATA[既然选择远方，便风雨兼程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://silencewt.github.io/"/>
  <updated>2014-12-29T08:44:29.342Z</updated>
  <id>http://silencewt.github.io/</id>
  
  <author>
    <name><![CDATA[Wangt]]></name>
    <email><![CDATA[wangt_hust@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[车牌识别LPR（八）-- 字符识别]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AB%EF%BC%89-%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（八）-字符识别/</id>
    <published>2014-12-29T08:35:10.000Z</published>
    <updated>2014-12-29T08:43:04.000Z</updated>
    <content type="html"><![CDATA[<p>​第八篇：字符识别</p>
<p>　　车牌定位、车牌倾斜校正、车牌字符分割都是为车牌字符识别做的前提工作，这些前提工作直接关系到车牌识别系统的性能。车牌字符识别是车牌识别系统的核心部分，车牌字符识别的准确率是衡量车牌识别系统的一个很重要的指标。</p>
<p>　　一般字符识别的方法就是采用模式识别方法，简单的来说模式识别就是先通过提取输入模板的特征，然后通过模板的特征对样本进行分类，从而识别出样本。模式识别主要包括：数据采集、预处理、特征提取、特征匹配，其结构框架如图：</p>
<p>　　字符识别是模式识别的一个重要应用，首先提取待识别字符的特征；然后对提取出来的特征跟字符模板的特征匹配；最后根据准则判定该字符所属的类别。不同的训练方法，不同的特征提取， 不同的匹配规则，就相应的有不同的字符识别方法，基本上很多就是在这些地方做改进，或者是采用新的规则。但是万变不离其宗。</p>
<p><strong>（1）模板匹配字符识别算法</strong></p>
<p>　　模板匹配字符识别算法是图像识别中的经典算法之一，该算法的核心思想是：通过比较待识别字符图像的字符特征和标准模板的字符特征，计算两者之间的相似性，相似性最大的标准模板的字符即为待识别的字符。该方法首先要建立标准模板库，其中标准模板库中的字符的大小是一样的；然后将待识别的字符规格化，其大小应该和模板库中的字符一样；最后将待识别的字符和标准模板库中的所有字符进行匹配，计算相似度。模板匹配字符识别算法适用于印刷字体、字体规范的字符等，但是对字符变形、弯曲、字符旋转等情况的抗干扰能力差。</p>
<p><strong>（2）神经网络字符识别算法</strong></p>
<p>　　主要思想是：通过神经网络学习大量字符样本，从而得到字符的样本特征。当对待识别的字符进行识别时，神经网络就会将待识别字符的特征和之前得到的样本特征匹配，从而识别出字符。该算法主要利用神经网络的学习和记忆功能。神经网络虽然有其优点，但是由于采用神经网络识别字符依赖于初始的样本的选择，并且容易陷入局部最优和收敛速度慢，因此采用神经网络识别字符的算法仍需要改进。</p>
<p><strong>（3）支持向量机</strong></p>
<p>　　主要思想：同上，都是先得到样本特征，进行训练，然后再分类。SVM应该算是用的的最多的分类方法，一般大多适合于二分类问题，在这里就需要使用多分类器来构造。</p>
<h3 id="字符识别步骤："><strong>字符识别步骤：</strong></h3>
<h4 id="1、归一化">1、归一化</h4>
<p>　　主要包括位置归一化和大小归一化。由于本文处理的车牌字符都是标准的印刷体字符，且都进行过倾斜校正，所以不需要对其进行位置归一化。但由于摄像距离大小不一样，导致拍摄到的车辆图像中的车牌字符大小不一，为了达到更好的识别效果，就需要对分割出来的单个车牌字符进行大小归一化。常用的归一化方法有两种：一种是将字符图像的外边框按比例线性放大或缩小到规定尺寸；另一种是根据水平和垂直两个方向像素的分布进行大小归一化。一般用第一种。当映射到原图像的点的坐标不是整数，即位于几个像素之间，这就需要利用插值算法来决定该像素的值。使用常见的双线性插值法。将图像归一化为32*64的。</p>
<h4 id="2、特征">2、特征</h4>
<p>　　根据上一篇的介绍，采用LBP特征来识别汉字，均匀网格特征来识别字母和数字。</p>
<h4 id="3、分类器">3、分类器</h4>
<p>　　SVM作为分类器。支持向量机的原理，其所涉及到的数学知识比较复杂，自己编程实现的话有一定难度。采用现成的支持 SVM 的工具箱，公认做的比较好的是台湾大学林智仁(Chih-Jen Lin)教授开发的 LibSVM，支持 SVM 的各种算法，可以解决回归和分类识别问题。LibSVM 不但提供了 Windows 系统的可执行文件，还提供了 C 语言的源代码，方便科研工作者根据自己的需要进行改进，而且还提供了Java、Matlab、C#、Ruthon 等语言的接口。当然可以直接调用opencv中的SVM工具。 </p>
<p>　　汉字的笔画很稠密，字符分辨率非常低:如果对车牌汉字字符进行二值化，将会丢失汉字的很多重要的结构信息，产生不必要的噪声，导致笔画断裂和笔画粘连等。</p>
<h4 id="4、二次识别">4、二次识别</h4>
<p>　　总的来说，单个字符的识别率比较高，容易识别错的主要是相近字符，解决这类问题的最佳办法就是二次识别。将相似字符中的一个识别出来后，便能确定其属于哪一类相近字符类别,利用区分相近字符的细节特征，将这个字符到专门识别这类相近字符的分类器中进行二次识别。车牌字符中相近字符主要有5类，分为为“0”、“D”、“Q”，“B”、“8”，“2”、”Z”，“5”、”S”和“A”、“4”。</p>
<p>　　(1) “0”、“D、“Q”</p>
<p>　　从字符图像中可以看出,它们的区分在左侧和右下角，其中“D”的左边为直线，黑色像素点较多，而“0”和“Q”的左边均为弧线,黑色像素点相对较少；字符“Q”的右下角的笔画丰富，黑色像素较多。具体局部特征如图：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.1.png" alt="0dq"></p>
<p> 　　(2)“B、8“</p>
<p>　　它们的区别在字符的左侧,“8”的左侧为弧线,而“B”的左侧为直线。具体局部<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.2.png" alt="b8"></p>
<p>　　(3) “2、Z”</p>
<p>　　它们的区别在字符的上方，“2”的上方为弧线，“Z”的上方为直线，具体局部特征。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.3.png" alt="2z"></p>
<p>　　(4)“5、S”</p>
<p>　　它们的区别在字符的上半部分，“5”的上半部分中，上方和左侧均为直线,而”S”的上半部分为弧线。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.4.png" alt="5s"></p>
<p> 　　(5)“A、4”</p>
<p>　　由于存在倾斜等情况,仅仅通过基本特征会出现误识别,它们的区别在左下角。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.5.png" alt="a4"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>​第八篇：字符识别</p>
<p>　　车牌定位、车牌倾斜校正、车牌字符分割都是为车牌字符识别做的前提工作，这些前提工作直接关系到车牌识别系统的性能。车牌字符识别是车牌识别系统的核心部分，车牌字符识别的准确率是衡量车牌识别系统的一个很重要的指标。</p>
<p>　　一般字符识]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（七）-- 字符特征]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%83%EF%BC%89-%E5%AD%97%E7%AC%A6%E7%89%B9%E5%BE%81/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（七）-字符特征/</id>
    <published>2014-12-29T08:23:42.000Z</published>
    <updated>2014-12-29T08:29:16.000Z</updated>
    <content type="html"><![CDATA[<p>第七篇：字符特征</p>
<p>选择的字符特征应该满足以下条件：</p>
<p>　　（1）选取的字符特征具有较强的鲁棒性，不受字符变形、弯曲等影响。</p>
<p>　　（2）两个字符的字符特征不能完全相同，但部分相同是允许的，即选择的字符特征是唯一的，但是不能重复。</p>
<p>　　（3）选取的字符特征要尽可能的提供字符的信息。</p>
<p>　　（4）选择的字符特征提取方法易于实现，能够减少计算时间。</p>
<p>　　一般采用<strong>纹理、边缘特征</strong>。纹理特征是表示图像的另一种重要的视觉特征，纹理结构反映图像亮度的空间变化情况，具有局部与整体的自相似性。纹理是有纹理基元按某种确定性的规律或某种统计规律排列组成的，在纹理区域内各部分具有大致相同的结构。</p>
<h4 id="提取特征的的方法：">提取特征的的方法：</h4>
<p>　　（1）逐像素特征提取是指对整幅二值图像进行扫描，若图像中的像素点为黑色像素点时，则令特征值为 1，否则特征值为 0。经过该方法提取的特征向量的维数与图像中的像素点的个数相同。</p>
<p>　　（2）骨架特征提取是先细化字符图像，然后从细化后的字符图像中逐像素地提取特征。此方法适用不同大小的字符。</p>
<p>　　（3）垂直方法数据统计特征提取是首先对字符图像进行水平投影，统计水平投影值，此处的水平投影值为黑色像素的数目；然后通过对字符图像进行垂直投影，统计垂直投影值，此处的垂直投影值仍为黑色像素的个数；最后将水平和垂直投影值作为字符的特征向量。</p>
<p>　　（4）13 点特征提取方法的总体思路是：首先把字符平均分成 8 份，统计每一份黑色</p>
<p>　　像素点的个数作为 8 个特征。分别统计这 8 个区域中的黑色像素的数目，就可以得到 8 个特征；然后统计水平方向中间两行和垂直方向中间两列的黑色像素点的个数作为 4 个特征；最后统计所有黑色像素点的个数作为 13 个特征。</p>
<h4 id="常用的特征求取：">常用的特征求取：</h4>
<p><strong>一、粗网格特征：</strong></p>
<p>　　将归一化后的字符图像等分成 8×8 网格，统计各网格内黑像素的数量，取得一个 64 维的网格特征。</p>
<p>　　外围特征：提取字符外围特征的步骤为：</p>
<p>　　① 把归一化后的点阵图形等分为 8 行。</p>
<p>　　② 计算每一行中点从图像左边缘至第一项由白变黑的长度（如果没有由白变黑的点，则默认为零）。</p>
<p>　　③ 再计算每一行中点从图像左边缘至第二项由白变黑的长度（如果没有由白变黑的点，则默认为零）。</p>
<p>　　④ 仿照上面 3 个步骤，提取其它 3 个边缘的特征。</p>
<p>　　采用上述方法可以提取另一个 4×2×8=64 维的外围特征。</p>
<p>　　通过采用基于像素数量的粗网格特征与外围特征相结合方法可以提取字符的128 维特征，用以字符识别。</p>
<p><strong>​二、PCA进行汉字识别，网格特征进行数字和字母的提取。</strong></p>
<p>　　网格特征是指通过把二值化后的字符分成M×N个网格，统计每一个网格中的字符像素数量，把各个网格中的像素数量组合起来作为字符的网格特征来识别字符。字母数字相对于汉字来说笔画简单，也极少出现字符轮廓模糊的现象。因此，字母数字的识别相对来说比较简单。但是，字母数字之间存在相似字符的比例较高，而且相似字符之间的差异又比较小，很容易识别错。对字母数字的识别论文采用了二次识别的思想。</p>
<p><strong>三、均匀网格特征</strong></p>
<p>　　统计黑像素点在每个网格中所占的比例，属于统计特征中局部特征的一种，体现了文字点阵的整体形状的分布。它将字符图像二值化以后，再把样本字符图像分成mxn个M格，并统计每个网格中属于文字点阵的像数量，记为i；统计整个图像巾屈于文字点阵的像素数量，记为j；计算各个网格中的文字点阵的像素数量整个像中文字点阵的像素数量之比P=i/j将每个网格统汁的百分比P組合起来作为字符的统计特征，用以实现对字符的识别。好个网格屮的文字点阵比例反映了文字笔画在二维平面空间的分布特征。</p>
<p>　　网格特征的统计是以网格为单位进行的,即使个别像素点的统计有误差也不会对识别结果造成很大的影响，该特征还具有较强的区分相似字符的能力。此特征提取算法比较简单，计算速率很快,且易于实现,但其对字符图像配准要求较高，故需要在提取字符图像的特征之前，对图像进行去边框等预处理操作。此算法更适合印刷体等较规则的字体，而不适用于手写体。</p>
<p><strong>四、LBP特征进行汉字识别</strong></p>
<p>　　预处理模块对图像进行归一化操作；第二个模块计算出图像中每个像素点的LBP值；第三个模块用于将图像平均分割为MxN个网格；最后一个模块用于计算各块的LBP特征。</p>
<p>　　1、传统的LBP算法是基于3 X 3的窗口的，对应于9个灰度值。将该窗口的8邻域的灰度值与中心像素的灰度值比较，小于中心灰度值的像素点的置为0，反之将其置为1；然后，通过逆吋针或者顺时针将这8个二进制数转化为一个二进制序列，并求出其对应的十进制值，作为这个3X3窗口的中心像素点的特征值。即各像素点的LBP值。</p>
<p>　　2、将每个像素点的LBP值齊代它的灰度值,得到LBP阁像。并将LBP图像分块，对每个分块进行直方图统计。如,将LBP图像分为4<em>8块，每块大小为8</em>8。在每个分块内，将0-255的LBP值量化为32级，并进行直方图统计。即每个分块的LBP特征为32维。</p>
<p>　　3、将各个小块的LBP特征连起来，获得(4<em>8)</em>32=1024维的一个矢量，该矢量即为字符图像的LBP特征。</p>
<p>　　<strong>改进的LBP特征：</strong></p>
<p>　　均匀模式：它们有一个共同点，即在LBP二值编码序列巾，最多有两个0到1或1到0的变化。LBP二值编码序列为11000001，从1到0的变化为1次,从0到1的变化为1次，即它的均匀性U(LBP)=2。满足U(LBP)&lt;=2的所有模式称为均匀模式。在8邻域中，满足U(LBP)&lt;=2的所有模式的个数为8*(8-1)+2，具体的LBP二值编码序列与i/(Z及TMH]对应图见图2-16。再进一步将它们旋转到最小值后，具有旋转不变性的均勾模式(Rotation Invariant Uniform Pattern)的个数则为8+1。</p>
<p>　　模式对应的LBP二进制中从0变化为1和从1变化为0的次数之和小于等于两次，则该模式就是均匀模式。再根据顺时针或逆时针方向读出8个二进制数作为一个二进制序列,计算其对应的十进制值，作为该3*3矩形的中心元的特征值。反之，则该模式就不是均匀模式，它们的LBP值均为8+1。</p>
<p>　　由于改进的LBP特征是用58种均匀模式和统一后的一种非均匀模式来表示的。即在每个分块内，将0-255的LBP倍转化为59级。将这59级量化到0-63、64-127、128-191、192-255这四个区间中，并进行直方图统计。即每个分块的LBP特征为4维。</p>
<p>　　将各个小块的LBP特征连起来，获得(4*8)*4=128维的一个矢量，矢量即为字符图像的LBP特征。均匀模式时的LBP特征向量维数=图像分块数*59，改进的LBP特征向量维数=图像分块数*4，大大地提高了识别速率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第七篇：字符特征</p>
<p>选择的字符特征应该满足以下条件：</p>
<p>　　（1）选取的字符特征具有较强的鲁棒性，不受字符变形、弯曲等影响。</p>
<p>　　（2）两个字符的字符特征不能完全相同，但部分相同是允许的，即选择的字符特征是唯一的，但是不能重复。</p>]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（六）-- 字符分割]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AD%EF%BC%89-%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（六）-字符分割/</id>
    <published>2014-12-29T07:56:00.000Z</published>
    <updated>2014-12-29T08:17:23.000Z</updated>
    <content type="html"><![CDATA[<p>第六篇：字符分割</p>
<p>　　在知道了车牌字符的规律之后，可以根据车牌的特点对字符进行分割。一般最容易想到的方法就是根据车牌投影、像素统计特征对车牌图像进行字符分割的方法。是一种最常用的、最基本的、最简单的车牌字符分割方法。它的精髓是对车牌图像进行逐列扫描，统计车牌字符的每列像素点个数，并得到投影图，根据车牌字符像素统计特点（投影图中的波峰或者波谷），把车牌分割成单个独立的字符。</p>
<p>　　图像的边缘信息一般都是高频信息，所以在水平、垂直方向上对车牌图像进行小波变换，对其高频信息进行重构，获得相应的高频信息方面的子图，在车牌垂直投影图像中找到每个车牌字符的边界所在位置，并记下边界位置的横坐标；同理在水平投影图像中找到相应的边界的纵坐标，再根据相应的字符坐标值将字符分割出来。</p>
<p>　　一般在进行分割之前需要对车牌进行预处理：倾斜校正和去噪处理。</p>
<p>　　在进行分割之后需要统一字符大小，对其进行归一化和去边框处理。</p>
<p><strong>（1）统一车牌底色：</strong></p>
<p>　　对不同类型的车牌灰度图像进行二位化以后，有的呈现的是黑底白字，而有的则是白底黑字，为了便于对字符进行分割，需首先将不同种类车牌的二值化结果进行景颜色和目标颜色的统一，然后再用相关字符分割的方法对车牌屮的字符进行切分和提収。统一车牌底色可以有两种方法：</p>
<p>　　基于颜色分量的判断，但由于我国车牌种类太多，这个方法并不能完全区分，但是区分两种车牌类型还是可以的，例如蓝底白字车牌中的R小于B，而黄底黑字中的B大于R，在考虑到光照影响和使用已久褪色车牌上这种方法就不好了。</p>
<p>　　基于二值图像中像素比例特征的车牌底色判断：一般情况下，二值化后的车牌图像中字符笔画的像素个数在整个车牌的像素数目中所占的比例要小于50%。因此，可以通过分别计算二值化后的车牌中两种像素值的像素个数的大小来判断是否需要反色，若目标像素的比例大于50%，则将图像进行反色，否则不进行处理。这种方法的优点是算法简单，适用各种底色类型的车牌。缺点是若车牌中含有的字符的笔画较粗或者是车牌上存在较多污点或者是有装饰物等因素影响时，往往不能准确的判断底色。</p>
<p><strong>（2）图像去噪</strong></p>
<p>　　采集的图像总是会受到各种噪声的影响。为了保证后续处理的精确度，需要抑制图像中的噪声。对二值化后的车牌图像进行中值滤波处理，它是一种常见的非线性滤波方法，是一种局部平均的图像平滑技术，也是一种低通滤波。经典的中值滤波算法步骤如下：</p>
<p>　　1、令一个 3*3模板沿行或者列方向的移动；</p>
<p>　　2、每次移动后，对模板覆盖区域的像素灰度值进行排序；</p>
<p>　　3、用排序得到的中值代替模板内中心位置的原始图像像素灰度值。</p>
<p>　　通过以上步骤可以看出，中值滤波的主要功能就是让与周围像素灰度值的绝对差较大的像素改为与周围像素灰度值接近的灰度值，去除那些相对于其领域像素更亮或更暗的灰度。一般来说，小于中值滤波器模板面积一半的亮或暗区域会被滤掉，而较大的物体则会几乎原封不动的保留下来。</p>
<p><strong>（3）倾斜校正</strong></p>
<p>　　通常车牌区域的上下沿是两条明显的平行直线，一般都采用Hough 变换，检测出这两条直线的倾斜角，然后对车牌进行校正。然而传统的 Hough变换是对整幅图像的每个像素进行计算，以求出图像中可能存在的直线。</p>
<p>　　要想使用 Hough 变换计算车牌的倾斜角度，必须先确定进行 Hough 变换所需要的数据，即车牌的边缘点。如果图像包含完整的车牌，一般采用检测车牌的上下边框边缘点来作为 Hough 变换的数据，但由于实际得到的车牌不一定含有边框或者只有极少量的边框，所以最常用的是直接检测车牌每个字符上下边缘点作为Hough 变换的数据来源，但是由于实际中得到的车牌含有噪声、污损等原因，用这种方法会产生大量的干扰点，影响校正效果。</p>
<p>　　方法：对车牌图像在垂直方向进行投影并用高斯滤波器进行平滑，定位投影曲线中的所有波谷点，然后在相应的二值图中，查找所有波谷点之间最高的连通区域，得到的各个区域大部分就是车牌中的各个字符，最终选取各个连通域中即字符的最高和最低点作为 Hough 变换的检测点。对图像进行旋转时采用双线性插值。 </p>
<p><strong>（4）去边框</strong></p>
<p>　　定位出来的车牌图像往往会包含车牌的部分或者全部边框，甚至还包含部分车身，为车牌字符分割带来了不利影响。因此就需要先对车牌图像进行去边框处理，其原理如下：采用水平投影得到上下边界。</p>
<p><strong>（5）字符分割</strong></p>
<p>　　采用一种基于相邻字符最大间隔宽度的方法来对车牌中的字符进行分割。由单行车牌的特点可以知道，在第二个字符和第三个字符之间存在一个圆形的间隔符，且该间隔符在每个单行车牌中有且仅有一个，还有一个重要的特点就是此间隔符所在的间隙约是其他相邻字符之间间隙的2.6倍，是整个车牌图像中相邻字符的最大间隙，根据这一先验知识首先确定了第二个字符右边缘和第三个字符左边缘的位置，然后由二值图像的垂直投影及单个字符的高宽比确定后5个和前2个字符的精确位置，因此，该方法的最为关键的部分是寻找图像中间隔符所在的空隙。</p>
<p>　　采用连通域和投影相结合的方法来对车牌图像进行字符分割，采用四连通标记法对车牌字符边界进行标记，形成连通域；然后判断各个区域的高宽是否基本等于车牌字符区域的高宽（去边框时已经求出），若相差较大时，就进行垂直投影，把宽小于车牌字符宽的相邻区域进行合并，把宽大于车牌字符宽的相邻区域进行进一步分割；最后对各个区域加矩形边框，提取单个车牌字符。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr6.jpg" alt="分割"></p>
<p>　　在理想的情况下，波谷的值应该为零，并且两个字符之间应该存在波谷，但是由于受到噪声的干扰，使得波谷的值为非零。常见的字符分割的问题有：字符粘连、字符断裂、数字“1”。字符粘连是指两个以上的字符连在一起，在垂直投影上的表现是原本应该为波谷的地方，现在却为非零的垂直投影值；字符断裂是一个字符分裂为几部分，在垂直投影上的表现为几段垂直投影；数字“1”的垂直投影值比较小，容易误判为噪声。可以结合车牌中字符的几何特征解决上述问题。设车牌中字符的宽度为 Width。</p>
<p>　　1）字符粘连</p>
<p>　　当 Width&lt; charWdith &lt; 1.5<em>Width，其中 charWidth 为粘连字符的宽度。此时为两个字符粘连的情形。可取 charWidth / 2 作为单个字符的宽度，以此来分割两个粘连的字符；若 1.5</em>Width&lt; charWidth&lt; 2*Width，此时为三个字符粘连的情况。通过单个字符具有固定的宽高比的先验知识，利用字符的高度求出字符的宽度。然后根据字符的宽度对粘连的字符进行分割。</p>
<p>　　2）字符断裂</p>
<p>　　若 charWidthi&lt; 0.5<em>Width 且 0.5</em>Width &gt; charWidthi+1。其中 charWidthi为当前字符的宽度，charWidthi+1为下一个字符的宽度。此时把当前字符和下一个字符合并。</p>
<p>　　3）数字“1”</p>
<p>　　当 charWidthi&lt; 0.5<em>Width 且 0.5</em>Width &lt; charWidthi+1时，统计区间宽度 charWidthi内的投影值大于 0.8*Height 的个数 nums，其中 Height 为车牌图像的高度。当符合条件 nums ≥ Thresh 时，其中 Thresh 为阈值，此时判定为数字“1”，否则为噪声。</p>
<p>　　<em>采用的车牌字符分割方法；对车牌图像进行灰度化处理，去除颜色信息，使后面的字符分割算法运行速度更快；对灰度车牌图像进行二值化处理（otsu），并统一车牌图像的背景和字符的颜色；对有一定倾斜角度的车牌图像进行倾斜校正处理，对车牌图像进行去边框处理；采用连通域与投影法相结合的方法对车牌图像进行字符分割，为后面的单个字符识别做准备。</em></p>
<p>​</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第六篇：字符分割</p>
<p>　　在知道了车牌字符的规律之后，可以根据车牌的特点对字符进行分割。一般最容易想到的方法就是根据车牌投影、像素统计特征对车牌图像进行字符分割的方法。是一种最常用的、最基本的、最简单的车牌字符分割方法。它的精髓是对车牌图像进行逐列扫描，统计车牌字]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（五）-- 一种车牌定位法]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%BA%94%EF%BC%89-%E4%B8%80%E7%A7%8D%E8%BD%A6%E7%89%8C%E5%AE%9A%E4%BD%8D%E6%B3%95/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（五）-一种车牌定位法/</id>
    <published>2014-12-29T07:52:14.000Z</published>
    <updated>2014-12-29T07:53:15.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em>该方法是某个文章中看到的，有点忘了是那一篇了，看的太多也太久了。</em></strong></p>
<p><strong>Step1、把采集到的RGB图像转换为HSI图像。</strong></p>
<p>　　HSI模型能反映人对色彩的感知和鉴别能力，非常适合基于色彩的图像的相似比较，故采用HSI模型。假设HSI颜色模型各分量为H、S、I ，RGB 彩色模型的各个分量为 R,  G ,B ，则 RGB 转换 HSI 的公式为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.1.jpg" alt="公式1"></p>
<p>　　其中H表示色调，如红色、绿色、蓝色等，色调的取值范围为[0,360]，其对应颜色轮的角度。S表示饱和度，其意义是颜色的鲜艳度，可以用百分比来表示，从0%到完全饱和100%。 I表示亮度，是指颜色的明亮程度，通常用百分比表示，从黑0%到白100%。</p>
<p>　　通过式把 RGB 彩色图像转换为 HSI 彩色模型的图像，HSI 彩色模型的图像，左侧为 RGB 彩色图像。从 HSI 颜色的图像中可以看出，高亮部分为车牌的蓝色区域。</p>
<p><strong>Step2、提取 HSI 图像中的 H、S 分量。</strong></p>
<p>（1）利用 H 分量进行图像颜色分割。由于蓝色的 H 分量值为 240 º，并且图像可能受到噪声污染，所以蓝色的 H 分量值有一定的波动。经过实验可得到蓝色分量 H 的最小值blue_MinH 为 220º，最大值 blue_MaxH 为 245º。假设二值图像为 Bw，Bw 和 HSI 图像具有相同的大小，Bw 中的所有元素都为 0。利用下式把满足蓝色区域条件的设为前景白色，即 Bw = 1；不满足条件的设为背景黑色，即Bw = 0。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.2.jpg" alt="公式2"></p>
<p>（2）利用S分量对图像处理。因为受到天气、光照等条件的影响，非牌照区域也会和牌照区域的色调特征相同，因此可以利用 S 分量去掉饱和度小且满足蓝色色调范围的区域。设饱和度的阈值为 threshS，利用去掉满足蓝色色调条件但非车牌的区域。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.3.jpg" alt="公式3"></p>
<p><strong>Step3、利用车牌的几何特征去除候选区域中的非牌照部分。</strong></p>
<p>　　由于天气、光线等因素导致采集到的图像受到噪声的干扰，所以即使经过 Step1、Step2 的处理，仍然可能存在多个车牌的候选区域。利用车牌的几何特征可以过滤掉部分不符合条件的候选区域。常用的车牌几何特征有：候选区域的面积、外接矩形的宽度和高度、外接矩形的长宽比，本文采用候选区域的高度。具体做法如下：通过对 Step2 得到的二值图像 Bw 水平投影，得到水平投影图，其中水平投影值是同一行中的像素点的个数。基于车牌区域存在一定的高度的事实，设定车牌高度的最小值为 Height_Min,最大值为 Height_Max,候选区域的高度为 Heigh。当满足 Height_Min ≤ Height ≤ Height_Max 时，从图像中提取出高度为 Height 的候选区域。</p>
<p><strong>Step4、为处理车辆和车牌颜色特征相同的情况，可以通过特征颜色边缘检测去除和车牌颜色特征相同的伪车牌区域。</strong></p>
<p>　　设图像 K(i,j)= (H(i,j),S(i,j), I(i,j))，其中 H(i,j),S(i,j), I(i,j)分别表示 K(i,j)的 H、S、I 分量。二维数组 K2(i,j)是边缘检测后的图像。采用以 K(i,j)为中心的 3×3窗口检测特定的颜色边缘。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.4.jpg" alt="公式4"></p>
<p>（1）在 HSI 彩色模型中，满足式前两式时判为蓝色；满足式（2.4）则为白色。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr5.5.jpg" alt="公式5"></p>
<p>（2）获取蓝白边缘图像。判断蓝白边缘的条件为：（a）K(i-1,j-1)、K(i,j-1)、K(i+1,j-1)都为蓝色像素点，K(i-1,j+1)、K(i,j+1)、K(i+1,j+1)均为白色像素点；（b）K(i-1,j-1)、K(i,j-1)、K(i+1,j-1)都为白色像素点，K(i-1,j+1)、K(i,j+1)、K(i+1,j+1)均为蓝色像素点。若满足（a）、（b）中的任意一个条件，则 K(i-1,j)、K(i,j)、K(i+1,j)为蓝白边缘点，令 K2(i-1,j)= K2(i,j) = K2(i+1,j) = 1，并将该窗口中的 K2 其它像素设为 0；若以上条件均不满足，则将该窗口位置的 K2 中的所有像素值置为 0。同时将窗口遍历整幅图像，得到蓝白边缘图。</p>
<p>（3）利用车牌的几何特征去掉不符合条件的候选区域。面积大小的计算定义为：蓝白边缘图像中白色的像素点的总数，即为 white_CountTotal。设车牌区域面积的最小值为 min_Area，最大值为 max_Area。当 min_Area ≤ white_CountTotal 并且 white_CountTotal ≤ max_Area,则认为是车牌区域。</p>
<p><strong>Step5、确定车牌区域的宽度。</strong></p>
<p>　　经过前面的步骤已得到车牌区域，确切的说应该是车牌的高度，所以还需得到车牌的宽度。本文采用垂直投影的方法确定车牌的宽度。对车牌区域进行垂直投影。垂直投影值定义为图像中同一列为白色像素点的个数，记为vertical_Count，令垂直投影值的阈值为 verticalValue_Thresh。</p>
<p>　　具体过程如下：</p>
<ul>
<li>首先从图像的最左边扫描图像的垂直投影值，当 vertical_Count ≥verticalValue_Thresh时，该位置即为车牌区域的起点 wide_Start ；</li>
<li>然后继续扫描直到vertical_Count ≤ verticalValue_Thresh 时，此位置则为车牌区域的终点 wide_End；</li>
<li>最后得到车牌区域的宽度 wide = wide_End – wide_Start。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong><em>该方法是某个文章中看到的，有点忘了是那一篇了，看的太多也太久了。</em></strong></p>
<p><strong>Step1、把采集到的RGB图像转换为HSI图像。</strong></p>
<p>　　HSI模型能反映人对色彩的感知和鉴别能]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（四）-- 车牌定位]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%9B%9B%EF%BC%89-%E8%BD%A6%E7%89%8C%E5%AE%9A%E4%BD%8D/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（四）-车牌定位/</id>
    <published>2014-12-29T07:24:23.000Z</published>
    <updated>2014-12-29T07:37:06.000Z</updated>
    <content type="html"><![CDATA[<p>第四篇：车牌定位　　</p>
<p>　　车牌定位就是采用一系列图像处理或者数学的方法从一幅图像中将车牌准确地定位出来。车牌定位提取出的车牌是整个车牌识别系统的数据来源，它的效果的好坏直接影响到整个系统的表现，只有准确地定位出车牌，才会有后续的车牌分割与字符识别。</p>
<p>　　目前车牌定位有两大类、基于灰度、基于彩色。</p>
<h4 id="基于灰度：">基于灰度：</h4>
<p>　　我们采用的是<strong>基于灰度的形态学的车牌定位</strong>：首先根据车牌区域中丰富的纹理特征，提取车牌图像中垂直方向的边缘并二值化。然后对得到的二值图像进行数学形态学(膨胀、腐烛、幵闭运算等)的运算，使得车牌区域形成一个闭合的连通区域。最后通过车牌的几何特征(高、宽、宽高比等)对得到的候选区域进行筛选，最终得到车牌图像。</p>
<p>　　<strong>基于灰度的还有边缘检测的车牌定位</strong>：由于车牌字符的灰度值与车牌底色的灰度值相差较大，字符与底色的交界处就有灰度突变，灰度突变处就会产生边缘，这是车牌定位技术中非常重要的特征。也可以通过检测车牌的外边框来定位车牌，由于外边框的上下左右四边都为直线，而且有明显的边缘特征，所以首先利用边缘检测算法提取车牌边框位置，然后，用Hough变换算法检测直线，确认外边框的上下左右四条边位置就确定了车牌在图像中的位置。</p>
<p>　　<strong>基于投影法的车牌定位方法</strong>：首先对车牌图像进行二值化，由于车牌区域存在明显的剧烈的字符与背景的灰度跳变，将跳变次数投影到垂直轴上，那么车牌区域对应的垂直轴上会有一个明显的峰值，这样可以得到车牌的上下边界。然后对上下边界内的区域进行水平投影，字符区域会出现明显的峰值，这样可以得到车牌的左右边界。这种方法比较理想化。</p>
<p>　　<strong>基于纹理分析的车牌定位方法</strong>：所谓的纹理特征是指对图像进行扫描得到的灰度变化曲线，由于扫描经过车牌得到的变化曲线明显不同于经过非车牌得到的曲线，根据这个特点再结合形态学操作和其它先验知识就能从图像中提取出车牌。</p>
<h4 id="基于彩色的：">基于彩色的：</h4>
<p>　　从颜色空间的角度来看，HSV (Hue色调，Saturation饱和度，Value亮度)颜色空间具有线性伸缩性，比RGB颜色空间更容易区分色彩。HSV车牌定位典型的思路是首先将车牌图像从RGB空间转换到HSV空间，然后寻找图像中含有蓝白相间、黄黑相间、白红相间和白黑相间的地方，对得到的候选区域进一步用字符颜色提取车牌字符，最后用车牌的字符特征确定车牌位置。基于彩色图像的车牌定位方法对字符颜色和背景颜色固定的车牌可以取得较好的效果。</p>
<p>　　<strong>基于彩色图像的边缘检测和区域生长相结合的车牌定位</strong>：实现该方法的基本思想是：首先可以利用边緣检测算子对原始彩色(RGB空问)图像进行边缘检测，使得车牌区域的纵向纹理特征得到增强；接着利用数学形态学中的膨胀算法实现区域的连通，然后采用区域生长的方法对候选区域进行标记，最后利用车牌具有的特征和字符排列的频率特点，去除伪车牌区域，得到车牌区域。</p>
<p>　　<strong>基于纹理和颜色综合特征的车牌定位</strong>：首先将原始彩色图像M0的颜色空间转化到HSV颜色空间Ml；接着对Ml进行色彩分割，把所需要的颜色的区域设置为前景白色，其他区域设为背景黑色，此时得到图像M2，其次对M2采用区域生长的方法进行处理，并生成连通区域，得到车牌区域的集合A，然后若集合A中不包含车牌，则继续对Ml进行色彩分割，提取下一块前景颜色区域，并对该区域进行车牌特征分析，重复上述过程。</p>
<p>　　<strong>车牌轮廓特征判断条件</strong>：</p>
<pre><code>（1）外接轮廓的高度大于5个像素或小于25个像素

（2）外接轮廓的宽度大于20个像素或小于80个像素

（3）外接轮廓的宽高比大于2或小于10
</code></pre><p> 　　由于我国车牌种类繁多，颜色组合不一致，会遇到以下问题：一方面各地发放的车牌的底色色调会有所不同，另一方面受自然光照变化影响，采集到车牌图像的色度的变化范围也很大。因此，定位我国车牌的方法不适宜直接利用颜色信息进行定位。</p>
<p>　　其实，还有一些文献里提出<strong>支持向量机和adaboost等分级分类的定位方法</strong>，虽然使用训练的方法可以很准确的得到车牌图像，但是实际中由于环境的复杂性，单纯的一种方法并不不能得到很好的结果。对图像进行预处理，结合三次定位，像素统计粗定位，颜色阈值定位，文理特征定位，一次次的精确定位结果，调整参数，知道得到正确的车牌图像。</p>
<p>　　这里有涉及到边缘检测的应用，其中边缘检测就有几种常用的算子方法。还涉及颜色空间的转换，这里不做具体展开。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第四篇：车牌定位　　</p>
<p>　　车牌定位就是采用一系列图像处理或者数学的方法从一幅图像中将车牌准确地定位出来。车牌定位提取出的车牌是整个车牌识别系统的数据来源，它的效果的好坏直接影响到整个系统的表现，只有准确地定位出车牌，才会有后续的车牌分割与字符识别。</p>
<]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（三）-- LPR系统整体结构]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%89%EF%BC%89-LPR%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（三）-LPR系统整体结构/</id>
    <published>2014-12-29T07:14:11.000Z</published>
    <updated>2014-12-29T07:23:27.000Z</updated>
    <content type="html"><![CDATA[<p>第三篇：系统的整体架构</p>
<p>　　LPR系统大体上可由图像采集系统，图像处理系统，数据库管理系统三个子系统组成。它综合了通讯、信息、控制、传感、计算机等各种先进技术，构成一个智能电子系统。</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr3.jpg" alt="LPR整体结构"></p>
<p>　　<strong>图像采集系统</strong>：图像采集系统主要由传感器、辅助照明设备和图像采集设备组成，主要功能是采集车辆图像。当有车辆经过时会触发感应装置，感应装置一般为地感线圈，触发成功后摄像机或照相机会自动采集当前的图像，最后将采集到的图像传送到计算机或手持的嵌入式系统进行处理。</p>
<p>　　<strong>图像处理系统</strong>：图像处理系统即为本文主要讨论的算法处理模块，为整个系统的软件部分。它主要包括图像预处理、车牌定位、字符分割和字符识别四个部分，它的任务是运用数字图像处理、模式识别等学科对获得的车辆图像进行处理以获得车牌上的字符内容信息，后面章节讲对它每一个部分做一个粗略的介绍。</p>
<p>　　<strong>数据管理系统</strong>：数据管理系统是一个后端管理数据库，它包含了几乎所有的图像输入是指利用摄像机或者数码相机采集到的车牌图像。车牌图像的质量与采集图像的设备和实际环境有关。性能好的摄像机能够得到质量更好的车牌图像，有利于识别车牌图像中的字符。在光照不均、恶劣天气的环境下，采集到的车牌图像的像质较差，导致车牌识别系统的性能降低。车牌登记信息，车牌中的字符信息被识别出来后就输入到这个系统进行查找对比，以方便公安机关追查被盗车辆，打击犯罪分子。</p>
<p>　　其中<code>图像处理模块</code>主要包括六个部分：<code>预处理</code>、<code>车牌定位</code>、<code>倾斜校正</code>、<code>字符分割</code>、<code>字符识别</code>。其中，<strong>车牌定位</strong>、<strong>字符分割</strong>、<strong>字符识别</strong>是车牌识别的关键技术。流程图如下：</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr4.jpg" alt="识别算法流程"></p>
<p>　　<strong>图像预处理</strong>是指对采集到的图像进行二值化、边缘检测、去除噪声、图像灰度化等操作。经过预处理的车牌图像增能够强目标图像，提高目标和背景图像的对比度，方便车牌识别的后续工作。</p>
<p>　　<strong>车牌定位</strong>是从一幅拍摄到的图片中定位出车牌的位置，并从图片中提取出车牌图像。车牌定位正确与否直接影响到字符分割和识别的工作，是所有关键技术中的第一步。</p>
<p>　　<strong>倾斜校正</strong>是指检测车牌图像的倾斜角度，并校正车牌图像。倾斜的车牌图像会导致车牌中的字符倾斜，直接影响到车牌字符的分割和识别，因此必须对倾的车牌图像进行校正。</p>
<p>　　<strong>字符分割</strong>是对提取出的车牌图像进行切割，从车牌图像中提取出单个车牌字符的图像。由于字符识别是以分割出的单个字符为输入，所以字符分割的准确与否直接影响到字符识别。</p>
<p>　　<strong>字符识别</strong>是指对分割出的字符进行处理，识别出车牌中的字符。因为我国的车牌号码的字符包含：汉字、英文字母、数字，增加了对字符识别的难度。字符识别直接影响到整个车牌识别系统结果的准确性。</p>
<p>　　这是一个LPR系统最基本的结构组成，每个模块的功能也清晰的给出来了，这对于后续我们的分工有很大的帮助，模块与模块之间耦合度也比较小。</p>
<p>　　<em>基于Linux的车牌识别系统，界面基于qt开发，图像处理模块基于opencv，数据库使用的mysql，基本上是在原有的系统上进行修改。原有的系统是在window平台下，使用MFC，opencv的版本是之前的C版本，按照新的架构重新修改代码，数据库部分基本没变，重点更新的是图像处理部分。</em></p>
<p>　　最后，在开发 LPR 算法之前，要<strong>确定算法的目的和要求</strong>。LPR 算法的最终目的是识别车辆的车牌号码，所以识别正确率自然是系统设计中应该首要考虑的因素。影响识别正确率的因素有很多，主要的有以下几点：一是定位的准确性；二是识别前字符的预处理；三是字符识别的算法。为了提高识别正确率，需要对现有的车牌字符识别算法进行改进，在后面的章节中会有详细的介绍。</p>
<p>　　其次，LPR 算法在工作时需要实时处理交通流量信息，所以系统的工作效率——即识别时间也是系统设计时必须要考虑的因素，一般要求在 1s 内能够完成识别，这就要求识别算法的复杂度、运算量不能太大。</p>
<p>　　除了算法识别正确率和识别时间外，算法软件的操作界面应尽量简单、友好，还要考虑系统的无故障运行时间，系统体积的大小等因素。最后，算法设计要面向现场、面向终端客户的需求，考虑到 LPR 系统在户外工作，所以要克服外面环境的复杂性及光照条件的变化，设计出一套适应性较强的算法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第三篇：系统的整体架构</p>
<p>　　LPR系统大体上可由图像采集系统，图像处理系统，数据库管理系统三个子系统组成。它综合了通讯、信息、控制、传感、计算机等各种先进技术，构成一个智能电子系统。</p>
<p><img src="http://7te8s4.com1.z0]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（二）-- 车牌特征及难点]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BD%A6%E7%89%8C%E7%89%B9%E5%BE%81%E5%8F%8A%E9%9A%BE%E7%82%B9/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（二）-车牌特征及难点/</id>
    <published>2014-12-29T07:01:47.000Z</published>
    <updated>2014-12-29T07:12:37.000Z</updated>
    <content type="html"><![CDATA[<p>第二篇：车牌的特征及难点分析</p>
<h3 id="2-1_对我国车牌的认识">2.1  对我国车牌的认识</h3>
<p>　　我国目前使用的汽车牌号标准是 2007 年开始实施的《中华人民共和国机动车号牌》GA36-2007（2010 年修订）。根据 GA36-2007 对机动车牌号编排规则规定，我国汽车的车牌构造特点如下：</p>
<p>　　汽车车牌号的编排规则：我国的标准车辆车牌是由一个省份汉字（军警车牌为其他汉字）后跟字母或阿拉伯数字组成的 7 个字序列。标准车牌的的具体排列格式是：X1X2·X3X4X5X6X7，X1是各省、直辖市的简称或军警，X2是英文字母，代表该汽车所在地的地市代码，比如 A 代表省会，B 代表该省的第二大城市，C 代表该省的第三大城市，X3X4X5X6X7为英文字母或阿拉伯数字，2010年以前车牌号码的分布规律是，前面是字母，后面是数字。但是，随着车辆保有量的增加，每个字母所属号段越来越不够用。按照新《中华人民共和国机动车号牌》（2010 年修订）标准，将允许字母在后五位编码中任意一位出现，但不能超过两个。除了第一个汉字外，字母和数字的笔画在竖直方向都是联通的。</p>
<p>牌照类型如下图：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr1.jpg" alt="拍照类型"></p>
<p>　　绝大部分的汽车牌照的宽度为1100px，高度为350px，牌照上一共有7个或8个字符，其中，每个字符的宽度为45mm，高度为90mm，间隔符的宽度为10mm，除了第二个和第三个字符之间的间距为 34mm 外，字符之间的间隔宽度12mm。民用的汽车牌照上有所属省、自治区或直辖市的简称(军用、警察牌为其他汉字)，监督机关及发证照的代号(大写的英文字母)后跟阿拉伯数字或英文字母组成的7个字符序列。<br>　　<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr2.jpg" alt="车牌"><br>　　<br>　　可以简单的归纳为以下特征：</p>
<p>　　1、颜色特征：即前面的六种类型，采用了对比度较为强烈的两种颜色的组合使车牌能明显区分于其它物体，而且车牌边框为白色或黑色两种颜色。使领馆车牌中的“使”和“领”字为红色，港澳出入境车牌中的“港”和“澳“两字为白色。警用汽车摩托车为白底黑字组合，其中”警“字为红色。</p>
<p>　　2、车牌具有统一的标准尺寸，这便于字符的分割和车牌的定位。</p>
<p>　　3、边缘特征：汽车的车牌边框是有规则的边缘，由于汽车车牌的字符排列规则，汽车车牌的垂直边缘比水平边缘更为丰富，而汽车的车身却有丰富的水平边缘，垂直边缘不明显。</p>
<p>　　4、黑白跳变特征：车牌区域二值化后，字符和背景为一黑一白，存在明显的黑白跳变，且跳变的次数在一定范围内。</p>
<p>　　5、投影特征：汽车车牌图像进行垂直投影后的图像是由波峰、波谷交替组成的连续分布图，垂直投影后的图像会有约七个波峰或波谷区；汽车车牌图像进行水平投影后的图像中灰度跳变的像素点数累加值很大。</p>
<p>　　了解我国车牌的特征，有利于后续对车牌进行的各种操作，在项目步骤中，这属于对需求目标的全面了解。对车牌的了解不能跳过，因清楚的知道我们所要处理的的目标的各个特性，这样才有利于我们利用这些特性来操作车票图像。</p>
<h3 id="2-2_技术难点">2.2 技术难点</h3>
<h4 id="2-2-1、车牌定位中的难点">2.2.1、车牌定位中的难点</h4>
<p>　　从环境等客观因素上来说，汽车的类型有很多且构造不同，使得不同汽车上的悬挂车牌的位置就会不同。这样，汽车车身与车牌区域出现相似的颜色、纹理，就很可能会造成车牌定位出错或需更长的时间才能定位出车牌。</p>
<p>　　车牌定位是指从拍摄的含有车牌的图像中定位出车牌的淮确位置，然后进一步的提取出车牌图像。其主要的难点有：</p>
<ul>
<li>周围环境因素，比如随机噪声，天气气候(雪天，雨天，雾天等)，光线(白天强光，晚上漆黑等)等。</li>
<li>车牌自身因素，比如车牌倾斜，字迹模糊，车牌乱挂装饰物，车牌周围广告标语覆盖或干扰等。</li>
</ul>
<h4 id="2-2-2、字符分割中的难点">2.2.2、字符分割中的难点</h4>
<p>　　字符分割是指从含有字符的车牌图像中将字符分割出来，字符分割的好坏会直接影响到下一步的字符识别。其主要的难点有：</p>
<ul>
<li>光照影响，不的照射光源(车灯，太阳光或辅助光源)，不同的气候条件(雨雪阴晴)，不同的光照角度。</li>
<li>汽车由于长途奔袭，再加上风吹日晒等各种原因，车牌上的字符可能会粘连，缺损或断裂，这会给字符分割带来一定的麻烦。</li>
<li>缺乏统一的车牌标准，车牌主要包括普通车牌，外事车牌和军用车牌等，这些车牌的规格，适用范围和颜色各有不同。</li>
</ul>
<p>实际应用中，摄像设备所放的方位和角度有可能造成拍摄出来的车牌图像倾斜、畸变或部分被遮挡；当汽车处于高速行驶时，所拍摄的车辆图像清晰度不高；背景复杂的车辆图像，定位会有一定的困难，对后续的字符分割和字符识别带来严重的困难。</p>
<h4 id="2-2-3、字符识别中的难点">2.2.3、字符识别中的难点</h4>
<p>　　字符识别是指将分割好的字符图像送到分类器中，对图像中的字符进行识别。字符识别是整个车牌识别系统中的最后一步，也是最为关键的一步。主要的难点有：</p>
<ul>
<li>车牌汉字中繁多的字符笔画，汉字较字母和数字的识别难度较大。</li>
<li>字符图像的分辨率较低时使得字符笔画结构特征不明显，特征难以提取。 </li>
<li>相似字符的识别(B和8，D和0等)。</li>
</ul>
<p>从算法上来说，由于采集到的车辆图像质量不高，存在噪声、图像模糊失真、车牌污损、其它字符区域干扰等情况，车牌识别技术中定位、分割、识别实现起来都有很多困难。算法的简捷、实用、快速往往和算法的速度形成冲突。怎样提高现有算法的识别率和速度，如何利用车牌的彩色信息进行车牌识别，一幅图像中多个车牌的情况怎样识别，怎样满足系统实时性要求等，这些都是车牌识别有待研究和解决的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第二篇：车牌的特征及难点分析</p>
<h3 id="2-1_对我国车牌的认识">2.1  对我国车牌的认识</h3>
<p>　　我国目前使用的汽车牌号标准是 2007 年开始实施的《中华人民共和国机动车号牌》GA36-2007（2010 年修订）。根据 GA36-2007]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（一）-- 研究背景]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%80%EF%BC%89-%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（一）-研究背景/</id>
    <published>2014-12-29T06:48:22.000Z</published>
    <updated>2014-12-29T06:53:24.000Z</updated>
    <content type="html"><![CDATA[<p>　　在年尾用了几天的时间将2014年的所有工作都总结了一遍，将之前的文档综合了下。</p>
<p>　　以下是LPR系统，车牌识别的一些总结资料。</p>
<p>第一篇：LPR研究背景</p>
<p>　　汽车的出现改变了以往出行徒步和以马代步的时代，极大地改变了人们的生活方式，扩大了人们的活动范围，加强了人与人之间的交流。全世界的汽车拥有量呈爆炸性增长，汽车虽方便了我们的出行，但同时也造成了城市交通压力，应用现代科技解决汽车不断增长而出现的交通问题已经成为一项重要的研究课题，智能交通系统应孕而出。</p>
<p>　　智能交通系统(Intelligent Transportation System，简称 ITS)是一种充分利用各种先进的高新技术来实现实吋、准确、高效的交通管理系统，使交通更畅通更安全，它也是一种交通信息服务系统，使人们出行更方便更快捷。随着智能交通系统的快速发展，智能交通系统已经融入人们的日常生活，使人们的生活越来越方便。车辆是智能交通系统中的重点研究对象，每辆车都有自身唯一的车牌号码，车牌号码反映了车辆信息以及关联着车主信息，通过车牌号码可以记录对应车辆的交通行为，因此，车牌识别技术是智能交通系统中最核心最基础的技术之一，决定着智能交通系统的发展速度和技术水平。</p>
<p>　　车牌智能识别能够实时地对城市的车辆进行检测、监控和管理，实现智能交通的实时性和高效性；它不仅可以有效地减少人工操作的参与，节约成本；还可以在一定程度上杜绝一些交通工作人员的违规、舞弊操作，解决收费流失等问题；它还可以对城市的过往车流量进行检测、指导相关工作，减少交通拥堵现象。</p>
<p>　　在这个大力倡导智慧型城市概念的社会，随着互联网技术的提升，网络的发展，智能的车牌识别系统早已经深入人们的生活中，监测车流量等。</p>
<p>　　<strong>电子警察系统</strong>：一种抓拍车辆违章违规行为的智能系统，大大降低了交通管理压力。</p>
<p>　　<strong>卡口系统</strong>：对监控路段的机动车辆进行全天候的图像抓拍，自动识别车牌号码，通过公安专网与卡口系统控制中心的黑名单数据库进行比对，当发现结果相符合时，系统自动向相关人员发出警报信号。</p>
<p>　　<strong>高速公路收费系统</strong>：自动化管理，当车辆在高速公路收费入口站时，系统进行车牌识别，保存车牌信息，当车辆在高速公路收费出口站时，系统再次进行车牌识别，与进入车辆的车牌信息进行比对，只有进站和出站的车牌一致方可让车辆通行。</p>
<p>　　<strong>停车场收费系统</strong>：随处可见，收费系统抓拍车辆图片进行车牌识别，保存车辆信息和进入时间,并语音播报空闲车位，当车辆离幵停车场时，收费系统自动识别出该车的车牌号码和保存车辆离幵的时间，并在数据库中查找该车的进入时间，计算出该车的停车费周，车主交完费用后，收费系统自动放行。</p>
<p>　　<strong>智能公交报站</strong>：当公交车进入和离开公交站台时，报站系统对其进行车牌识别，然后与数据库中的车牌进行比对，语音报读车牌结果和公交线路。</p>
<p>　　车牌识别技术应用广泛，当然，上面所指的应用只是其中的一小部分。随着智能交通的迅猛发展，社会对车牌自动识别的需求量会越来越高多，技术上也会越来越高。</p>
<p>　　车牌自动识别系统也叫做LPR（License Plate Recognition）系统，目前国内做的比较成熟的产品有北京汉王科技有限公司开发的“汉王眼”车牌识别系统，厦门宸天电子科技有限公司研发的 Supplate系列，深圳吉通电子有限公司研发的“车牌通”车牌识别产品、亚洲视觉科技有限公司研发的 VECON-VIS 自动识别系统等。也有很多高校在研究这个课题。国外相对的在这个方面开始的比较早，同时他们的车牌种类单一，字符简单，容易定位识别有关，取得不错的成就。</p>
<p>　　关于车牌识别的研究，虽然国内外学者已经作了大量的工作，但仍然存在一些问题。在车辆还比较新的时候，车牌上的字迹清晰，较容易识别，随着车龄越来越大，车子经过风吹雨淋，车牌难免受到一定程度的磨损，这样就会造成识别的难度。比如车牌图像的倾斜、车牌自身的磨损、光线的干扰都会影响到定位的精度。</p>
<p>　　车牌字符识别是在车牌准确定位的基础上，对车牌上的汉字、字母、数字进行有效确认的过程。目前已有的方法很多，但其效果与实际的要求相差很远，难以适应现代化交通系统高速度、快节奏的要求。因而对字符识别的进一步研究也同样具有紧迫性和必要性。</p>
<p>　　<strong>我们实验室的所做的工作就是基于Linux实现一个具有可视化界面的车牌识别系统。重点在于针对特点的环境改善现有的车牌定位、检测和识别的算法，对其进行优化，实现车牌识别的准确率和精确度。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　在年尾用了几天的时间将2014年的所有工作都总结了一遍，将之前的文档综合了下。</p>
<p>　　以下是LPR系统，车牌识别的一些总结资料。</p>
<p>第一篇：LPR研究背景</p>
<p>　　汽车的出现改变了以往出行徒步和以马代步的时代，极大地改变了人们的生活方式]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014年年度总结]]></title>
    <link href="http://silencewt.github.io/2014/12/28/2014%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://silencewt.github.io/2014/12/28/2014年年度总结/</id>
    <published>2014-12-28T02:26:08.000Z</published>
    <updated>2014-12-28T02:29:08.000Z</updated>
    <content type="html"><![CDATA[<p>　　好好回顾了下，这一年自己走过的时光，发现很多事情真的不是自己可以计划和安排的，犹记去年的这个时候是怎样的告诉自己不能浪费时光，要好好对待自己，也给自己设定了目标，也有一部分达成了，一部分终归是不了了之了。到了年底，没想到这一年的时间就这样了没了，回顾过去，<strong>只为更好的前进，成为更好的自己</strong>。</p>
<p>　　2014年收获了很多，也失去了很多，感概最多就是没有好好的使用时间，但是，每次回过头来看，都会觉得这一段路走的很有必要，没有经历过这些，怎么会知道自己要的是什么，怎么会感受到自己的成长，也许，这就是人们常说的，成长的所失与所得。虽然这段日子没有什么惊天动地的大事件，但是确确实实给了我很多的东西，不仅仅是学习也是做人。2014基本可以分为几个阶段性报告。</p>
<h3 id="学习">学习</h3>
<p>1、1-4月属于真真正正的迷茫期。一月忙于各种研究生结业考试，天天呆在图书馆，除了考试不知道自己还能那忙什么，去实验室的时间就是休息娱乐。当然，这段时间也过得很充实，达到了我要的目标，成绩优秀，这样的日子在10月份的时候出了成绩，轻松拿得国奖，学生的最高奖项。</p>
<p>2、寒假回家，除了和家人愉快的玩耍之外，也静下心来想了想之后的生涯该怎么过，没有结果但是紧迫感越来越大，提早来了实验室。从放假回来到三月，一直在思考，该怎么度过剩下的时间，该怎么才能提升自我竞争力？我可以做什么？我想做什么？未来的职业是什么？这几个问题一直就这样困扰着我。导师方向的更改造成我很大的压力，这不是我喜欢的。实验室的压力和责任也很大，不能任性的扔下实验室的事情不管，但有不能放弃找工作的目的。就是这么纠结的过了一两个月。白天，看论文，学图像处理，看opencv，学机器学习，了解这方面的各种信息和资料；晚上，接触前端，接触互联网，学写网站。虽然会被各种杂事打断但基本就是这个节奏。</p>
<p>3、这两个月内，纠结归纠结，期间自己设定的目标还是有完成一点的。这段时间，让我真正的踏入<strong>图像处理和机器学习</strong>的大门，自学了图像检测，目标识别这个领域的知识。回过头来看，原来这些都很简单，量的积累确实换来了质的飞跃。我所谓的简单，只是局限于现有简单算法的实现和理解。优化以及实际应用这又是一个大的世界。</p>
<p>4、还踏入了互联网领域，通过各种渠道的信息，通过师姐，通过不断的关注最新互联网信息，开启联通外面世界之路。对于<strong>构建网站，博客，页面交互，前端</strong>等等有了认识，接触了html，css，js，nodejs，mongodb，bootstrap，github，trello各种有趣的东西。学习这些的过程中，让我知道如何作用好网络找到自己想要的东西，如何查看官方文档，如何解决问题，不敢说每个都学的很深，不敢说都精通，但基本的我都知道。个人觉得重要的不是你学会了哪门技术，重要的是<strong>学会了怎么解决和处理问题，怎么寻求帮助，怎么思考，这个过程带给我的体会及自我进化才是慢珍贵的。</strong></p>
<p>5、在经过一段时间的挣扎，在听过阿里测试大讲坛之后，我坚定了要做测试这个行业的心，于是从5月开始就利用课余的时间重新将测试的东西捡起来，慢慢的深入到测试的领域，收集信息，找到自己想做的方向，web测试，由于自己对互联网很有的热情，鉴于之前接触了前端的知识，这一块能很快的上手，理解很快。这个期间，有尝试着去找实习，但是每次都被实验室的事情压着，没有办法顺利的离开，最后只能放弃。学习python，跟本科同学，尝试django建立一个网站，类似于博客收集信息的，界面基本上是copy某个网站的，只是内容和逻辑是自己的。</p>
<p>6、暑假回来后，对微信订阅号知道了怎么有效的利用了，重点关注了几个有效的订阅号，每天通过其了解最新的消息。坚持了2-3个月后，发现自己了解到的领域多了，知识面广了，和他人聊天的时候，什么话题都能聊下去，周围的人都说，我怎么知道这么多的。<strong>寻找消息的渠道，增长见识。</strong></p>
<p>7、下学期开学，变得更有目标性了，基本上就是图像处理（重点关注机器学习）和软件测试。开始完成车牌识别的项目，对于车牌识别领域的各个知识点都有所掌握，重点在字符识别这一块，结合<strong>python和机器学习</strong>这本书，完成了python的学习，加深对学习算法的理解。</p>
<p>8、之后，开始加入一个<strong>实验室的团队，做安卓开发</strong>，一个创业项目，手机App应用。由于本科有java和安卓的一点基础,花了7天的时间，通过极客学院的视频学习Android。这样时间被分为两段，白天在实验室，晚上在工作室那边。11月底，一方面感觉时间过于紧张，没有时间做自己的事情。实验室也有了新的项目，另一方面由于团队的内部原因，选择离开。</p>
<p>9、11月下旬开始接触自动化测试、单元测试、测试驱动开发思想、接口测试以及java、设计模式等等。</p>
<p>10、11月份开始，重点放在实验室项目上，<strong>三光检测系统</strong>，红外和可见光图像配准，图像融合，结合硬件在<strong>Linux</strong>下搭建便于三光检测的手持设备，该项目使用qt编程，有摄像头、视频服务器、pc主板、触摸屏等硬件设备，了解了融合硬件设备和软件的开发流程，自学了linux，由于是实际应用，对方只要知道是否可以在Linux下使用设备即可，所以只接触了简单的liunx，重点负责，Linux和图像融合配准模块。</p>
<h3 id="生活">生活</h3>
<p>11、上半年，组织实验室外出游玩三天，整个过程，从行程安排到住宿，坐车，吃饭，到游玩路线都是我一个人安排下来，全程自助游，路上不断收到大家的赞美声，都说安排的很好很贴心，太开心了。下半年，实验室周末的各种小聚，小活动，都组织得挺好的，为自己的<strong>交际能力和组织能力</strong>喝彩，总的一个感觉就是不管在实验室，在寝室，还是以前本科班，我的人缘还是很不错的，大家都愿意和我交流。这点希望继续保持，用一颗包容的心去对待大家，做一个大家眼里的开心果，传播正能量。</p>
<p>12、暑假回去帮哥哥忙活了大半个月，也算是尽到做妹妹的心了，照顾锦娴，帮助管理店里的生意，感触最深的就是：生活的不容易，各行各业都不是那么轻松的，自己做老板也不轻松，站在不同的位置就会有不同的角度看待问题，也就会有不同的烦恼问题出现。老板有老板的出发点，打工有打工的想法。其实都是不容易，唯有尽心尽力做好就好。不亏待自己，善待他人，包容理解换位思考。家里因为多了个小孩，变得更好欢乐了，只能说小孩好萌，好可爱啊~~~，和小孩接触就了，才发现自己也有一颗童心，未泯的赤子之心。</p>
<p>13、和闺蜜相处融洽，大家都说我们谁也离不开谁。我们能从09年一直走到现在，5年的友情，除了彼此的包容之外，更多的是彼此的维护，愿意为对方迁就自己的一些东西，<strong>愿意用心经营，愿意倾听</strong>。我一直相信，任何一段感情，不管是亲情、友情还是爱情都是需要彼此用心经营的，双方都需要付出，需要包容，若有一方从不付出，再浓感情慢慢的也会随着时间消失。对待生活的态度上，我觉得自个比较像“鬼脚七”（一个很有名的自媒体人），他对网友的一些回答我都很赞同，在价值观上挺一致的。</p>
<p>14、在瑜伽馆兼职了一段时间，爱上了瑜伽，深深感受到瑜伽的魅力，瑜伽成为我的业余爱好，以后有机会要好好的学学瑜伽。</p>
<h3 id="感情">感情</h3>
<p>15、顺其自然，能遇到一个懂你的人不容易，但还是希望那个他能快点出现，不要让我等久了。</p>
<p>　　这一年，给自己一个赞，也希望自己改掉拖拉的毛病，在年尾将所有的工作做个总结和了断，该写报告的写报告，该做记录的做记录，博客该发的发，来年不再为2014年买单了。所有的这些就在元旦前结束。</p>
<p>　　来年，愿自个不再拖延，坚持写博客，每周一次整理和总结所学的知识点，找个好的实习、好的工作，羽毛球技术飞升，和闺蜜好好的享受生活，好好的维持实验室的欢乐氛围，总之：<strong>用心生活，享受乐趣，不让自己遗憾。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　好好回顾了下，这一年自己走过的时光，发现很多事情真的不是自己可以计划和安排的，犹记去年的这个时候是怎样的告诉自己不能浪费时光，要好好对待自己，也给自己设定了目标，也有一部分达成了，一部分终归是不了了之了。到了年底，没想到这一年的时间就这样了没了，回顾过去，<strong]]>
    </summary>
    
      <category term="总结" scheme="http://silencewt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="心路历程" scheme="http://silencewt.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="心路历程" scheme="http://silencewt.github.io/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://silencewt.github.io/2014/12/28/hello-world/"/>
    <id>http://silencewt.github.io/2014/12/28/hello-world/</id>
    <published>2014-12-28T02:18:07.000Z</published>
    <updated>2014-09-12T14:17:00.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[时间管理--小强升职记]]></title>
    <link href="http://silencewt.github.io/2014/12/28/%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0/"/>
    <id>http://silencewt.github.io/2014/12/28/小强升职记/</id>
    <published>2014-12-28T02:18:07.000Z</published>
    <updated>2014-09-16T13:47:36.000Z</updated>
    <content type="html"><![CDATA[<p>　　书中已对话的形式，主管老付如何教会小强对自己时间进行管理，如何高效的完成工作，培养其成为主管。<br>　　在我们觉得时间很多的时候，他就偷偷的溜走了，时间对于每个人都是公平的。我们每天在忙忙碌碌的日子里过去，是否过得有意义，浑浑噩噩的日子真的是我们所要的吗？到底我自己追求的是什么？每天工作学习是为了什么？什么样的人生才有意义?我们需要站在一个更高的位置上审视自己。问问自己什么才是真正想要的。<br>　　<br>　　我们的时间总是在无意义的事情上面一点点的浪费掉。确实如此，以前总是每次开电脑的时候。登下QQ，看下新闻什么的，以为这样浪费不了多少时间，可是每次都没有忍住，还有点像滚雪球似的的越滚越长，结果一看时间已经10:00多了，过一会就要吃饭了，自然就没有心思学习了，或者每次时间很轻易的就被同学打断，被QQ消息打断，那么在要集中注意就很难，就是这样的时间黑洞将我们的时间吞噬掉。<br>　　<br>　　有时候也会有同时有很多事情向我袭来，很多时候就应该根据自己的价值观，给他们分出优先级，找出核心事件，及时解决这些问题。时间管理的方法有很多，四象限法则，时间投资法，衣柜整理法等，具体哪一种是适合你的，还是需要自己去摸索，去实践才知道什么是适合自己的。书里的时间资本法，对于时间价值的计算让我忽然醒来，原来我的时间就剩这么一点了，可是我想要的生活还没有实现。。<br>　　<img src="/images/zbjs2.png" alt="资本计算2"><br>    <img src="/images/zbjs.png" alt="资本计算"><br>　　很典型的，在今后工作的日子里，只有8年是在工作，有10年是在睡觉，其他时间是13年，有人曾统计过一个人活得72岁时对时间的消费情况：睡觉21年，工作14奶奶，个人卫生7年，吃饭6年，旅行6年，排队5年，学习4年，开会3年，打电话2年，找东西1年，其他3年。如果加上我们的年新来计算时间资本，那么很廉价。。</p>
<h3 id="目标">目标</h3>
<p>　　时间，是一个非常奇怪的东西，当你想挥霍它的时候，它会尽量的满足你，让你觉得怎么挥霍都用不完。但是当你想要珍惜它的时候，他又会i特别的吝啬，让你觉得时光飞逝，转眼已是尽头。<br>　　对于一个项目或是什么要有明确的目标，具体的下一步行动，一个行动清单。对人生有规划，有明确的目标是很好的，但如果沉迷在未来美好生活的幻想中，而不是执行它，只是做个梦想家，我们要将目标化为行动，做个建筑家，梦想的缔造者。<br>　　当然，目标也不是有了完美的计划就能达成的，我们需要方法避免失败。<br>　　1、找到最大的石头，就是要问问自己实现这个目标最大的石头（障碍）在哪里，如果最大的石头没有移除，你除去了99%的小石头也是没有用的。<br>　　2、有什么想法计划一定要写下来，白字黑子是最好的契约，写到了才可以做到，那么所有的想想就不再只是想想了，而是需要实现的东西了。<br>　　3、拒绝第一次失败，万事开头难，很多目标的夭折都是从第一次失败开始的。所以我们要重视第一次的是吧，摆正心态不让它产生连锁反应。我们有一种很可怕的适应性，不敢是对好习惯还是坏习惯的适应。失败了，我们更应该找出原因，为什么会失败？到底为什么成功？花时间思考这两个问题是非常重要的。</p>
<h3 id="习惯">习惯</h3>
<p>　　习惯是个很可怕的东西，对于长期做在电脑前的上班族，最重要的一点就是要养成健身的习惯，平时我们可能没有大把的时间可以去运动，为了身体的健康，每天坚持一个小时的锻炼。向着你要养成多习惯，每天去做一些你不愿意的事情，这样你就不会为那些真正需要你完成的责任而痛苦。</p>
<h3 id="思维导图">思维导图</h3>
<p><img src="/images/swdt.bmp" alt="思维导图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　书中已对话的形式，主管老付如何教会小强对自己时间进行管理，如何高效的完成工作，培养其成为主管。<br>　　在我们觉得时间很多的时候，他就偷偷的溜走了，时间对于每个人都是公平的。我们每天在忙忙碌碌的日子里过去，是否过得有意义，浑浑噩噩的日子真的是我们所要的吗？到底我自己追]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://silencewt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[opencv函数系列---漫水填充floodfill]]></title>
    <link href="http://silencewt.github.io/2014/12/28/opencv%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97-fillfood/"/>
    <id>http://silencewt.github.io/2014/12/28/opencv函数系列-fillfood/</id>
    <published>2014-12-28T02:18:07.000Z</published>
    <updated>2014-09-16T13:57:22.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、floodFill思想">一、floodFill思想</h3>
<p>　　所谓漫水填充，简单来说，就是自动选中了和种子点相连的区域，接着将该区域替换成指定的颜色，这是个非常有用的功能,经常用来标记或者分离图像的一部分进行处理或分析.漫水填充也可以用来从输入图像获取掩码区域,掩码会加速处理过程,或者只处理掩码指定的像素点。操作结果总是某个连续的区域。当邻近像素点位于给定的范围（从lodiff到updiff）内或在原始seedPoint像素值范围内是，floodFill将会为这个点涂上颜色。以此填充算法为基础，类似photoshop的魔术棒选择工具就很容易实现了。<br>　　漫水填充（FloodFill）是查找和种子点联通的颜色相同的点，魔术棒选择工具则是查找和种子点联通的颜色相近的点，将和初始种子像素颜色相近的点压进栈作为新种子。<br>　　泛红填充实现最常见有四邻域像素填充法，八邻域像素填充法，基于扫描线的像素填充方法。根据实现又可以分为递归与非递归（基于栈）。</p>
<h3 id="二、函数介绍">二、函数介绍</h3>
<p>　　</p>
<pre><code>floodFill ( InputOutputArray image,   <span class="comment">//输入/输出1通道或3通道，8位或浮点图像，具体参数由之后的参数具体指明InputOutputArray mask,     </span>
     Point seedPoint,                <span class="comment">//漫水填充算法的起始点</span>
     Scalar newVal,                   <span class="comment">//像素点被染色的值，即在重绘区域像素的新值</span>
     Scalar loDiff=Scalar(), 
     Scalar upDiff=Scalar(), 
     CvConnectedComp*  comp = <span class="keyword">NULL</span>
     <span class="keyword">int</span> flags=<span class="number">4</span> )
</code></pre><p>　　mask：表示操作掩模,（控制被填充的区域）。它应该为单通道、8位、长和宽上都比输入图像 image 大2个像素点的图像（是内部运算简单快速）。floodFill需要使用以及更新掩膜。需要注意的是，漫水填充不会填充掩膜mask的非零像素区域。例如，一个边缘检测算子的输出可以用来作为掩膜，以防止填充到边缘。同样的，也可以在多次的函数调用中使用同一个掩膜，以保证填充的区域不会重叠。另外需要注意的是，掩膜mask会比需填充的图像大，所以mask中与输入图像(x,y)像素点相对应的点的坐标为(x+1,y+1)。<br>　　<br>　　lodiff、updiff：表示当前观察像素值与其部件邻域像素值或者待加入该部件的种子像素之间的亮度或颜色之负差（lower brightness/color difference）或正差的最大值。 如果一个像素点的值不低于被染色的相邻点减去lodiff且不高于其加上updiff，那么该像素点就会被染色。如果flags参数包含FLOODFILL_FIXED_RANGE 这时每个像素点都将于种子点而不是相邻点比较。可以理解成阈值范围，在这个范围里的像素都会被染色。<br>　　<br>　　flags：低8位（第0~7位）用于控制算法的连通性，可取4 (4为缺省值) 或者 8。如果设为4，表示填充算法只考虑当前像素水平方向和垂直方向的相邻点；如果设为 8，除上述相邻点外，还会包含对角线方向的相邻点。高8位部分（16~23位）可以为0 或者如下两种选项标识符的组合：<br>　　（1） FLOODFILL_FIXED_RANGE－如果设置为这个标识符的话，就会考虑当前像素与种子像素之间的差，否则就考虑当前像素与其相邻像素的差。也就是说，这个范围是浮动的。<br>　　（2）FLOODFILL_MASK_ONLY－如果设置为这个标识符的话，函数不会去填充改变原始图像 (也就是忽略第三个参数newVal),而是去填充掩模图像（mask）。中间8位部分，上面关于高八位FLOODFILL_MASK_ONLY标识符中已经说的很明显，需要输入符合要求的掩码。Floodfill的flags参数的中间八位的值就是用于指定填充掩码图像的值的。但如果flags中间八位的值为0，则掩码会用1来填充。<br>　　而所有flags可以用or操作符连接起来，即“|”。例如，如果想用8邻域填充，并填充固定像素值范围，填充掩码而不是填充源图像，以及设填充值为47，那么输入的参数是这样：</p>
<pre><code><span class="attribute">flags</span>=<span class="string">8 | FLOODFILL_MASK_ONLY | FLOODFILL_FIXED_RANGE | （47&lt;&lt;8）</span>
</code></pre><h3 id="三、函数演示">三、函数演示</h3>
<p>待写ing……</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、floodFill思想">一、floodFill思想</h3>
<p>　　所谓漫水填充，简单来说，就是自动选中了和种子点相连的区域，接着将该区域替换成指定的颜色，这是个非常有用的功能,经常用来标记或者分离图像的一部分进行处理或分析.漫水填充也可以用来从输入图像]]>
    </summary>
    
      <category term="opencv" scheme="http://silencewt.github.io/tags/opencv/"/>
    
      <category term="opencv" scheme="http://silencewt.github.io/categories/opencv/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试之美有感]]></title>
    <link href="http://silencewt.github.io/2014/12/28/%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%BE%8E%E6%9C%89%E6%84%9F/"/>
    <id>http://silencewt.github.io/2014/12/28/测试之美有感/</id>
    <published>2014-12-28T02:18:07.000Z</published>
    <updated>2014-12-24T12:55:54.000Z</updated>
    <content type="html"><![CDATA[<p>　　<strong>王小波说：这个世界上有两种人，一类人将有趣的事情做成无趣，一类人把无趣的事情做成有趣。</strong>软件测试原本是件很有趣的事情，可是网上有很多的人或者一些做测试的人很不幸将测试这件有趣的事做成了无趣的事情：觉得是日复一日的手工劳动，不断的和开发人员争执，等等……但其实不是这样的。测试是一个软件项目，公司成功的基石，是一种在成本、质量、效率、周期之间平衡的艺术。</p>
<h3 id="一、性能测试，协作是关键">一、性能测试，协作是关键</h3>
<p>　　性能测试是比较复杂的一个测试环节，比如对一个学生进度跟踪系统，客户会要求“100%的网页在5秒或者是更短的时间内显示出来，应用程序支持1000及以上用户同时使用，98%的情况下，课程将在第一次尝试时就完全正确下载”，等等。虽然这是客户的要求，在这样是不可以写进目标里的，因为这完全无法验证，不能讲模棱两可的性能指标写到合同义务中。性能测试应该做到可度量有价值。将其改为“对于内部版本（出现情况需上报），在任意数量的用户条件下，有超过5%的情况加载网页的时间超过5S，超过2%的情况，课程无法完整或正确的下载……对于外部版附有性能报告，包括在，任意数量的用户条件下，有超过5%的情况加载时间超过5S的网页，超过2%的情况无法完整或正确下载的课程……”。<br>　　<strong>对于性能测试的需求从承诺达到一定水平转变为承诺报告在什么样的条件下目标将无法实现。这个过程就涉及到项目经理，客户，开发人员之间的交流和协作。</strong><br>　　但是面对这样的目标还是无法给出测试用例，那么应该在系统中设置检查点，策略：收集系统性能指标基准，并验证使用模型中包括的每个功能任务，分别在1个用户的负荷下，10个用户，1000甚至更多负荷下载每一个包含该功能任务的性能测试中都达到性能需求，每一个下面都需要列出功能任务清单。一个系统的性能是客户最关注的，但是你无法不能性能测试所有的东西。文中用一个超级杯营销的案例，说明性能测试需要与其他测试人员协作，于项目管理协作，于客户协作，于开发团队协作，于IT人员协作，以及与最终用户协作。</p>
<h3 id="二、模糊测试，让系统更可靠">二、模糊测试，让系统更可靠</h3>
<p>　　模糊测试大多数用于办公软件，<strong>那什么是模糊测试：是通过对输入数据进行随机修改和破坏来测试程序的方法。</strong>他为测试和编程人员在开发软件时面临的棘手问题提供多种优美的解决方案。办公软件需要支持很多种格式，我们或许能找到特定格式的文档，但这些文档可能不准确或有丢失处。例如与其他软件之间的互操作性，我们就需要模拟其他复杂软件，或者用一个模糊器生成范围很广的各种文档来模拟各种应用软件和软件版本的差别。office2007在开发的时候就大量使用了模糊测试。<br>　　在进行模糊测试的时候需要准备一组有代表性的文档，一个模糊器，从常规模型到自定义模型。在测试过程中也要不断的修改你的模糊器，以产生更多的测试用例并去除可能影响输出的偏差。模糊测试擅长发现诸如崩溃和挂起的明显问题，但对判断正确性的作用很小。在办公软件领域，它对开发和测试人员所面临的操作性、安全性、和稳定性在内的许多复杂问题提供有创意且简洁的解决方案。</p>
<h3 id="三、自动化测试">三、自动化测试</h3>
<p>　　自动化测试不仅仅是简单的编写和运行那些不需要人为干预的测试用例。事实上，在很多测试人员看来，自动化这是由一些手动生成的，用来执行特定测试场景或一部分产品功能的测试脚本或代码组成。但是很多时候自动化测试并没有给测试人员带来方便，因为除了实际的执行程序之外，流程中的其他部分没有一个实现了自动化。那么为了实施自动化，特别是规模较大的自动化测试，整个过程从头到尾—从测试人员编写玩测试程序到结果被分析出来给人看，都必须自动化。如果没有这个层次上的自动化，测试人员在监控测试程序运行上所花的时间将会变成难以控制的增长。<br>　　在什么情况下自动化可以帮助测试团队，以及什么情况下自动化会妨碍测试的工作，应该百分百的自动化那些应该被自动化的测试，这一准则本身是简单多额，困难就在于决定那些是应该被自动化的，产品架构，相关参与者，都可以帮助测试团队做出正确的决定。很多自动化之所以失败的原因在在于测试人员花太多的时间进行自动化或者试着去自动化，并把时间花在了根本不值得自动化的目标任务上。<br>　　一个基本的自动化测试流程：编写自动化测试—-选择测试和测试平台—-运行测试—-收集用于报告的测试结果—-报告新的额bug解决已近修复的bug。自动化测试要成功的第一步是：测试代码要写得棒。必须要能够易于维护，要对测试带进行源代码控制，并且集中编译和创建。测试员可以成为设计和实现系统测试框架的专家，这于应用程序开发是不一样的。<strong>编写一个漂亮的测试自动化工具需要对被测系统的理解，需要对可能将要编写的测试的理解，需要知道哪些测试对项目最优价值，还需要知道哪些测试最可能在将来随着被测软件的变化而具有可维护性。</strong><br>　　<em>如果在某一阶段，测试通过率仅为94%，你会怎么做？对于合理的测试通过率目标，与其去设定一个神奇的数字，你真正需要的是100%的失败调研并确保那些失败中没有一个严重到阻碍发布。回答”这要看失败来定了，如果阻碍我么达到目标的错误不满足我们的门槛，我们就让他过去“</em></p>
<h3 id="四、测试随机数发生器">四、测试随机数发生器</h3>
<h3 id="五、QA不是魔鬼">五、QA不是魔鬼</h3>
<p>　　测试人员是好的流程的促进者，能准确的发现（在发布之前）软件需求与实现之间不吻合的人，也是最广泛了解软件开发实践的人，对项目总体状态最了解的人。QA的工作是引导软件开发过程以提高成功率，以及建设性的批判软件开发过程而不是阻碍这个过程并成为拖后腿的人。<br>　　检验：通过重复的操作来确认事情做得正确的过程。<br>　　调查：反馈驱动的过程<br>　　很多人认为测试就是简单的触屏和点击，无聊的文本进行，是一个简单无聊的工作，如果这么想就错了，这样的工作不是调查而是检验。测试不仅仅是这些，测试往往需要和各类人员沟通，测试是对产品质量负责，保证每个产品能满足客户的需求及时上线。</p>
<h3 id="六、高效测试">六、高效测试</h3>
<p>　　软件测试中首要考虑的问题就是：安全性测试。导致用户数据的丢失是一件很糟糕的事情！安全性测试必须最早考虑，因为其贯穿在整个产品的架构之中。即架构上如果有所改动，那么几乎需要重新测试所有的东西，比如如果数据库的权限有问题，那么就不得不重新测试所有与数据库交互有关的测试用例，或者一旦程序和操作系统的交互存在安全问题，所有与操作系统交互有关的测试用例也必须重测。安全性对于应用程序的测试几乎会影响到每一个测试领域，需涉及到整个应用程序，对于安全性要求高的领域最好有相关的信息安全人员提供高级全面的解决方案。<br>　　在互联网应用程序中，可以考虑一下几个问题：跨站脚本、SQL注入、越权访问、信息泄露。</p>
<h3 id="七、查找缺陷">七、查找缺陷</h3>
<p>　　问：如果处于整个软件开发周期的最后一个环节：所有的新功能都实现了所有的测试用例也通过了，那么产品可以发布了吗？<br>　　理论上讲是测试用例都通过了就没有问题了，但是怎么保证你的测试集是完美的，如何才能知道你的测试集能有效的检查出缺陷。在这种情况下，可以系统化的植入认为的缺陷，然后测试集能否发现他们。测试集的代码覆盖率就是量化的度量测试集的质量指标（检查是否执行了程序的每一种状态）、分支覆盖率（保证代码中的分支至少被执行一次）、条件覆盖率（保证代码中每个条件分支子条件都经历过是和否的状态）。80%的缺陷都集中在20%的模块中。<br>　　覆盖率只能告诉你测试执行的情况并没有测试集本身的信息。可以使用变异测试，在程序中植入大量的人为的漏洞，并逐个对他们进行测试看哪些变异没有检测出来。然后系统化的改进这个测试集，知道所有的变异都能被检测出来。但是变异测试非常耗时。变异测试依赖于自动化测试。<br>　　问：怎么对程序进行变异呢？改变常量的值（对某一常量X，尝试用X-1,X+1，0来替换），用常量来替换变量的值，用变量来替换数组的引用，改变操作符，改变调用方法，将某一条件置返（判断条件c为非c）。改变数字操作符+改成-,&gt;&gt;改成&lt;&lt;。省略方法调用(将一个方法调用直接改为0.如果该方法不需要返回值，可以直接删除)。</p>
<h3 id="八、测试分类">八、测试分类</h3>
<p>　　黑盒和白盒测试是软件测试中最普遍的设计方法，在黑盒测试中，软件被看做是一个神秘的对象，他的内部结构和设计是未知的，他接受一些输入数据，对数据进行处理，然后输出结果。如果一个程序能正确处理数据并输出预期的结果，则认为测试师成功的。黑盒测试是以软件说明书为基础的，而白盒测试则需要具有软件内部实现的了解，并关注于程序的某一特定路径的测试。程序员要小心的选择测试用例以覆盖所有重要的代码单元。虽然黑盒和白盒测试方法是互相补充的，但二者都有一些共同的局限。其中主要的一个问题就是他们都不能对程序进行全面的测试。这就要求你富有创造型、有效的进行设计，甚至为了在用户使用软件之前将缺陷找到，还要开发出漂亮的测试来覆盖个整蛊你用例。<br>　　静态分析：白盒测试一种，不需要代码的执行，在于查找一般性错误确保代码满足所有重要的要求和标准。一般自动化执行。例如GCC编译器是静态分析工具。<br>　　单元测试：白盒测试一种，检查代码单元个体单个函数或模块是否正常工作，是否接受和处理数据u，并返回预期的值。<br>　　测试脚本：一系列逐步运行的指令集合，再现各种不同的条件来检查程序各项功能是否正常，模仿日常对应用程序的使用，给定在一系列牌值下下能否输出正确的的结果。不关心程序的内部细节。 </p>
<hr>
<p>　　<br>　　<em>这本书并不适合出学者看，建议有了一定的测试基础之后在过来看本书。以上的只是书里的一些摘录，对于测试的理解还不是很深入，但是对于测试会有一点大概的了解，书中提到的一些经验还是不错的，但是个人感觉这本书有点旧时了，不建议看。当然这个只能我个人的看法。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<strong>王小波说：这个世界上有两种人，一类人将有趣的事情做成无趣，一类人把无趣的事情做成有趣。</strong>软件测试原本是件很有趣的事情，可是网上有很多的人或者一些做测试的人很不幸将测试这件有趣的事做成了无趣的事情：觉得是日复一日的手工劳动，不断的和开发人员]]>
    </summary>
    
      <category term="测试" scheme="http://silencewt.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://silencewt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单Xpath入门]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E7%AE%80%E5%8D%95Xpath%E5%85%A5%E9%97%A8/"/>
    <id>http://silencewt.github.io/2014/12/25/简单Xpath入门/</id>
    <published>2014-12-25T13:54:52.000Z</published>
    <updated>2014-12-25T14:01:04.000Z</updated>
    <content type="html"><![CDATA[<p>　　XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。XPath 是 XML 的查询语言，和 SQL 的角色很类似。以下面 XML 为例，介绍 XPath 的语法。</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span>
<span class="tag">&lt;<span class="title">catalog</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"USA"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Empire Burlesque<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bob Dylan<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>10.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"UK__time"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"UK"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span>
<span class="tag">&lt;<span class="title">cd</span> <span class="attribute">country</span>=<span class="value">"USA"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Greatest Hits<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artist</span>&gt;</span>Dolly Parton<span class="tag">&lt;/<span class="title">artist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">price</span>&gt;</span>9.90<span class="tag">&lt;/<span class="title">price</span>&gt;</span>
<span class="tag">&lt;/<span class="title">cd</span>&gt;</span><span class="tag">&lt;/<span class="title">catalog</span>&gt;</span>
</code></pre><p><strong>定位节点</strong></p>
<p>　　XML 是树状结构，类似档案系统内数据夹的结构，XPath 也类似档案系统的路径命名方式。不过 XPath 是一种模式(Pattern)，可以选出 XML 档案中，路径符合某个模式的所有节点出来。<br>1）要选 catalog 底下的 cd 中所有 price 元素可以用：<br>　　 /catalog/cd/price<br> 　 如果 XPath 的开头是一个斜线（/）代表这是绝对路径。如果开头是两个斜线（//）表示文件中所有符合模式的元素都会被选出来，即使是处于树中不同的层级也会被选出来。</p>
<p>2）选出文件中所有叫做 cd 的元素（在树中的任何层级都会被选出来）：<br>　　//cd　　使用星号（Wildcards,＊）可以选择未知的元素。</p>
<p>3）选出/catalog/cd 的所有子元素：<br>　　/catalog/cd/*</p>
<p>4）选出所有 catalog 的子元素中，包含有 price 作为子元素的元素。<br>　　/catalog/*/price</p>
<p>5）选出有两层父节点，叫做 price 的所有元素。<br>　　/<em>/</em>/price</p>
<p>6）选择出文件中的所有元素。<br>　　//<em>　<br>　　要注意的是，想要存取不分层级的元素，XPath 语法必须以两个斜线开头(//)，想要存取未知元素才用星号(</em>)，星号只能代表未知名称的元素，不能代表未知层级的元素。</p>
<p><strong>选择分支</strong><br>使用中括号可以选择分支。</p>
<p>1）从 catalog 的子元素中取出第一个叫做 cd 的元素。XPath 的定义中没有第0元素<br>　　/catalog/cd[1]</p>
<p>2）选择 catalog 中的最后一个 cd 元素： XPath 没有定义 first() 这种函式，用上例的 [1]就可以取出第一个元素。<br>　　/catalog/cd[last()]</p>
<p>3）选出含有 price 子元素的所有/catalog/cd 元素。<br>　　/catalog/cd[price]</p>
<p>4）选出 price 元素的值等于10.90的所有/catalog/cd 元素<br>　　/catalog/cd[price=10.90]</p>
<p>5）选出 price 元素的值等于10.90的所有/catalog/cd 元素 的 price 元素<br>　　/catalog/cd[price=10.90]/price</p>
<p><strong>选择一个以上的路径</strong></p>
<p>使用 Or 操作数(|)就可以选择一个以上的路径</p>
<p>1）选择所有 title 以及 artist 元素<br>　　//title | //artist</p>
<p>2）选择所有 title 以及 artist 以及 price 元素<br>　　//title | //artist | //price</p>
<p><strong>选择属性</strong> </p>
<p>在XPath的属性。除了选择元素以外，也可以选择属性，属性都是以@开头。</p>
<p>1）选择文件中所有叫做 country的属性。<br>　　//@conutry</p>
<p>2）选择所有含有country 这个属性的 cd元素。<br>　　//cd[@country]</p>
<p>3) 选择出country属性值为UK的cd元素<br>　　//country[@country==’UK’]</p>
<p><strong>部分匹配</strong></p>
<p>有些属性的值具有一定的规律，例如上面的UK就是前缀，一部分是不变的。也可以用start-with</p>
<p>1）定位属性值前缀为UK<em>的元素<br>　　//cd[containers(@country，’UK</em>‘)]<br>　　//cd[start-with(@country，’UK_’)]  </p>
<p>这是在某个文档里面学习来的，感觉简单又易上手，故摘录于此。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。XPath 是 XML 的查询语言，和 SQL 的角色很类似。以下面 XML 为例，介绍 XPath ]]>
    </summary>
    
      <category term="selenium" scheme="http://silencewt.github.io/tags/selenium/"/>
    
      <category term="selenium" scheme="http://silencewt.github.io/categories/selenium/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[selenium--大家庭介绍]]></title>
    <link href="http://silencewt.github.io/2014/12/25/selenium-%E5%A4%A7%E5%AE%B6%E5%BA%AD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://silencewt.github.io/2014/12/25/selenium-大家庭介绍/</id>
    <published>2014-12-25T13:29:10.000Z</published>
    <updated>2014-12-25T14:01:20.000Z</updated>
    <content type="html"><![CDATA[<p>安装好配置环境后，开始我的selenium之旅。简单的了解一下色，selenium大家庭的组成。</p>
<p>Selenium是ThoughtWorks专门为Web应用而开发的功能测试工具。Selenium使用JavaScript和Iframes在浏览器嵌入自动化测试引擎，可以在任何支持JavaScript的浏览器中进行工作，模拟用户在浏览器中进行的操作。Selenium的强大之处就在于可以使用集成开发环境，让用户使用自己最熟悉的开发语言进行调试操作。</p>
<p><strong>Selenium的优势</strong>：<br>1）它是开源的    </p>
<p>2）简单，易于安装，易于工作    </p>
<p>3）提供Selenium IDE ，一个FireFox plugin，能自动记录用户的操作，生成测试脚本。生成的测试脚本可以基于Selenium RC放入Java，C#，Ruby的单元测试用例中自动运行。selenium ide是selenium的唯一可以在浏览器窗口上记录用户行为的组件     </p>
<p>4）除了火狐上的事件外不会记录你电脑上的任何其他事件    </p>
<p>5）Selenium支持多种浏览器，能够运行与多种操作系统，因此更容易帮助测试人员发现应用程序在不同浏览器上的兼容性问题。通过在不同浏览器中运行测试，更容易发现浏览器的不兼容性. </p>
<p>6）通过编写模仿用户操作的 Selenium 测试脚本，可以从终端用户的角度来测试应用程序；可以操作 Web 页面上的各种元素，诸如：点击按钮、输入文本框，以及断言 Web 页面上存在某些文本与 Web 元素等。<br><br>7）测试用例调用实际的浏览器(如IE、FireFox)来执行测试。和有些开源方案自行实现Web解释引擎相比，实际的浏览器能模拟更多用户交互和JS语法。    </p>
<p> 8） SELENIUM录制的脚本比较灵活，因为它生成的是PERL的脚本程序。作为几乎最为强大和最广泛使用语言之一，PERL这种程序给予我最大的灵活性和控制度。</p>
<p><strong>Selenium IDE</strong> 支持并且只支持 Firefox 浏览器，支持的浏览器太少，而依附于 Firefox 也不便于日后开展自动化测试，但是，它的录制快捷好用！并且有代码 转换功能，可以把 Selenium 语言测试案例转为 C#,Java 等语言的测试案例，使用 Selenium IDE + FireBug 进行测试案例的编写，然后转为其他语言的测试案例后，再调用 Selenium RC运行测试案例。</p>
<p><strong>Selenium RC</strong> 它支持很多浏览器，可以使用 C#，Java 等语言编写测试案例，易于维护，同时提供了很好的扩展性，将使用Selenium RC 测试工具。</p>
<p>selenium 和 WebDriver 合幵后创建了一个新的 Selenium 2 框架。 Selenium 是一个针对网页应用测试非常好的框架。他有着一些积极的影响。WebDriver 也不像 Selenium 1 一样需要一个代理。你可以直接和浏览器进行对话。这也非常受人们欢迎的，因为可以加快测试的执行速度，不需要一个“中间人”进行传递消息。</p>
<p><strong>Selenium IDE</strong>：右Command、target、value组成的表格就是脚本，每个脚本都是一条条的action行为组成，action有CTV 三者组成，command就是api中的各种函数，target就是web中的某个目标对象，比如：输入框、按钮等，使用xpath选取对象。Value：根据实际内容填写。</p>
<p>　　在这里可以手动的增加两种页面校验：verify和assert。他们都能对显示内容，输出内等做验证，区别在于：</p>
<ul>
<li>verify：验证失败了，会抛出期望结果不存在的错误，但是测试过程会继续执行下面的步骤，但会显示成淡红的。</li>
<li>assert：验证失败，测试不会继续执行下去。</li>
</ul>
<p>Selenium 没有指明会等到需要交互的元素出现，所以你最好等到需要交互元素出现时再迕行交互，即利用wait指令。如带有下拉菜单，带有ajax的页面都要有所等待，等页面元素准备好了再进行下一步的操作。</p>
<p>Selenium RC：有两部分组成</p>
<ul>
<li>Selenium Server：负责控制浏览器行为，包括三个部分：launcher、http proxy、Selenium core，其中Selenium core是Selenium server嵌入到浏览器页面中的，Selenium core是一堆JS函数的集合，从而实现对浏览器的操作。</li>
<li>Selenium Clientlibrary：写测试案例时用来控制server的库。</li>
</ul>
<p>支持很多浏览器，可以使用C#，Java 等语言编写测试案例，易于维护，同时提供了很好的扩展性。</p>
<p><strong>Selenium Grid</strong>允许创建很多个 Selenium RC实例，由一个中心来发送 Selenium RC命令。拥有一个中心点 Hub， 测试可以连接到此点，  测试命令会推送到连接在此集线器上的Remote RC 实例上。 这个中心有一个 web 界面（localhost：4444/console）， 告诉你连接在此集线器上的Selenium RC 实例，和返些实例是否正在使用的状态。</p>
<blockquote>
<p>启动Selenium Server<br>java –jar selenium-server-standalone-2.22.0.jar -port 4444<br>启动Selenium Grid的Hub<br>java –jar selenium-server-standalone-2.22.0.jar -port 4000 -role hub<br>启动Selenium Grid的Node，其中的-hub参数，是Selenium Grid的Hub的URL<br>java -jar selenium-server-standalone-2.22.0.jar -port 4001 -role node -hub <a href="http://127.0.0.1:4000/grid/register" target="_blank" rel="external">http://127.0.0.1:4000/grid/register</a></p>
</blockquote>
<p>显然，可以启动多个Node：<br>java -jar selenium-server-standalone-2.22.0.jar -port 4002 -role node -hub <a href="http://127.0.0.1:4000/grid/register" target="_blank" rel="external">http://127.0.0.1:4000/grid/register</a></p>
<h4 id="WebDriver">WebDriver</h4>
<p>　　WebDriver 提供一个先进技术来定位 web 页面元素。其实WebDriver就是基于Selenium的一个自动化测试类库，但它不再是运行在浏览器内的JS程序，而是自己可以控制浏览器。webdriver提供了很多方式来定位元素，对于不同平台的语言都有相关的api，如C#、java、python、ruby等等。</p>
<p>　　前段时间利用空余的时间学习这方面的知识，现将其一点点的整理出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>安装好配置环境后，开始我的selenium之旅。简单的了解一下色，selenium大家庭的组成。</p>
<p>Selenium是ThoughtWorks专门为Web应用而开发的功能测试工具。Selenium使用JavaScript和Iframes在浏览器嵌入自动化测试引擎]]>
    </summary>
    
      <category term="selenium" scheme="http://silencewt.github.io/tags/selenium/"/>
    
      <category term="selenium" scheme="http://silencewt.github.io/categories/selenium/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个网页的测试用例]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://silencewt.github.io/2014/12/25/一个网页的测试用例/</id>
    <published>2014-12-25T13:23:58.000Z</published>
    <updated>2014-12-25T14:03:45.000Z</updated>
    <content type="html"><![CDATA[<p>　　今天在看51testing的博客时，看到这么一个网页登录的测试用例，想到自己之前写的那个关于登录页面的简单的功能测试用例真的是太弱了，感觉很多都没有考虑进去。特此在这里记录下来，参考。具体需求： 有一个登陆页面， （假如上面有2个textbox, 一个提交按钮。 请针对这个页面设计30个以上的TestCase.）</p>
<p>　　此题的考察目的：面试者是否熟悉各种测试方法，是否有丰富的web测试经验， 是否了解Web开发，以及设计Test case的能力<br>首先，你要了解用户的需求，比如这个登录界面应该是弹出窗口式的，还是直接在网页里面。对用户名的长度，和密码的强度（就是是不是必须多少位，大小写，特殊字符混搭）等。还有比如用户对界面的美观是不是有特殊的要求？（即是否要进行UI测试）。剩下的就是设计用例了 ，等价类，边界值等等。<br>　　请你记住一点，<strong>任何测试，不管测什么都是从了解需求开始的。</strong></p>
<p><strong>功能测试(Function test)</strong><br>　　0.  什么都不输入，点击提交按钮，看提示信息。（非空检查）<br>　　1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。（正常输入）<br>　　2.输入错误的用户名或者密码, 验证登录会失败，并且提示相应的错误信息。（错误校验）<br>　　3.登录成功后能否能否跳转到正确的页面（低）<br>　　4.用户名和密码，如果太短或者太长，应该怎么处理（安全性，密码太短时是否有提示）<br>　　5.用户名和密码，中有特殊字符（比如空格），和其他非英文的情况（是否做了过滤）<br>　　6.记住用户名的功能<br>　　7.登陆失败后，不能记录密码的功能<br>　　8.用户名和密码前后有空格的处理<br>　　9.密码是否加密显示（星号圆点等）<br>　　10.牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个按钮是否好用<br>　　11.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确<br>　　12.输入密码的时候，大写键盘开启的时候要有提示信息。</p>
<p><strong>界面测试(UI Test)</strong><br>　　1.布局是否合理，2个testbox 和一个按钮是否对齐<br>　　2.testbox和按钮的长度，高度是否复合要求<br>　　3. 界面的设计风格是否与UI的设计风格统一<br>　　4. 界面中的文字简洁易懂，没有错别字。</p>
<p><strong>性能测试(performance test)</strong><br>　　1.打开登录页面，需要几秒<br>　　2.输入正确的用户名和密码后，登录成功跳转到新页面，不超过5秒</p>
<p><strong>安全性测试(Security test)</strong><br>　　1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)<br>　　2.用户名和密码是否通过加密的方式，发送给Web服务器<br>　　3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript验证<br>　　4.用户名和密码的输入框，应该屏蔽SQL注入攻击<br>　　5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）<br>　　6.错误登陆的次数限制（防止暴力破解）<br>　　7. 考虑是否支持多用户在同一机器上登录；<br>　　8. 考虑一用户在多台机器上登录</p>
<p><strong>可用性测试(Usability Test)</strong><br>　　1. 是否可以全用键盘操作，是否有快捷键<br>　　2. 输入用户名，密码后按回车，是否可以登陆<br>　　3. 输入框能否可以以Tab键切换</p>
<p><strong>兼容性测试（Compatibility Test）</strong><br>　　1.主流的浏览器下能否显示正常已经功能正常（IE,6,7,8,9, Firefox, Chrome, Safari,等）<br>　　2.不同的平台是否能正常工作，比如Windows, Mac<br>　　3.移动设备上是否正常工作，比如Iphone, Andriod<br>　　4.不同的分辨率</p>
<p><strong>本地化测试（Localization test）</strong><br>　　1. 不同语言环境下，页面的显示是否正确。<br>　　软件辅助性测试 （Accessibility test）<br>　　软件辅助功能测试是指测试软件是否向残疾用户提供足够的辅助功能<br>　　2. 高对比度下能否显示正常 （视力不好的人使用）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　今天在看51testing的博客时，看到这么一个网页登录的测试用例，想到自己之前写的那个关于登录页面的简单的功能测试用例真的是太弱了，感觉很多都没有考虑进去。特此在这里记录下来，参考。具体需求： 有一个登陆页面， （假如上面有2个textbox, 一个提交按钮。 请针对]]>
    </summary>
    
      <category term="测试用例" scheme="http://silencewt.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试用例" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[9本java程序员必读的书]]></title>
    <link href="http://silencewt.github.io/2014/12/25/9%E6%9C%ACjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB%E7%9A%84%E4%B9%A6/"/>
    <id>http://silencewt.github.io/2014/12/25/9本java程序员必读的书/</id>
    <published>2014-12-25T13:11:05.000Z</published>
    <updated>2014-12-25T13:22:59.000Z</updated>
    <content type="html"><![CDATA[<p>来源：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scene=1#rd" target="_blank" rel="external">http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scene=1#rd</a></p>
<p>　　本文列出的9本书在Java程序员界都是被认为很棒的书。当一个程序员开始初学Java时，他的第一个问题应该是如何选择一本书来作为指导学习Java。这个问题也就表明，相对于其他的教程和博客，Java书籍还是很重要的参考，主要表现在以下两点</p>
<p>●通常书籍是由比较权威的程序员来撰写的。</p>
<p>●相比其他媒介，书籍对于内容的描述更加详细，解释更加明确。</p>
<p>　　本文列出的九本书是我个人非常喜欢的Java书籍，当我有时间的时候，我就会将它们捧在手里阅读。甚至有些书我反复读过很多遍，每次重新读的时候总会有新的收获。因此这些书也是大部分Java程序员喜欢的书籍。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java1.jpg" alt="javabook1"><br>　　Head　First Java是所有编程或者Java初学者最适合的书籍，我很喜欢轻松和寓教于乐的Head First风格，这应该是最有意思的关于Java的书。无论是初级，中级还是高级都能从中有所收获。学习本书，你可以了解到类，对象，线程，集合等编程知识，还可以了解到泛型，枚举，可变参数和自动装箱等语言特性。本书中还涉及到了Java高级编程中的Swing，网络编程，IO操作等，可以让初学者对Java有比较完整地概念。如果你是一位Java初学者，不要犹豫，这本书最适合你了。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java2.jpg" alt="javabook２"><br>　　Head First设计模式又是一部Head First系列的书籍。作者为Kathy Sierra及其团队。当我在2006年开始读这本书的时候，我对设计模式并不是很了解。设计模式解决什么问题，怎么解决问题，如何使用设计模式，设计模式有什么好处，这些问题我几乎都无法回答出来。但是当我读完这本书的时候，一切都豁然开朗。在本书介绍继承和组合一章，使用简单有趣的例子，一步一步提出问题并解决问题，最终得出最优解。本书中会有很多要点总结，幽默对话，练习题还有有名的单词接龙等帮助你更好地了解设计模式。如果你想了解Java中的设计模式，请带走这本书。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java3.jpg" alt="javabook3"><br>　　Effective Java这本书也是一本我最喜欢的。本书为领导开发Java集合框架和并发API包的 约书亚·布洛克 大神所著。本书适合于有着数年开发经验Java程序员，通过本书我们可以很多编程中的最佳实践，并且可以从JDK贡献者布洛克大神这里汲取经验。Effective Java从质量，内容和问题解答方式上来说都是一本评价很高的书，因此读这本书会是一种感觉很棒的体验。另外本书的章节相对比较轻量，与其他章节耦合度较低，因此在旅行或者闲暇时间阅读也是可以的。在内容方面，Effective Java包含了从静态工厂，序列化，equals和hashcode到泛型，枚举，可变参数以及反射的最佳解决方法。本书对Java各方面知识点的讲解会让你受益匪浅。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java4.jpg" alt="enter image description here"><br>又一部 约书亚·布洛克 大神的经典之作，当然本书的另一位主作者为 Doug Lea（影响两次Java历史上的大变革的大神）。这本书几乎就是Java并发和多线程编程方面的权威，同时也是核心Java开发人员必读的一本书。本书的强大主要表现在</p>
<ul>
<li>本书非常详细地描述了多线程和并发中的诸多(小)细节。</li>
<li>本书并非聚焦于核心Java代码的实现，而是关注并发引起的问题，比如死锁，饥饿，线程安全，竞争条件，然后提供可行的方法来解决这些问题。因此这本书可以很好地帮助开发者了解并掌握并发包以及其中的CountDownLatch，CyclicBarrier，BlockingQueue，Semaphore这些类。这也是我一遍一遍阅读这本书的原因。</li>
<li>书中的例子简明扼要清晰，很能描述问题。</li>
<li>解释明确：本书很好地解释了什么是错的，为什么错，怎样改正。这也是本书畅销的原因之一。</li>
</ul>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/java5.jpg" alt="enter image description here"><br>　　这本书是来自O’Reilly的一本成功之作，作者为Naftalin和Philip Wadler。正如书名可知，这本书的内容关注于泛型和集合这两个Java语言的核心方面。本书对于那些有编程经验的程序员加强对集合和泛型的理解和掌握有很大的帮助。本书详细介绍了每一个集合的API，Set, List, Map, Queue，以及他们的实现，对比不同场景下它们的性能优劣。每个章节最后的对比图表很不错。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java6.jpg" alt="enter image description here"><br>　　本书为我个人的最爱，本书重点关注性能监视，性能剖析以及如何使用工具对性能分析。本书不同于其他的编程书籍，因为本书中涉及到很多Java虚拟机的细节，垃圾回收机制，Java堆内存监视以及对程序性能剖析。其中讲述JVM的章节写的很不错，很值得咀嚼。注意，这本书属于编程高级层次，阅读需要具有足够的Java编程经验。初级和中级Java开发者也可以阅读本书也会学到不同程度的干货。所以，你想进行性能调优，把这本书放到你的书架上吧。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java7.jpg" alt="enter image description here"><br>　　再介绍一本 约书亚·布洛克 大神写的书。本书的另一位作者为Neal Gafter（已转到微软做Donet Compiler技术Lead）。本书讲述了Java语言中的极端情况和陷阱。相对于C++，Java更加安全低风险，JVM有着垃圾回收机制，让Java程序员不用关心内存分配和释放，大大提高了程序的开发效率。但是有些时候，即便是经验丰富的程序员也会被Java中的极端情况或陷阱给绊倒。本书列举并详细描述了Java中的这些陷阱。如果你喜欢刨根问底，钻牛角尖，这本书就是为你而写。通过本书，你可以了解很多java的核心知识并对自己的Java水平有所知晓。本人更加喜欢上面提到的 约书亚·布洛克 的 Effective Java 和 Concurrency Practice in Java。但是如果你感兴趣，还是可以去尝试的。为了让收获最大化，你可以先尝试解决书中的问题，然后对着书中的解释进行比较。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java8.jpg" alt="enter image description here"><br>　　这是一本属于Head First系列的关于面向对象编程的书。本书建议和Head First设计模式结合阅读，效果更佳。本书关注于面向对象设计原则，比如多用组合少用继承，针对接口编程而非针对实现编程，不要重复你自己等。这本书可以帮助你写出好代码并且参考最佳实践进行优化改善。当然本书中的内容也适合使用其他面向对象的语言的程序员。想学好面向对象编码和设计规则，现在就开始读这本书哈。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/java9.jpg" alt="enter image description here"><br> 　　Thinking in Java book应该是Java中文界最有名的书籍了，中文又名 Java编程思想。作者为Bruce Eckel，他也是Thinking in C++的作者，他用自己很独特的观点讲述了Java。据我所知，这本书获得了很高的认可，本书是一本介绍齐全的Java学习参考书。如果你不喜欢Head First类似小人书那样的讲解，可以尝试这本书。本书的内容讲解详细，成熟（相对Head First有种教科书的感觉）。</p>
<p>　　这就是我的关于Java编程相关的推荐的书，这些都可以说是看成经典中的经典。像Effective Java 和 Head First 系列我已经反复阅读了很多遍。相信看完本文，根据自己的水平和想要提升的知识侧重，你应该能选出最适合自己的书了。<br>　　Mark下，以后慢慢看。。。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来源：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=202904638&amp;idx=2&amp;sn=21dd20438e32a24e78e8c33dd4a0991e&amp;scen]]>
    </summary>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java--面向抽象编程]]></title>
    <link href="http://silencewt.github.io/2014/12/25/java-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://silencewt.github.io/2014/12/25/java-面向抽象编程/</id>
    <published>2014-12-25T13:09:48.000Z</published>
    <updated>2014-12-25T13:10:15.000Z</updated>
    <content type="html"><![CDATA[<p>　　所谓面向抽象编程是指当设计某种重要的类时，不让该类面向具体的类，而是面向抽象类，及所设计类中的重要数据是抽象类声明的对象，而不是具体类声明的对象。就是利用abstract来设计实现用户需求。</p>
<p>比如：我们有一个Circle圆类，计算其面积。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Geometry</span></span>{
<span class="keyword">double</span> r;
Circle(<span class="keyword">double</span> r){
    <span class="keyword">this</span>.r = r;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span>(){
    <span class="keyword">return</span> (<span class="number">3.14</span>*r*r);
}
}
</code></pre><p>现在要设计一个Pillar（柱类），getvolume（）可以计算柱体的体积。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Pillar{
Circle bottom;
<span class="keyword">double</span> height;
Pillar(Circle bottom, <span class="keyword">double</span> height){
    <span class="keyword">this</span>.bottom = bottom;
    <span class="keyword">this</span>.height = height;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVolume</span>(){
    <span class="keyword">return</span> bottom.getArea() * height;
}
}
</code></pre><p>　　在Pillar（柱类）中，bottom是用具体类Circle声明的对象，如果不涉及用户需求的变化，上面Pillar（柱类）的设计没有什么不妥，但是在某个时候，用户希望Pillar（柱类）能创建出底部是三角形的柱体。显然上面的Pillar（柱类）就无法创建出这样的柱体，即上述设计的Pillar（柱类）不能应对用户的这中需求。</p>
<p>　　重新修改Pillar（柱类）。注意到柱体的计算体积的关键是计算出底面积，一个柱体在计算底面积是不应该关心他的底是社么形状的具体图案，应该只关心这种图像是否具有计算出面积的方法。因此，在设计Pillar（柱类）的时候不应当让他的底是某个具体类的声明的对象，一旦这么做，Pillar（柱类）就会依赖具体类，缺乏弹性，难以应对需求的变化。</p>
<p><strong>第一步</strong>：定义一个抽象类Geometry，类中定义一个抽象的getArea（）方法，Geometry类如下。这个抽象类将所有计算面积的方法都抽象为一个标识：getArea（）无需考虑算法细节。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Geometry{
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getArea</span>();
}
</code></pre><p><strong>第二步</strong>：Pillar（柱类）可以面向Geometry类编写代码，即Pillar（柱类）应当把Geometry类作为自己的成员，该成员可以调用Geometry的子类重写的getArea（）方法。这样，Pillar（柱类）就将计算底面积的任务指派个Geometry类的子类的实例，不再依赖于某一个具体的类，而是面向Geometry类的，即Pillar（柱类）的bottom是用抽象类Geometry声明的对象，而不是具体的某一类，新的Pillar（柱类）如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Pillar{
Geometry botom;
<span class="keyword">double</span> height;
Pillar(Geometry bottom, <span class="keyword">double</span> height){
    <span class="keyword">this</span>.bottom = bottom;
    <span class="keyword">this</span>.height = height;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVolume</span>(){
    <span class="keyword">return</span> bottom.getArea() * height;
}
}
</code></pre><p>在新增Geometry的子类时就不需要修改Pillar（柱类）的任何代码，只需要增加一个Triangle类（三角形）。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Geometry</span></span>{
<span class="keyword">double</span> a,b;
Circle(<span class="keyword">double</span> a, <span class="keyword">double</span> b){
    <span class="keyword">this</span>.a = a;
    <span class="keyword">this</span>.b = b;
}
<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span>(){
    <span class="keyword">return</span> (a*b);
}
}
</code></pre><p>应用：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Application{
<span class="keyword">public</span> state <span class="keyword">void</span> <span class="title">main</span>(String args[]){
    Pillar pillar;
    Geometry bottom;
    bottom = <span class="keyword">new</span> Circle(<span class="number">10</span>);             <span class="comment">//子类的上转型对象</span>
    pillar = <span class="keyword">new</span> Pillar(bottom, <span class="number">10</span>);
    System.<span class="keyword">out</span>.println(<span class="string">"圆柱体的体积"</span> + pillar.getVolume());
    bottom = <span class="keyword">new</span> Rectangle(<span class="number">10</span>,<span class="number">10</span>);
    pillar = <span class="keyword">new</span> Pillar(bottom, <span class="number">10</span>);
    System.<span class="keyword">out</span>.println(<span class="string">"矩形底的体积"</span> + pillar.getVolume());
}
}
</code></pre><p><strong>总结</strong>：面向抽象编程目的是为了应对用户需求的变化，将某个类中经常因需求变化而需要改变的代码从类中分离出去。其核心是让类中每种可能的变化对应的交给抽象类的一个子类去负责，从而让该类的设计者不去关心具体的实现，避免所设计的类依赖于具体的实现。</p>
<p><strong>关于抽象类</strong>：</p>
<ul>
<li>对于抽象类不能用new创建该类的对象，但可以成为其子类的上转型对象，从而该对象可以调用子类重写的方法。</li>
<li>一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法，给出方法体。</li>
</ul>
<p>　　</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　所谓面向抽象编程是指当设计某种重要的类时，不让该类面向具体的类，而是面向抽象类，及所设计类中的重要数据是抽象类声明的对象，而不是具体类声明的对象。就是利用abstract来设计实现用户需求。</p>
<p>比如：我们有一个Circle圆类，计算其面积。</p>
<pre]]>
    </summary>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java--面向接口编程]]></title>
    <link href="http://silencewt.github.io/2014/12/25/java-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
    <id>http://silencewt.github.io/2014/12/25/java-面向接口编程/</id>
    <published>2014-12-25T12:58:46.000Z</published>
    <updated>2014-12-25T13:05:55.000Z</updated>
    <content type="html"><![CDATA[<p>　　之前看的一本书的笔记，上周再看设计模式的时候，想到了这篇之前在看某本书时候的笔记。</p>
<p>　　面向接口编程很重要的一点就是接口回调，用接口声明的变量称作接口变量，属于引用型变量，可以存放实现该接口的类的实例的引用，对象引用。<strong>接口回调</strong>：可以把实现某一接口的类创建的对象的引用赋值给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口方法。</p>
<p>Com com;      //接口<br>ImplCom object;    //实现接口的对象<br>com = object;        //接口回调，com会根据对象的不同而实现不同的接口方法，回调类重写的接口方法<br>接口和abstract类的比较如下：<br>abstract类和接口都可以有abstract方法。<br>接口中只可以有常量，不能有变量；而abstract类中既可以有常量也可以有变量。abstract类中也可以有非abstract方法，接口不可以。</p>
<p>　　在设计程序时应当根据具体的分析来确定是使用抽象类还是接口。abstract类除了提供重要的需要重写的abstract方法外，也提供了子类可以继承的变量和非abstract方法。如果某个重要问题需要使用继承才能更好地解决，比如，子类需要重写父类的abstract方法，还需要从父类继承一些变量或继承一些重要的非abstract方法，就可以考虑用abstract类。如果某个问题不需要继承，只是需要若干个类给出某些重要的abstract方法的实现细节，就可以考虑使用接口。<br>　　使用接口编程的最重要的<strong>核心思想就是使用接口回调</strong>，及接口变量存放实现该接口的类的对象的引用，从而接口变量就可以回调类实现的接口方法。<br>　　<img src="http://7te8s4.com1.z0.glb.clouddn.com/jiekou.jpg" alt="接口编程">　　</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Advertisement {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAdvertisement</span>();
    <span class="keyword">public</span> String <span class="title">getCorpName</span>();
}
</code></pre><p>2、设计AdvertisementBoard类（广告牌），该类有一个show（Advertisement adver）方法，该方法的参数是接口Advertisement的类型，显然该参数adver可以存放任何实现Advertisement接口的类的对象的引用，并回调类重写的接口方法showAdvertisement()来显示公司的广告词，回调类重写的接口方法getCorpName来获取公司名称。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> AdvertisementBoard{
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> (Advertisement adver){
    System.<span class="keyword">out</span>.println(adver.getCorpName()+<span class="string">"广告词"</span>);
    adver.showAdvertisement（）; <span class="comment">//接口回调</span>
}
}
</code></pre><p>实现接口的A公司类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Acorp implement Advertisement {
<span class="keyword">public</span> <span class="keyword">void</span> showAdvertisement（）{
    System.<span class="keyword">out</span>.println(<span class="string">"AAAAAAAAAAAAAAAAA"</span>);
}
<span class="keyword">public</span> String getCorpName（）{
    <span class="keyword">return</span> <span class="string">"A Corp"</span>;
}
}
</code></pre><p>实现接口的B公司类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Bcorp implement Advertisement {
<span class="keyword">public</span> <span class="keyword">void</span> showAdvertisement（）{
    System.<span class="keyword">out</span>.println(<span class="string">"BBBBBBBBBBBBBBBBB"</span>);
}
<span class="keyword">public</span> String getCorpName（）{
    <span class="keyword">return</span> <span class="string">"B Corp"</span>;
}
}
</code></pre><p>运行住程序：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> test （）{
<span class="keyword">public</span> state <span class="keyword">void</span> main （<span class="keyword">string</span> args[]）{
    AdvertisementBoard board = <span class="keyword">new</span> AdvertisementBoard();
    board.show(<span class="keyword">new</span> Acorp());
    board.show(<span class="keyword">new</span> Bcorp());
}
}
</code></pre><p>最后程序会根据对象的不同调用不同的方法。若想要添加C公司，只要实现接口的方法就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　之前看的一本书的笔记，上周再看设计模式的时候，想到了这篇之前在看某本书时候的笔记。</p>
<p>　　面向接口编程很重要的一点就是接口回调，用接口声明的变量称作接口变量，属于引用型变量，可以存放实现该接口的类的实例的引用，对象引用。<strong>接口回调</stron]]>
    </summary>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式----建造者模式]]></title>
    <link href="http://silencewt.github.io/2014/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://silencewt.github.io/2014/12/25/设计模式-建造者模式/</id>
    <published>2014-12-25T12:50:32.000Z</published>
    <updated>2014-12-28T02:29:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong>创建型模式</strong></p>
<p>建造者模式：又叫生成器模式，就是对流程的抽象，一步一步的去创建一个复杂的对象。</p>
<p>举个实例，有一个化学老师需要在公开课上向校长等人演示摸个试管实验，老师请了两个同学A和B上台演示，ＡＢ的操作顺序都是一样的，只是试剂所放的量不一样而已，那么老师要如何控制这个学生呢？如果我们只是简单地定义两个学生类A和B的话，由于两个人的实验顺序（方法）是一样的，那么就很容易出错，搞错了顺序？或者漏掉某个步骤？</p>
<p><strong>解决</strong>：因为他们具有一样的组成成分，那么就可以让他们同时继承一个抽象接口，该接口提供他们所需要的步骤，以确保不会漏掉某步。因为子类必须实现抽象接口里的所有方法。</p>
<p>抽象接口类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Student {
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou1</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou2</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buZou3</span>();
}
</code></pre><p>学生A：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentA</span> <span class="keyword">extends</span> <span class="title">Student</span></span>{

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou1</span>() {
    System.out.println(<span class="string">"AAAAA"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou2</span>() {
    System.out.println(<span class="string">"BBBBBB"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou3</span>() {
    System.out.println(<span class="string">"CCCCCC"</span>);
}
}
</code></pre><p>学生B：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">Student</span></span>{
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou1</span>() {
    System.out.println(<span class="string">"OOOOO"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou2</span>() {
    System.out.println(<span class="string">"PPPPP"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buZou3</span>() {
    System.out.println(<span class="string">"QQQQQQ"</span>);
}
}
</code></pre><p>虽然保证了不会漏掉某部，但是还是无法保证学生能正确操作？这是就可以使用建造者模式，有老师来控制。</p>
<p>teacher类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Teacher {
<span class="keyword">private</span> Student student;
<span class="keyword">public</span> <span class="title">Teacher</span>(Student student) {
    <span class="keyword">this</span>.student = student;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DirectEx</span>() {
    student.buZou1();
    student.buZou2();
    student.buZou3();
}
}
</code></pre><p>主函数：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]) {
    Student studentA = <span class="keyword">new</span> StudentA();
    Student studentB = <span class="keyword">new</span> StudentB();
    Teacher teacher = <span class="keyword">new</span> Teacher(studentA);
    teacher.DirectEx();
    teacher = <span class="keyword">new</span> Teacher(studentB);
    teacher.DirectEx();
}
</code></pre><p>   <strong>总结</strong>：建造者模式就是当需要一个复杂对象的构建或者造作过程和这个对象的表示相分离，就可以使用了。就相当于A和 B是具体的创建者，知道怎么操作，但是学生不知道完成一次实验需要按照何种步骤来进行，而老师作为指挥者，了解实验步骤，可以指挥学生（按一定顺序调用学生类提供的方法）来实验，客户端就只需要关心结果就好了。使用这个模式，用户只要制定要创建的类型就可以得到对应的对象，为具体的过程被direct和builder影藏了。而这正体现了依赖倒转的原则，抽象不依赖于细节，细节依赖于抽象。</p>
<hr>
<p>建造者模式的<code>标准代码</code>：<br>Builder：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Builder {
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPartA</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPartB</span>();
    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">getResult</span>();   
}
</code></pre><p>product：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Product {
    ArrayList&lt;String&gt; parts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(String part) {
        parts.add(part);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"create product"</span>);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.size(); i++) {
            String part = parts.<span class="keyword">get</span>(i) ;
            System.<span class="keyword">out</span>.println(part);
        }
    }
}
</code></pre><p>建造者类A：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilderA</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>{
<span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartA</span>() {
    product.add(<span class="string">"part A"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartB</span>() {
    product.add(<span class="string">"part B"</span>);
}
<span class="annotation">@Override</span>
<span class="keyword">public</span> Product <span class="title">getResult</span>() {
    <span class="keyword">return</span> product;
}
}
</code></pre><p>建造者B:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilderB</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>{

<span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartA</span>() {
    product.add(<span class="string">"part W"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPartB</span>() {
    product.add(<span class="string">"part Q"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> Product <span class="title">getResult</span>() {
    <span class="keyword">return</span> product;
}
}
</code></pre><p>指挥者：这里控制之行动的顺序</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Director {
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span>(Builder builder){
    builder.builderPartA();
    builder.builderPartB();
}
}
</code></pre><p>客户端：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]) {
    Director director = <span class="keyword">new</span> Director();
    Builder builder = <span class="keyword">new</span> ConcreteBuilderA();
    Builder builder2 = <span class="keyword">new</span> ConcreteBuilderB();

    director.construct(builder);
    Product productA = builder.getResult();
    productA.show();
    director.construct(builder2);
    Product productB = builder2.getResult();
    productB.show();
}
</code></pre><p>  建造者优点：</p>
<p>1）在建造者模式中，客户端不必知道产品内部组成的具体细节，将产品本身于产品的创建过程进行解耦，是的相同的创建过程可以创建不同的产品对象。</p>
<p>2）每一个具体的建造者都是独立的，而与其他的具体建造者没有关系，可以很方便的去增加或者删除一个建造者，用户用不同的建造者就可以获得不同的产品。</p>
<p>3）可以更加精细的控制产品创建的具体过程，将复杂的产品步骤分解在不同的方法当中，是的创建过程更加清晰。</p>
<p>4）增加新的建造者不用修改原有类库的代码，指挥者类是针对抽象建造者类编写的，扩展方便，符合开放封闭原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>创建型模式</strong></p>
<p>建造者模式：又叫生成器模式，就是对流程的抽象，一步一步的去创建一个复杂的对象。</p>
<p>举个实例，有一个化学老师需要在公开课上向校长等人演示摸个试管实验，老师请了两个同学A和B上台演示，ＡＢ的操作顺序都是一样]]>
    </summary>
    
      <category term="设计模式" scheme="http://silencewt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
