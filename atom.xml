<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silence 婷婷 Blog]]></title>
  <subtitle><![CDATA[既然选择远方，便风雨兼程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://silencewt.github.io/"/>
  <updated>2015-01-17T12:29:26.502Z</updated>
  <id>http://silencewt.github.io/</id>
  
  <author>
    <name><![CDATA[Wangt]]></name>
    <email><![CDATA[wangt_hust@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[python学习笔记（三）]]></title>
    <link href="http://silencewt.github.io/2015/01/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://silencewt.github.io/2015/01/17/python学习笔记（三）/</id>
    <published>2015-01-17T12:27:50.000Z</published>
    <updated>2015-01-17T12:28:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="函数式编程："><strong>函数式编程</strong>：</h4>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python内建了map()和reduce()函数。</p>
<p>map()：函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。举例：有一个函数f(x)=x^2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<p>>&gt;&gt;map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])<br>[1, 4, 9, 16, 25, 36, 49, 64, 81]</p>
<p>reduce()：把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>>&gt;&gt; def fn(x, y): …<br>return x * 10 + y …<br>>&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])<br>13579</p>
<p>filter()：和map()类似，也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<p>在一个list中，删掉偶数，只保留奇数，可以这么写：<br>def is_odd(n):<br>    return n % 2 == 1<br> filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]) # 结果: [1, 5, 9, 15]</p>
<p>sorted()：该函数可以对list进行排序，sorted([36, 5, 12, 9, 21])。它也是一个高阶函数，可以接收一个比较函数来实现自定义的排序。比如，如果要倒序排序，就可以自定义一个reversed_cmp函数：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">reversed_cmp</span><span class="params">(x, y)</span>:</span>    
<span class="keyword">if</span> x &gt; y:       
    <span class="keyword">return</span> -<span class="number">1</span>   
<span class="keyword">if</span> x &lt; y:       
     <span class="keyword">return</span> <span class="number">1</span>    
<span class="keyword">return</span> <span class="number">0</span>
</code></pre><p>传入自定义的比较函数reversed_cmp，就可以实现倒序排序：</p>
<p>>&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp) [36, 21, 12, 9, 5]</p>
<hr>
<h4 id="面向对象编程"><strong>面向对象编程</strong></h4>
<p><strong>类</strong>：</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span>               
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span>        
        self.name = name         
        self.score = score
</code></pre><p> 　　Student类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 <strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创#建的实例本身。有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</p>
<p>　　类中定义的函数和其他函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，仍然可以用默认参数、可变参数和关键字参数。</p>
<p>外部代码还是可以自由地修改一个实例的name、score属性</p>
<p>＼&gt;&gt;&gt; bart = Student(‘Bart Simpson’, 98)<br>＼&gt;&gt;&gt; bart.score<br> 98<br>＼&gt;&gt;&gt; bart.score = 59</p>
<p>　　如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<strong>。self.</strong>name = name，self.__score = score</p>
<p>　　在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<p>　　在Python中，变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，不能用<strong>name</strong>、<strong>score</strong>这样的变量名。</p>
<p><strong>多态</strong>：</p>
<p>　　当我们定义一个class的时候，就相当于定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p>
<p>判断一个变量是否是某个类型可以用isinstance()判断：</p>
<p>＼&gt;&gt;&gt; isinstance(a, list)</p>
<p>true 或 false</p>
<p>在调用类实例方法的时候，变量视作父类类型，这样，所有子类类型都可以正常被接收。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="函数式编程："><strong>函数式编程</strong>：</h4>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python内建了map()和reduce()函数。</p>
<p>map()：函数]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python学习笔记（二）]]></title>
    <link href="http://silencewt.github.io/2015/01/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://silencewt.github.io/2015/01/17/python学习笔记（二）/</id>
    <published>2015-01-17T12:16:48.000Z</published>
    <updated>2015-01-17T12:22:55.000Z</updated>
    <content type="html"><![CDATA[<h4 id="List："><strong>List</strong>：</h4>
<p>list是一种有序的集合，可以随时添加和删除其中的元素。List里面的元素可以是不同类型的，也可以是list，嵌套，相当于二维数组。list=[‘dfs’,’DSF’,123]，空的list=[]</p>
<p>len（）：函数可以获得list元素的个数</p>
<p>list[0]: 下标为0的元素值</p>
<p>list[-1]：倒数第一个元素，即最后一个数</p>
<p>pop（）：弹出末尾的元素</p>
<p>pop（i）：弹出第i个元素</p>
<p>append（）：list中追加元素到末尾</p>
<p>insert（1，“”）：把元素插入到指定的位置，比如索引号为1的位置。</p>
<p>sort()：对元素排序</p>
<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置可变也不可变对象：</p>
<p>字符串是不可变的，比如str=”apple”；str.replace(‘a’, ‘A’) 这个的结果是Apple，但是str还是apple</p>
<p>list是可变的：比如list = [1,2,4,3,5]; list.sort(); 这个结果是12345，list的结果也是12345</p>
<p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<hr>
<h4 id="tuple："><strong>tuple</strong>：</h4>
<p>有序列表叫元组。tuple和list非常类似，但是tuple一旦初始化就不能修改，没有append()，insert()这样的方法。其他获取元素的方法和list是一样的。当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来。tuple=（’dfs’,’DSF’,123），空的tuple=（）；只有一个元素的tuple=(1，)</p>
<p>在显示只有1个元素的tuple时，也要加一个逗号,，以免误解成数学计算意义上的括号。</p>
<p>“可变”的tuple：tuple = (‘a’, ‘b’, [‘A’, ‘B’])；tuple[2][0]=’x’；tuple=[2][1]=’y’；这时候在输出tuple为(‘a’, ‘b’, [‘x’, ‘y’])？</p>
<p>这个tuple定义的时候有3个元素，分别是’a’，’b’和一个list。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/a.jpg" alt="a"></p>
<p>之后修改list的值，变为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/2.jpg" alt="q"></p>
<p>tuple指向的值并没有变化，变化的只是list指向的值，tuple一开始指向的list并没有改成别的list，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>
<hr>
<h4 id="字典："><strong>字典</strong>：</h4>
<p>dictionary，相当于map，一个键值对，使用大括号，dict = {‘apple’： 1，‘bananan’：2， ’orange‘：3}。相应的使用dict[‘apple’]就可以得到1。</p>
<p>这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。多次对一个key放入value，后面的值会把前面的值冲掉即更新。key必须是不可变对象。</p>
<p>判断是否存在key：一、可以使用in ：’apple’ in dict 输出 true。二、通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：dict.get（’apple’），dict.get（’apple’,-1）。</p>
<p>pop(key)方法，删除一个key，对应的value也会从dict中删除</p>
<p>和list比较，dict有以下几个特点：</p>
<p>查找和插入的速度极快，不会随着key的增加而增加；</p>
<p>需要占用大量的内存，内存浪费多。</p>
<p>而list相反：</p>
<p>查找和插入的时间随着元素的增加而增加；</p>
<p>占用空间小，浪费内存很少。</p>
<p>所以，dict是用空间来换取时间的一种方法。</p>
<hr>
<h4 id="set："><strong>set：</strong></h4>
<p>set和dict类似，也是一组key的集合，但不存储value。在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：s=set([1,2,3])，重复的值会自动过滤：s=set([1,2,2,3,3]) 为set([1,2,3])</p>
<p>add(key)：方法可以添加元素到set中</p>
<p>remove(key)：方法可以删除元素</p>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作（s1 &amp; s2 | S3)</p>
<hr>
<h4 id="切片Slice："><strong>切片Slice</strong>：</h4>
<p>L[0:3]：L[:3]取前3个元素，从索引0开始取，直到索引3为止，但不包括索引3。</p>
<p>L[-2:]：倒数两个数（后两个数），最后一个数的索引是-1</p>
<p>L[-2:-1]：倒数第二个数，这个时候不包括-1即最后一个数。</p>
<p>L[:：5]：每5个数取一个，</p>
<hr>
<h4 id="迭代："><strong>迭代</strong>：</h4>
<p>给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple。for…..in </p>
<p>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()。</p>
<p>由于字符串也是可迭代对象，因此，也可以作用于for循环：for ch in ‘ABC’</p>
<p>使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，不必知道该对象究竟是list还是其他数据类型。</p>
<p>如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：</p>
<p>>&gt;&gt; from collections import Iterable<br>>&gt;&gt; isinstance(‘abc’, Iterable) # str是否可迭代<br> True</p>
<p>如果要对list实现类似Java那样的下标循环？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p>
<p>>&gt;&gt; for i, value in enumerate([‘A’, ‘B’, ‘C’]):<br> …     print i, value …<br>0 A<br>1 B</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="List："><strong>List</strong>：</h4>
<p>list是一种有序的集合，可以随时添加和删除其中的元素。List里面的元素可以是不同类型的，也可以是list，嵌套，相当于二维数组。list=[‘dfs’,’DSF’,123]，空的lis]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python学习笔记（一）]]></title>
    <link href="http://silencewt.github.io/2015/01/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://silencewt.github.io/2015/01/17/python学习笔记（一）/</id>
    <published>2015-01-17T12:02:24.000Z</published>
    <updated>2015-01-17T12:14:16.000Z</updated>
    <content type="html"><![CDATA[<p>这个python记录的有点乱，都是在看电子档资料的时候，记录下来的。</p>
<p>1、学习Python与其他语言最大的区别就是，Python的代码块不使用大括号（{}）来控制类，函数以及其他逻辑判断。python最具特色的就是用缩进来写模块。</p>
<p>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行</p>
<p>2、Python语句中一般以新行作为为语句的结束符。但是可以使用斜杠（ \）将一行的语句分为多行显示，但是如果包含[], {} 或 () 括号就不需要使用多行连接符。</p>
<p>3、Python 接收单引号(‘ )，双引号(“ )，三引号(‘’’ “””) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法</p>
<p>4、注释采用#，还有一种文档字符串的特别注释。你可以在模块、类或者函数的起始添加一个字符串，起到在线文档的功能。与普通注释不同，文档字符串可以在运行时访问，也可      以用来自动生成文档。</p>
<p>5、Python中的变量不需要声明，变量的赋值操作既是变量声明和定义的过程。每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>6、可以为多个对象指定多个变量：a, b, c = 1, 2, “john” 即将1赋给a,2赋给b,john赋给c。</p>
<p>7、Python有五个标准的<strong>数据类型</strong>：</p>
<p>Numbers（数字）：int  long(L)  float complex</p>
<p>String（字符串）:python的字串列表有2种取值顺序:从左到右索引默认0开始的，最大范围是字符串长度少1，从右到左索引默认-1开始的，最大范围是字符串开头。+是字符串连接运算符，星号（<em>）是重复操作（print str</em>2输出两个str）；[:]表示截取字符串的一部分</p>
<p>List（列表）：list = [ ‘abcd’, 786 , 2.23, ‘john’, 70.2 ]列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>Tuple（元组）：用”()”标识。内部元素用逗号隔开。但是元素不能二次赋值（不能修改也不能删除），相当于只读列表，只有一个元素时要留有逗号a=(1,)；可以使用del删除整个元祖</p>
<p>Dictionary（字典）：用”{ }”标识，由索引(key)和它对应的值value组成。结构类似json</p>
<p>列表：是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>python创建对象后，数据类型是不允许改变的，只能用del var1,var2来删除多个对象。</p>
<p>字典：字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，键必须不可变，可以用数，字符串或元组充当，但不可以用列表就不行，</p>
<hr>
<p>python算术运算符</p>
<p>*<em>：幂运算 2*</em>3=8</p>
<p>//：取整数 返回商的整数部分  9.0//2.0=4.0</p>
<p>and：(a and b) 返回 true，类似的有or 和 not</p>
<p>in：成员运算符   x in y 如果x在y中，则为TRUE，not in 表示为x不在y中怎为TRUE </p>
<p>is:身份运算符is是判断两个标识符是不是引用自一个对象（返回结果 1），is not是判断两个标识符是不是引用自不同对象</p>
<hr>
<p>python流程控制</p>
<pre><code><span class="number">1</span>、<span class="keyword">if</span> 判断条件：

      执行语句……

 <span class="keyword">else</span>：（<span class="keyword">elif</span> 判断条件:）

      执行语句……
</code></pre><p> 　　python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or 或and</p>
<pre><code><span class="number">2</span>、<span class="keyword">while</span> 判断条件：

        执行语句……

  <span class="keyword">else</span>：
</code></pre><p>　　在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while     … else 也是一样。while 可以循环嵌套</p>
<pre><code><span class="number">3</span>、<span class="keyword">for</span> itareting_var <span class="keyword">in</span> <span class="keyword">sequence</span>

       statement(s)
</code></pre><hr>
<p>Python函数</p>
<p>函数代码块以def关键词开头，后接函数标识符名称和圆括号()。<br>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。<br>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>函数内容以冒号起始，并且缩进。<br>Return[expression]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</p>
<p>定义一个什么事也不做的空函数，可以用pass语句<br>函数返回多值，其实就是一个tuple：x,y=myfun() == r=myfun(),r=(x,y)</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">( parameters )</span>:</span>
   <span class="string">"函数_文档字符串"</span>
   function_suite
   <span class="keyword">return</span> [expression]
</code></pre><p>所有参数（自变量）在Python里都是按引用传递。如果你在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。</p>
<p><strong>默认参数</strong>：</p>
<p>先定义一个函数，传入一个list，添加一个END再返回：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span>    

    L.append(<span class="string">'END'</span>)    

    <span class="keyword">return</span> L
</code></pre><p>当你正常调用时，结果似乎不错：</p>
<p>＼&gt;&gt;&gt; add_end([1, 2, 3])<br>[1, 2, 3, ‘END’]<br>＼&gt;&gt;&gt; add_end([‘x’, ‘y’, ‘z’])<br> [‘x’, ‘y’, ‘z’, ‘END’]</p>
<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<p>＼&gt;&gt;&gt; add_end()<br>[‘END’]</p>
<p>但是，再次调用add_end()时，结果就不对了：</p>
<p>＼&gt;&gt;&gt; add_end()<br> [‘END’, ‘END’]<br>＼&gt;&gt;&gt; add_end()<br>[‘END’, ‘END’, ‘END’]</p>
<p>　　很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了’END’后的list。</p>
<p>原因解释如下：</p>
<p>　　Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<p>所以，定义默认参数要牢记一点：<strong>默认参数必须指向不变对象</strong>！</p>
<p>要修改上面的例子，我们可以用None这个不变对象来实现：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span>   
    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:        
        L = []    
    L.append(<span class="string">'END'</span>)    
    <span class="keyword">return</span> L
</code></pre><p>现在，无论调用多少次，都不会有问题：</p>
<p>＼&gt;&gt;&gt; add_end()<br>[‘END’]<br>＼&gt;&gt;&gt; add_end()<br>[‘END’]</p>
<p>　　为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
<p><strong>可变参数</strong>：</p>
<p>参数个数不确定，可以把a，b，c……作为一个list或tuple传进来，函数定义如下：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span>   
<span class="keyword">for</span> i <span class="keyword">in</span> numbers:
</code></pre><p>在调用的时候，需要先组装出一个list或tuple：</p>
<p>＼&gt;&gt;&gt; calc([1, 2, 3])</p>
<p>如果利用可变参数，函数的参数改为可变参数：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span>   
 <span class="keyword">for</span> n <span class="keyword">in</span> numbers:
</code></pre><p>调用函数的方式可以简化成这样：</p>
<p>＼&gt;&gt;&gt; calc(1, 2, 3)</p>
<p>　　定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：calc()</p>
<p>　　如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p>
<p>＼&gt;&gt;&gt; nums = [1, 2, 3]<br>＼&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</p>
<p>　　但是这样太繁琐，可以在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：</p>
<p>＼&gt;&gt;&gt; nums = [1, 2, 3]<br>＼&gt;&gt;&gt; calc(*nums)</p>
<p><strong>关键字参数：</strong></p>
<p>　　关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span>
</code></pre><p>　　函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p>
<p>＼&gt;&gt;&gt; person(‘Michael’, 30)</p>
<p>也可以传入任意个数的关键字参数：</p>
<p>＼&gt;&gt;&gt; person(‘Bob’, 35, city=’Beijing’)</p>
<p>　　关键字参数可以扩展函数的功能。比如，在person函数里，可以保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，函数也能收到。试想做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<p>也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>
<p>＼&gt;&gt;&gt; kw = {‘city’: ‘Beijing’, ‘job’: ‘Engineer’} </p>
<p>＼&gt;&gt;&gt; person(‘Jack’, 24, city=kw[‘city’], job=kw[‘job’]) 或者 person(‘Jack’, 24, **kw)</p>
<p><strong>参数组合：</strong></p>
<p>将上面三种参数组合：def func(a, b, c=0, <em>args,**kw):  解释器自动按照参数位置和参数名把对应的参数传进去所以，对于任意函数，都可以通过类似func(\</em>args, **kw)的形式调用它，无论它的参数是如何定义的。</p>
<hr>
<p><strong>匿名函数</strong>：lambda   lambda [arg1 [,arg2, ….argn]] : expression</p>
<p>　　用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。</p>
<p>　　Lambda函数能接收任何数量的参数但只能返回一个表达式的值，同时只能不能包含命令或多个表达式。</p>
<p>　　匿名函数不能直接调用print，因为lambda需要一个表达式。lambda函数拥有自己的名字空间，且不能访问自有参数列表之外或全局名字空间里的参数。虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</p>
<p><strong>模块</strong>就是一个Python文件，只有导入import了模块你才能使用模块里的函数。当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。<br>from  modname  import   funcname1,funcname2….导入某模块中的具体某个函数。</p>
<p>　　模块搜索路径存存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH（就是Python中lib的路劲）和由安装过程决定的默认目录。一个Python表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。</p>
<hr>
<p><strong>命名空间</strong></p>
<p>　　每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。Python会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给全局变量在一个函数里赋值，必须使用global语句。</p>
<p>　　global VarName的表达式会告诉Python， VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量了。</p>
<pre><code>a=<span class="number">0</span>;
<span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span>
 <span class="keyword">global</span> a     <span class="comment">#若将其注释掉将出现错误 UnboundLocalError: local variable 'a' referenced before assignment</span>
 a +=<span class="number">1</span>
<span class="keyword">print</span> a
</code></pre><p><strong>包</strong></p>
<p>　　包是一个分层次的目录结构，例如你要在A文件夹下有三个a1.py，a2.py，a3.py。这时可在A下创建<strong>init</strong>.py文件，然后再里面使用显示的导入语句，</p>
<p>　　import a1 from a1; import a2 from a2; import a3 from a3;  这样就导入A包的时候这些类就全都是可用的了，import A;  A.a1();这就是包的使用方法。</p>
<p><strong>文件I/O</strong></p>
<p>　　raw_input(提示) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）</p>
<p>　　input(提示) 函数和raw_input(提示) 函数基本可以互换，但是input会假设你的输入是一个有效的Python表达式，并返回运算结果。</p>
<p>　　open(filename,mode,buffering):打开一个文件</p>
<p>　　Write()方法可将任何字符串写入一个打开的文件，不在字符串的结尾不添加换行符(‘\n’)。</p>
<p>　　read（）方法从一个打开的文件中读取一个字符串。</p>
<p>　　Tell()方法告诉你文件内的当前位置；换句话说，下一次的读写会发生在文件开头这么多字节之后：</p>
<p>　　seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p>
<p><strong>面向对象</strong></p>
<p>　　在python中实现数据隐藏很简单，不需要在前面加什么关键字，只要把类变量名或成员函数前面加两个下划线即可实现数据隐藏的功能，这样，对于类的实例来说，其变量名和成员函数是不能使用的，对于其类的继承类来说，也是隐藏的，这样，其继承类可以定义其一模一样的变量名或成员函数名，而不会引起命名冲突。Python不允许实例化的类访问隐藏数据，但你可以使用object._className__attrName访问属性。</p>
<p>参考的都是网上资料</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个python记录的有点乱，都是在看电子档资料的时候，记录下来的。</p>
<p>1、学习Python与其他语言最大的区别就是，Python的代码块不使用大括号（{}）来控制类，函数以及其他逻辑判断。python最具特色的就是用缩进来写模块。</p>
<p>缩进的空白数量]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[公交wifi运营平台分析]]></title>
    <link href="http://silencewt.github.io/2015/01/17/%E5%85%AC%E4%BA%A4wifi%E8%BF%90%E8%90%A5%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90/"/>
    <id>http://silencewt.github.io/2015/01/17/公交wifi运营平台分析/</id>
    <published>2015-01-17T11:55:16.000Z</published>
    <updated>2015-01-17T11:55:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、前言背景">一、前言背景</h3>
<p>　　昨晚下午，老板让看一些车载公交wifi后台管理的一些东西，这个随着移动端设备而兴起的wifi战，慢慢的也会越演越烈。</p>
<p>　　现在于很多人在外面的时候，进入一家店首先看的不是菜单，而是问一句“你们的wifi密码是多少”？没有贴着“免费wifi”标签的店，估计都不会有人进去用餐，咖啡店，甜品店，餐厅，美发店……到处都可以看到免费wifi的字样，wifi已经成为标配了。随着移动端的兴起，微信营销的推广，对WiFi的需求也越来越多，这个可以说是生有体会，武汉某商圈的兴起就和wifi，微信脱不了关系。聚餐、活动总是可以看到大半以上的成员拿着手机再看。正是，对WiFi的需求的增加，让wifi营销成为关注点，除了固定地点，餐厅、美发店等，移动wifi也成为了热点，地铁wifi，公交wifi，渐渐地进入人们的生活。</p>
<p>　　2014年中国智能手机用户规模已达到5亿人，到2017年全球手机用户量预计增长至45.5亿。智能终端的全面普及和移动互联网的发展带来wifi接入需求迅速膨胀的同时，也带来基于移动通信与wifi应用创新的巨大市场机遇。现在智慧城市建设如火如荼，其中就有公交wifi热，公交wifi建设造价不低，而且后期流量使用巨大，产生的费用也是不少的，所以也不能全靠政府买单，自然就有了运营盈利这块。直接向用户收费一般都是不可取的，只能间接的，例如广告，通过广告商的投入来盈利。公交WiFi是指在公交车上实现WiFi。公交WiFi是政府部门及相关单位为了方便乘客出行、提高乘车体验，通过在公交车上安装无线网络设备，乘客只需通过移动终端即可实现无线互联的一种WiFi利用方式。</p>
<p>　　中国科学院发布的《中国新型城市化报告2012》中提到，在选取的中国百万人口以上的50个主要城市中，居民平均单行上班时间要花39分钟。而大部分上班族选用的上班交通工具均为公交车，而且途中都在使用手机、平板等上网浏览新闻、刷微博、上微信、听音乐、看视频等。</p>
<p>　　公共交通系统是市民出行的主要交通工具，为了提供给乘客更智能、更舒适、更便捷的乘车环境和相关设施，将无聊的上班时间变得有趣而且有用，结合目前已经日益成熟的无线信息系统，在载客运输的基本职能上给乘客带来更多有价值的增值服务。从受众的视听感受来看，音视频往往会更加形象、便于记忆，达到更及时准确的传播。未来，公交WiFi将作为智慧城市发展的一部分进入我们的生活，势必从一线省会城市向二三线城市普及和推广。</p>
<p>　　来自某调研公司的数据表明，国内公交WiFi供应商产品中，涉及到“广告推送”的大部分是由设备内部存储的内容来实现，其存储的内容若要更新，必须修改代码，无法实现直接覆盖，这样导致了设备内部的存储内容更新困难，且由于公交WiFi是通过一车一设备的方式实现的，因此采用这样的方式就要求终端客户需对每一台设备进行单独更新，如想要二次开发，依托终端用户的力量不足，而求助于供应商则需要消耗极大的人力物力。不仅如此，设备内的广告内容不能由后台统一推送，无法实现广告主动推送功能，则广告功效自然无从谈起。于是出现了一些新的，满足要求的wifi设备，其中属厦门才茂公司的车载公交wifi路由器最为成熟。</p>
<h3 id="二、wifi推送系统">二、wifi推送系统</h3>
<p>　　目前一些商家为了是用户能够快速的连上自家wifi，从一开始的密码设置到现在的直接连通，很多商家并没有多想到通过wifi来营销。商家还是有别于公交wifi，公交的盈利大部分来自于广告，那么如果公交上拥有了wifi，那么自然会考虑到如何从中获取盈利。目前存在以下几个方式：</p>
<p>　　第一，wifi广告认证就是用户使用商家提供的免费wifi网络时，会在上网登录页面看到商家的广告信息，看10-30秒广告即可上网。</p>
<p>　　第二，wifi微信认证的原理是用户接入无线网络，微信就可以上网了，用户根据商家认证页面提示启动微信，扫描商家的官方微信二维码关注商家微信，即可获得上网权限，商家通过免费的wifi服务获得了微信粉丝，为以后的营销做好了准备。</p>
<p>　　第三，wifi短信认证是通手机接收短信验证码获取上网权限，认证系统会留下用户的手机号码，为商家二次营销做好准备。</p>
<p>　   第四，wifi微博认证的形式和微信认证的形式相似，成为商家微博粉丝即可获得上网权限。</p>
<p>　　第五，wifi App下载就是让接入无线网络的用户下载App来获取上网权限。wifi营销更突出了商家与用户之间的互动，将商家的活动信息精确无误的传递给用户，让用户在享受免费wifi服务的同时，能够更清晰的了解商家信息，引起用户兴趣和关注度，进而选择二次消费。</p>
<h3 id="三、wifi系统组成">三、wifi系统组成</h3>
<h4 id="（一）网络架构">（一）网络架构</h4>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/wifi.jpg" alt="ｗｉｆｉ"></p>
<h4 id="（二）系统功能">（二）系统功能</h4>
<p>　　后台网管：后台网管是一个远程的WIFI设备集中管理系统，可实现设备的远程查询、远程配置、远程升级等功能，WIFI设备的运行并不依赖于网管，“后台网管”功能的加入将使WIFI设备的集中管理变得更加灵活，更加智能；</p>
<p>　　广告推送系统：广告推送子系统可用于发布公共信息，推送商业广告，广告页面可根据不同需求进行定制修改，广告推送方式多样灵活；</p>
<p>　　用户接入认证系统：用户接入认证子系统是一个用户注册、用户认证及用户计费/计时系统，该系统对用户接入Internet访问进行控制，用户只需打开web浏览器即可进行认证，提供多种接入认证方式，包括注册帐号、短信验证码方式，以及手机号黑白名单等方式，“接入认证系统”使运营者对用户接入Internet的控制变得可能；</p>
<p> 　   用户上网行为管理系统：上网行为管理系统可对用户访问Internet的内容进行管理/限制，同时也可记录用户访问的Internet内容，“上网行为管理”功能在流量控制及内容限制方面尤为突出。</p>
<p>　　各子系统的功能完整独立，可根据不同运营要求自由组合，如果只监控WIFI设备的运行状况，搭配“后台网管”即可；需要以广告推送方式来发布公共信息，可搭配“广告推送系统“；如果考虑用户接入的统计和控制，则要加上“接入认证系统”；对用户上网行为有要求的情况下，可加入“上网行为管理系统”；</p>
<p>　　商家购买该wifi路由之后，可以选择性的接入上述系统，拥有该系统的登入账号，并对其进行管理。可以选择B/S，或者C/S系统。对于公交车而言，可以根据移动设备联网的手机号情况，熟悉有哪些用户是经常乘坐哪一路的公交，可以针对的性的对其进行相应的广告推送。</p>
<p>　　这个系统比较重要的就是每个登入用户数据的收集，以及对数据的分析，进而有目的性的推送消息，以及流量的导入。</p>
<p>　　以下功能应该属于后台网管部分。主要是商家对路由器的控制和设置。</p>
<p>　　1、支持多种认证方式：</p>
<p>　　　　短信验证、WEB认证、微信认证、QQ认证、微博认证等方式</p>
<p>　　2、流量控制</p>
<p>　　带宽管理</p>
<p>　　流量控制策略，是通过为用户和应用指定“带宽通道对象”，让指定的用户和应用走指定的通道，实现对用户和应用的带宽上下限管理，例如限制迅雷、FTP的　　下载带宽等。</p>
<p>　　3、每用户控制</p>
<p>　　每用户控制，就是对每个用户进行控制，策略中无论是时长限额、流量限额还是带宽限制、连接数限制，针对的都是个体用户，而并非用户组，比如时长限　　　　制QQ使用1小时，表示用户组内每个用户使用QQ不能超过1小时，带宽控制中限制上传带宽为100kbps，指的是用户组内每个用户上传带宽最大值为100kbps……，　　通过每用户控制，可以使网络资源得到更加合理的应用。</p>
<p>　　每用户控制主要包含4个部分：</p>
<blockquote>
<p>带宽控制：限制每用户的上传、下载带宽；<br>连接控制：限制每用户的并发连接数及每秒新建连接数；<br>时长限额：限制每用户使用网络应用的最大时长，超时长被阻塞；<br>流量限额：限制每用户使用网络应用的最大流量，超流量被阻塞；</p>
</blockquote>
<p>　　为保证每位乘客都可以较好的体验上网，对每个用户的流量是必须进行控制的，不然会出现某个用户使用了某个霸道的app，直接占用所有的带宽流量，那么就会影响到其他用户的无法联网。</p>
<p>　　4、带宽控制</p>
<p>　　通过带宽控制策略实现对目标组织结构中每个用户限制其上传和下载带宽，实现流量管控</p>
<p>　　5、用户管理</p>
<p>　　　　支持用户导入</p>
<p>　　　　IP导入</p>
<p>　　　　第三方数据导入</p>
<p>　　　　自定义</p>
<p>　　6、流量阈值</p>
<p>　　流量阈值功能即指当网口总流量超阈值时触发，除了可以通过声音或者邮件进行外，还可以通过弹屏方式显示具体的超阈值流量信息。</p>
<p>　　7、日志管理</p>
<p>　　日志记录了系统主要的操作和事件，以及系统的各项信息，辅助技术支持人员进行系统维护和故障诊断。日志管理中提供多种日志查询。</p>
<p>　　日志可以显示每个路由器的运行情况，不便于日常的维护和维修，及时的对无法联网的路由器进行维护。</p>
<p>　　以下功能是对应广告商的管理：</p>
<p>　　1、及时跟新广告内容，针对性的对每条线路公交推送相应的广告内容。</p>
<p>　　2、对用户实行流量的导入，获得用户的点击量和浏览量。记录用户的上网行为并对其进行管理，用户上线下线的管理，使用wifi时长的记录和次数，以图表的形式清　　晰的展现出来，便于进行分析。如哪种形式的广告更能够吸引用户点击，哪种标语的出现可以增加用户的浏览时间？某条公交线路上的用户对哪一商圈的信息比较关　　注？某条线路上的用户对哪一个方面会比较感兴趣，一般在什么时间段会关注使用公交上的wifi？……等等，通过对这些数据的收集和分析，有便于公交寻找相对应的　　广告投放，增加盈利。</p>
<p>　　3、后台可以根据不同，对广告页面推送进行多元化管理，对广告商的综合管理，每个广告的方式、时长，出现的次数，图片和信息的更新等等。</p>
<p>　　这个部分重点就在于对广告的管理和用户信息的采集。</p>
<h3 id="四、公交wifi难点">四、公交wifi难点</h3>
<h4 id="（一）网速">（一）网速</h4>
<p>　　公交wifi是移动场景下的，使用的是运营商无线信号，和固定场景下使用的有线宽带wifi是不同的。无线信号的资源是有限的，而有线宽带的资源却是接近无限的。所以，前者的上网体验肯定比不上后者。对于用户来说，用公交wifi上网同用手机流量上网来比，信号会更好。随着运营商的努力，随着4G时代的到来，无线信号越来越好了。那么用户在公交车上的体验也会越来越好。其实技术是成熟的，主要看基础设施的发展。</p>
<h4 id="（二）wifi盈利模式探索">（二）wifi盈利模式探索</h4>
<p>　　wifi战就是数据战服务商探索盈利模式。目前，刚起步的公交wifi也处在烧钱阶段。公交免费wifi前期投入还是蛮大的，公交免费wifi的成本中，硬件成本主要是车载路由器，然后是日常维护和向运营商购买流量的成本。支持3G网络的车载路由价格在2000元左右，而支持4G网络的路由在3000元左右。再加上人工等成本，笼统地计算，一辆公交车硬件成本为4000多元。这里并每月有加上向运营商购买的流量费。</p>
<p>目前现有的盈利模式：</p>
<p>　　第一种是卖广告，这也是比较成熟的盈利模式之一。这种模式虽然是盈利最直接的一种模式，但无疑也最影响用户体验的。公交wifi模式下，所提供的所有视频、音乐、读书等内容不能够实时，用户自由选择性也不强，只能通过广告弹窗的方式让用户获得信息。</p>
<p>　　第二种应用分发，把流量变现，比如在wifi开放平台上承载各种应用，然后把流量导到微信公众号、支付宝钱包等，在用户登录wifi的时候推荐能用于下次自动登录的应用程序，这个App能作为应用市场，给用户分发有刚性需求的应用和游戏。</p>
<p>　　第三种以网换网，用移动互联网模式来思考，采用‘以网换网’O2O模式，通过社交游戏实现变现，比如，在公交车上，乘客可以在享受热门游戏或者使用一些热门移动应用上网服务的同时，换取免费使用公交WiFi的流量。</p>
<h3 id="五、总结">五、总结</h3>
<p>　　公交wifi，说到底就是一种数据之战，但却建立在良好的网络基础上，配合硬件和网络的使用，根据获得的数据针对性的推送消息，这个如果能很好的实现，所获得的价值是很可观的。公交是一个庞大的交通链，城市的主动脉，若能解决上述问题，使公交wifi得以很好的利用，将又是移动互联网的一次应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、前言背景">一、前言背景</h3>
<p>　　昨晚下午，老板让看一些车载公交wifi后台管理的一些东西，这个随着移动端设备而兴起的wifi战，慢慢的也会越演越烈。</p>
<p>　　现在于很多人在外面的时候，进入一家店首先看的不是菜单，而是问一句“你们的wif]]>
    </summary>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[testNG小试牛刀]]></title>
    <link href="http://silencewt.github.io/2015/01/12/testNG%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://silencewt.github.io/2015/01/12/testNG小试牛刀/</id>
    <published>2015-01-12T13:28:22.000Z</published>
    <updated>2015-01-12T13:37:18.000Z</updated>
    <content type="html"><![CDATA[<p>　　testNG是一个测试框架，其灵感来自JUnit和NUnit的，但引入了一些新的功能，使其功能更强大，使用更方便。</p>
<p>　　testNG是一个开源自动化测试框架；testNG表示下一代。 testNG是类似于JUnit（特别是JUnit 4），但它不是一个JUnit扩展。它的灵感来源于JUnit。它的目的是优于JUnit的，尤其是当测试集成的类。 testNG的创造者是Cedric Beust（塞德里克·博伊斯特）</p>
<p>　　testNG消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。 因为它在很大程度上借鉴了Java注解annotation（JDK5.0引入的）来定义的测试，它也可以告诉你如何使用这个新功能在真实的Java语言生产环境中。</p>
<h3 id="testNG的特点：">testNG的特点：</h3>
<ul>
<li>注解</li>
<li>testNG使用Java和面向对象的功能</li>
<li>支持综合类测试（例如，默认情况下，没有必要创建一个新的测试每个测试方法的类的实例）</li>
<li>独立的编译时间测试代码运行时配置/数据信息</li>
<li>灵活的运行时配置</li>
<li>主要介绍“测试组”。当编译测试，只要问testNG运行所有的“前端”的测试，或“快”，“慢”，“数据库”等</li>
<li>支持依赖测试方法，并行测试，负载测试，局部故障</li>
<li>灵活的插件API</li>
<li>支持多线程测试</li>
</ul>
<hr>
<p>　　testNG.xml文件记录了一些非常简单的术语。xml是一个以XML记录所有测试的文件口这个文件能够很容易地在一个文件中描述所有测试套件和它们的参数，可以将它签人到代码库中，或通过电子邮件发送给其他组员。也可以很容易地提取测试的子集，或分成几种运行时配置。这个文件并不是运行testNG所必须的。</p>
<p>　　</p>
<blockquote>
<p>一个suite(套件)由一个或多个测试组成。</p>
<p>一个test(测试)由一个或多个类组成。</p>
<p>一个class(类)由一个或多个方法组成。</p>
</blockquote>
<hr>
<p><strong>testNG相对于junit的一些优点</strong>：</p>
<p>　　1. testNG是一个设计用来简化广泛的测试需求的测试框架，从单元测试到集成测试这个是testNG设计的出发点，不仅仅是单元测试，而且可以用于集成测试。设计目标的不同，对比junit的只适合用于单元测试，testNG无疑走的更远。可以用于集成测试，这个特性是我选择testNG的最重要的原因。</p>
<p>　　2. 测试的过程的三个典型步骤，注意和junit(4.0)相比，多了一个将测试信息添加到testng.xml文件或者build.xml测试信息尤其是测试数据不再写死在测试代码中，好处就是修改测试数据时不需要修改代码/编译了，从而有助于将测试人员引入单元测试/集成测试。</p>
<p>　　3. 基本概念，相比junit的TestCase/TestSuite，TestNG有suite/test/test method三个级别，即将test/test method明确区分开了。</p>
<hr>
<h3 id="基本使用：">基本使用：</h3>
<p><strong>1、异常处理</strong></p>
<p>　　testNG可以简单方便的检测异常的发生，通过@ExpectedExceptions标注预期捕获的异常，当确实发生预期的异常，testNG认为测试通过。也可以指定标注多个异常。</p>
<p><strong>2、失败处理</strong><br>　　当testNG运行的case有失败的时候，会在test-output目录下生成一个testng-failed.xml文件，这对于批量执行测试定位问题很有帮助，testng可以单独执行这些失败的测试。</p>
<p><strong>3、使用参数</strong></p>
<p>　　testNG传参数的两种方式（xml文件，@DataProvider）</p>
<p><strong>使用testng.xml设置参数</strong></p>
<p> 　　参数在xml文件中可以在suite级别定义，也可以在test级别定义；testNG会尝试先在包含当前类的test标签中寻找参数，如果没找到则在上层的suite标签中查找。即在test标签中相同的参数对当前类当前方法的优先级比较高。 testNG支持这种传参方式的类型如下：String、 int/Integer、boolean/Boolean、 byte/Byte、 char/Character、 double/Double、 float/Float、 long/Long、 short/Short。对于非上述类型TestNG无法通过这种方式进行传参，可以通过@DataProvider方式传参</p>
<p> <strong>DataProvider方式传参</strong></p>
<p>　　只提供了一个字符串属性：名称，供测试方法作为传递参数的annotation使用两种DataProvider，一种是返回一个二维数组对象，如上面的例子；另外一种DataProvider是返回一个Iterator，DataProvider可以向测试方法传递任意类型任意数目的参数，利用DataProvider提供不同的参数集合对一个测试方法进行多次调用。</p>
<p><strong>4、Annotation</strong></p>
<p>　　快速预览，这些可以在官方的文档上找到更详细的资料。</p>
<p>　</p>
<blockquote>
<p>@BeforeSuite:        被注释的方法将在所有测试运行前运行 　　<br>@AfterSuite:    　被注释的方法将在所有测试运行后运行<br>@BeforeTest: 　被注释的方法将在测试运行前运行 　　<br>@AfterTest: 　被注释的方法将在测试运行后运行 　　<br>@BeforeGroups:       被配置的方法将在列表中的gourp前运行。这个方法保证在第一个属于这些组的测试方法调用前立即执行。<br>@AfterGroups:     被配置的方法将在列表中的gourp后运行。这个方法保证在最后一个属于这些组的测试方法调用后立即执行。 　　<br>@BeforeClass:    被注释的方法将在当前类的第一个测试方法调用前运行。 　　<br>@AfterClass:       被注释的方法将在当前类的所有测试方法调用后运行<br>@BeforeMethod:        被注释的方法将在每一个测试方法调用前运行。<br>@AfterMethod:        被注释的方法将在每一个测试方法调用后运行。</p>
</blockquote>
<p><strong>5、分组</strong></p>
<p>　　testNG的annotation有分组的功能，这些分组的名称和编号完全由我们自己来决定。@Test（groups={“fast”,”database”}）定义了分组之后可以在排除或者运行某个组。testNG容许执行复杂的测试方法分组。不仅可以申明方法属于组，而且可以指定分组包含其他分组。然后TestNG可以被调用，并被要求包含某些分组和排除其他的分组。这将提供怎样划分测试的最大弹性，并且如果想运行两个不同的测试装置不需要重新编译。</p>
<p><strong>6、依赖</strong></p>
<p>　　有些时候，需要测试方法按照一个特定的顺序被调用。这非常有用，比如：
　　</p>
<ul>
<li><p>在运行更多测试方法前确认特定数量的测试方法调用完成并且成功</p>
</li>
<li><p>初始化测试并希望这个初始化方法也作为测试方法（被标记为@Before/After的方法将不作为最终报告的一部分）</p>
</li>
</ul>
<p>为了做到这点，需要使用@Test注解的dependsOnMethods属性或者dependsOnGroups属性。</p>
<p>这里有两种依赖：</p>
<ul>
<li>强依赖。在运行你的测试方法前所有依赖方法必须运行并且成功。哪怕有一个依赖方法失败，测试方法都不会被调用，在报告中将被标记为SKIP。</li>
<li>软依赖。测试方法在依赖方法运行后总是会被运行，即使某些依赖方法失败。对于只想确认测试方法是按照特定顺序运行，而测试方法并不真正依赖其他方法是否成功的情况下非常有用。软依赖通过在@Test注解中增加”alwaysRun=true”来实现。</li>
</ul>
<hr>
<p>　　除了上面基本的使用之外还有，testNG在并发测试、异步测试和多线程测试方面的应用等等。</p>
<p>关于testng的使用可以参考官方文档：<a href="http://testng.org/doc/documentation-main.html" target="_blank" rel="external">http://testng.org/doc/documentation-main.html</a></p>
<p>这是看了《java测试新技术—testng》这本书的一点记录，虽没有全部理解，但是对于很多部分还是了解理解了。知道有这么个东西。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　testNG是一个测试框架，其灵感来自JUnit和NUnit的，但引入了一些新的功能，使其功能更强大，使用更方便。</p>
<p>　　testNG是一个开源自动化测试框架；testNG表示下一代。 testNG是类似于JUnit（特别是JUnit 4），但它不是一个JU]]>
    </summary>
    
      <category term="testNG" scheme="http://silencewt.github.io/tags/testNG/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(三)--web模块]]></title>
    <link href="http://silencewt.github.io/2015/01/12/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%B8%89-web%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/12/maven小项目注册服务-三-web模块/</id>
    <published>2015-01-12T02:29:10.000Z</published>
    <updated>2015-01-12T03:26:01.000Z</updated>
    <content type="html"><![CDATA[<p>　　java的web应用打包方式一般为war它和jar的区别就是包含了更多的资源和文件，如JSP文件，静态资源文件，servlet等等。war包的核心就WEB-INF文件夹下必须有一个web.xml 的配置文件，子目录classes包含所有该项目的类，子目录lib包含所有的依赖，这两个目录都会在运行的时候添加到classpath下。</p>
<p>　　maven对于web项目有统一的格式。项目代码和资源还是放在src/main/java和src/main/resources下，web资源目录在src/main/webapp/。webapp下就包含WEB-INF，css, js, jsp,等等文件夹。</p>
<p>　　这里account-service模块是综合之前三个模块，提供总的服务，直接看代码。</p>
<h3 id="service模块：">service模块：</h3>
<p> SignUpRequest对应表单的信息：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> SignUpRequest {
<span class="keyword">private</span> String id;

<span class="keyword">private</span> String email;

<span class="keyword">private</span> String name;

<span class="keyword">private</span> String password;

<span class="keyword">private</span> String confirmPassword;

<span class="keyword">private</span> String captchaKey;

<span class="keyword">private</span> String captchaValue;

<span class="keyword">private</span> String activateServiceUrl;

<span class="keyword">public</span> String <span class="title">getId</span>() {
    <span class="keyword">return</span> id;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span>(String id) {
    <span class="keyword">this</span>.id = id;
}

<span class="keyword">public</span> String <span class="title">getEmail</span>() {
    <span class="keyword">return</span> email;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span>(String email) {
    <span class="keyword">this</span>.email = email;
}

<span class="keyword">public</span> String <span class="title">getName</span>() {
    <span class="keyword">return</span> name;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
    <span class="keyword">this</span>.name = name;
}

<span class="keyword">public</span> String <span class="title">getPassword</span>() {
    <span class="keyword">return</span> password;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span>(String password) {
    <span class="keyword">this</span>.password = password;
}

<span class="keyword">public</span> String <span class="title">getConfirmPassword</span>() {
    <span class="keyword">return</span> confirmPassword;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfirmPassword</span>(String confirmPassword) {
    <span class="keyword">this</span>.confirmPassword = confirmPassword;
}

<span class="keyword">public</span> String <span class="title">getCaptchaKey</span>() {
    <span class="keyword">return</span> captchaKey;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaptchaKey</span>(String captchaKey) {
    <span class="keyword">this</span>.captchaKey = captchaKey;
}

<span class="keyword">public</span> String <span class="title">getCaptchaValue</span>() {
    <span class="keyword">return</span> captchaValue;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaptchaValue</span>(String captchaValue) {
    <span class="keyword">this</span>.captchaValue = captchaValue;
}

<span class="keyword">public</span> String <span class="title">getActivateServiceUrl</span>() {
    <span class="keyword">return</span> activateServiceUrl;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActivateServiceUrl</span>(String activateServiceUrl) {
    <span class="keyword">this</span>.activateServiceUrl = activateServiceUrl;
}
}
</code></pre><p>　　<br>接口实现：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>{
String generateCaptchaKey() <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">byte</span>[] generateCaptchaImage(String captchaKey)
    <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> signUp(SignUpRequest signUpRequest) <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> activate(String activationNumber) <span class="keyword">throws</span> AccountServiceException;
<span class="keyword">void</span> login(String id, String password) <span class="keyword">throws</span> AccountServiceException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>{
<span class="keyword">private</span> AccountPersistService accountPersist;
<span class="keyword">private</span> AccountEmailService accountEmail;
<span class="keyword">private</span> AccountCaptchaService accountCaptcha;
<span class="keyword">private</span> Map&lt;String, String&gt; activationMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();

<span class="keyword">public</span> AccountPersistService <span class="title">getAccountPersist</span>() {
    <span class="keyword">return</span> accountPersist;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountPersist</span>(AccountPersistService accountPersist) {
    <span class="keyword">this</span>.accountPersist = accountPersist;
}
<span class="keyword">public</span> AccountEmailService <span class="title">getAccountEmail</span>() {
    <span class="keyword">return</span> accountEmail;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountEmail</span>(AccountEmailService accountEmail) {
    <span class="keyword">this</span>.accountEmail = accountEmail;
}
<span class="keyword">public</span> AccountCaptchaService <span class="title">getAccountCaptcha</span>() {
    <span class="keyword">return</span> accountCaptcha;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountCaptcha</span>(AccountCaptchaService accountCaptcha) {
    <span class="keyword">this</span>.accountCaptcha = accountCaptcha;
}
<span class="keyword">public</span> String <span class="title">generateCaptchaKey</span>() <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> accountCaptcha.generateCaptchaKey();
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to generate captcha key"</span>,e);
    }

}
<span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">generateCaptchaImage</span>(String captchaKey)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        <span class="keyword">return</span> accountCaptcha.generateCaptchaImage(captchaKey);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to generate captcha image"</span>,e);
    }

}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signUp</span>(SignUpRequest signUpRequest)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> 
    {
        <span class="keyword">if</span> (!signUpRequest.getPassword().equals(signUpRequest.getConfirmPassword())) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"password donnot match"</span>);
        }

        <span class="keyword">if</span> (!accountCaptcha.validateCaptcha(signUpRequest.getCaptchaKey(), 
                signUpRequest.getCaptchaValue())) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captcha not match"</span>);
        }
        Account account = <span class="keyword">new</span> Account();
        account.setId(signUpRequest.getId());
        account.setEmail(signUpRequest.getEmail());
        account.setName(signUpRequest.getName());
        account.setPassword(signUpRequest.getPassword());
        account.setActivated(<span class="keyword">false</span>);

        accountPersist.createAccount(account);

        String activationId = RandomGenerator.getRandomString();
        activationMap.put(activationId, account.getId());
        String link = signUpRequest.getActivateServiceUrl().endsWith(<span class="string">"/"</span>) ? 
                signUpRequest.getActivateServiceUrl()+activationId : signUpRequest.getActivateServiceUrl()+
                <span class="string">"?key="</span>+activationId;
        accountEmail.sendMail(account.getEmail(), <span class="string">"please activate Your email"</span>, link);

    } <span class="keyword">catch</span> (AccountCaptchaException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to validate captcha"</span>, e);
    } <span class="keyword">catch</span> (AccountEmailException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to send email"</span>, e);
    } <span class="keyword">catch</span> (AccountPersistException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"unable to create account"</span>, e);
    }
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span>(String activationId)
        <span class="keyword">throws</span> AccountServiceException {
    String accountId = activationMap.get(activationId);

    <span class="keyword">if</span> (accountId == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"invalid account activated id"</span>);
    }
    <span class="keyword">try</span> {
        Account account = accountPersist.readAccount(accountId);
        account.setActivated(<span class="keyword">true</span>);
        accountPersist.updateAccount(account);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to activate"</span>);
    }

}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span>(String id, String password)
        <span class="keyword">throws</span> AccountServiceException {
    <span class="keyword">try</span> {
        Account account = accountPersist.readAccount(id);
        <span class="keyword">if</span> (account == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"account donnot exits"</span>);
        }
        <span class="keyword">if</span> (!account.isActivated()) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"account not activate"</span>);
        }
        <span class="keyword">if</span> (!account.getPassword().equals(password)) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"password is error"</span>);
        }
    } <span class="keyword">catch</span> (AccountPersistException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountServiceException(<span class="string">"Unable to logging"</span>, e);
    }
}
}
</code></pre><p>　　注意service的配置文件中pom必须将email、captcha、persist这三个模块包含进去，依赖关系：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-email<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-captcha<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.icegreen<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>greenmail<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${greenmail.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><hr>
<h3 id="account-web模块：">account-web模块：</h3>
<p>pom需要依赖servlet，service模块，其他的配置和一般的maven项目一样。</p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>${project.groupId}<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-service<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${project.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>

<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><p>  <br>web.xml：定义了一些servlet，具体的servlet实现代码在src/main/java 下。</p>
<pre><code><span class="tag">&lt;<span class="title">web-app</span>&gt;</span>
<span class="tag">&lt;<span class="title">display-name</span>&gt;</span>Sample Maven Project: Account Service<span class="tag">&lt;/<span class="title">display-name</span>&gt;</span>
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
<span class="tag">&lt;<span class="title">context-param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>
        classpath:/account-persist.xml
        classpath:/account-captcha.xml
        classpath:/account-email.xml
        classpath:/account-service.xml
    <span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">context-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>SignUpServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.SignUpServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ActivateServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.ActivateServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.hust.silence.account.web.LoginServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>CaptchaImageServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/captcha_image<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>SignUpServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/signup<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ActivateServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/activate<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
</code></pre><p><br>　　这个给出其中一个servlet的代码：对用户login的处理。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span>
<span class="keyword">extends</span> <span class="title">HttpServlet</span>
</span>{
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">929160785365121624</span>L;

<span class="keyword">private</span> ApplicationContext context;

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>()
    <span class="keyword">throws</span> ServletException
{
    <span class="keyword">super</span>.init();
    context = WebApplicationContextUtils.getWebApplicationContext( getServletContext() );
}

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span>( HttpServletRequest req, HttpServletResponse resp )
    <span class="keyword">throws</span> ServletException,
        IOException
{
    String id = req.getParameter( <span class="string">"id"</span> );
    String password = req.getParameter( <span class="string">"password"</span> );

    <span class="keyword">if</span> ( id == <span class="keyword">null</span> || id.length() == <span class="number">0</span> || password == <span class="keyword">null</span> || password.length() == <span class="number">0</span> )
    {
        resp.sendError( <span class="number">400</span>, <span class="string">"incomplete parameter"</span> );
        <span class="keyword">return</span>;
    }

    AccountService service = (AccountService) context.getBean( <span class="string">"accountService"</span> );

    <span class="keyword">try</span>
    {
        service.login( id, password );
        resp.getWriter().print( <span class="string">"Login Successful!"</span> );
    }
    <span class="keyword">catch</span> ( AccountServiceException e )
    {
        resp.sendError( <span class="number">400</span>, e.getMessage() );
    }
}
}
</code></pre><p>　　关于jsp界面只有两个：login.jsp和signup.jsp这个对于接触过web 的而言很简单了。</p>
<p>　　基本上这些内容大概就可以说明maven的好处和使用方法了，经过书上的讲解和自己的实际操练，对maven的使用会更加熟悉，当然自己用到的只是maven的皮毛，它的功能可 不仅仅只有这些，这些只是它的核心功能。如果能在实际项目中运用，并去学习的话会对maven有更深的了解，鉴于时间关系，我只能先了解个大概，之后若需要的时候能够快速的使用起来，也希望能在实验室项目中好好的使用这个工具。（有机会和时间的话，尝试重构实验室之前的web项目代码）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　java的web应用打包方式一般为war它和jar的区别就是包含了更多的资源和文件，如JSP文件，静态资源文件，servlet等等。war包的核心就WEB-INF文件夹下必须有一个web.xml 的配置文件，子目录classes包含所有该项目的类，子目录lib包含所有的]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用maven进行测试]]></title>
    <link href="http://silencewt.github.io/2015/01/12/%E7%94%A8maven%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/"/>
    <id>http://silencewt.github.io/2015/01/12/用maven进行测试/</id>
    <published>2015-01-12T02:26:31.000Z</published>
    <updated>2015-01-12T02:28:14.000Z</updated>
    <content type="html"><![CDATA[<p>　　maven的重要职责之一就是自动运行单元测试，它通过maven-surefire-plugin与主流的单元测试框架junit和testng集成，并且能够自动生成丰富的结果报表。</p>
<p>　　maven并不是一个单元测试框架，他只是在构建执行打特定的生命周期阶段的时候，通过插件来执行JUnit或testNG的测试用例，这个插件就是maven-surefire-plugin，也叫做测试运行器。maven-surefire-plugin会自动执行测试源码路劲下（src/test/java）的所有符合以下命名模式的测试用例
　　</p>
<blockquote>
<p>*<em>/Test</em>.java：任何子目录下的所有命名以Test开头的java类</p>
<p>　　*<em>/*</em>Test.java：任何子目录下的所有命名以Test结尾的java类</p>
<p>　　*<em>/*</em>TestCase.java：任何子目录下的所有命名以TestCase结尾的java类</p>
</blockquote>
<p>　　只要将测试类按上述模式命名，maven就能自动运行它们，用户也就不再需要定义测试集合（testsuite）来聚合测试用例了。</p>
<p>　　当然也可以自定义来包含一些不符合上述命名规则的测试类，以下定义以Tests结尾的用例：</p>
<pre><code><span class="variable">&lt;plugin&gt;</span>
  <span class="variable">&lt;groupId&gt;</span>org.apache.maven.plugin<span class="variable">&lt;/groupId&gt;</span>
  <span class="variable">&lt;artifactId&gt;</span>maven-surefire-plugin<span class="variable">&lt;/artifactId&gt;</span>
  <span class="variable">&lt;version&gt;</span>2.5<span class="variable">&lt;version&gt;</span>
  <span class="variable">&lt;configuration&gt;</span>
<span class="variable">&lt;includes&gt;</span>
   <span class="variable">&lt;include&gt;</span><span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>Tests.java<span class="variable">&lt;/include&gt;</span>
<span class="variable">&lt;/includes&gt;</span>
  <span class="variable">&lt;/configuration&gt;</span>
<span class="variable">&lt;/plugin&gt;</span>
</code></pre><p>　　日常工作中，软件开发人员总有很多理由来跳过单元测试，“我敢保证这次改动不会导致任何测试失败，测试运行太耗时了，暂时跳过一，有持续集成服务跑所有测试呢，我本地就不执行啦。在大部分情况下，这想法都是不对的。任何改动都要交给测试去验证，测试运行耗时过长应该考虑优化测试，更不要完全依赖持续集成服务来报告错误，测试错误应该尽早在尽小范围内发现，并及时修复。</p>
<p>　　maven同时也可以通过设置skipTest来跳过测试。</p>
<p><strong>测试报告</strong>：</p>
<p>　　surefire会在target-report下生成两种格式的错误与报告，简单文本格式和支持JUnit的XML格式。</p>
<p><strong>测试覆盖率报告</strong>：</p>
<p>　　cobertura是一个开源的测试覆盖率统计工具，使用时添加插件cobertura-maven-plugin</p>
<p><strong>testng</strong>：</p>
<p>　　可以使用testing.xml的文件，来配置想要运行的测试集合。然后再pom文件里在配置使用该文件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　maven的重要职责之一就是自动运行单元测试，它通过maven-surefire-plugin与主流的单元测试框架junit和testng集成，并且能够自动生成丰富的结果报表。</p>
<p>　　maven并不是一个单元测试框架，他只是在构建执行打特定的生命周期阶段的时]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(二)--captcha模块]]></title>
    <link href="http://silencewt.github.io/2015/01/12/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%BA%8C-captcha%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/12/maven小项目注册服务-二-captcha模块/</id>
    <published>2015-01-12T02:12:05.000Z</published>
    <updated>2015-01-12T02:15:58.000Z</updated>
    <content type="html"><![CDATA[<p>　　验证码生成模块，配置信息基本和前面的模块一样。account-captcha需要提供的服务是生成随机的验证码主键，然后用户可以使用这个主键要求服务生成一个验证码图片，这个图片对应的值应该是随机的，最后用户用肉眼读取图片的值，并将验证码的主键与这个值交给服务进行验证。这一服务对应的接口可以定义如下：</p>
<h3 id="具体代码：">具体代码：</h3>
<pre><code><span class="keyword">public</span> <span class="interface"><span class="keyword">interface</span> AccountCaptchaService </span>{
<span class="comment">//生成主见</span>
    <span class="built_in">String</span> generateCaptchaKey() throws AccountCaptchaException;
    byte[] generateCaptchaImage(<span class="built_in">String</span> captchaKey) throws AccountCaptchaException;
<span class="comment">//验证主键和值</span>
    <span class="built_in">boolean</span> validateCaptcha(<span class="built_in">String</span> captchaKey, <span class="built_in">String</span> captchaValue)throws AccountCaptchaException;
    List&lt;<span class="built_in">String</span>&gt; getPreDefinedTexts();
    <span class="built_in">void</span> setPreDefinedTexts(List&lt;<span class="built_in">String</span>&gt; preDefinedTexts);
}
</code></pre><p>　　额外定义的getPreDefinedText和set方法可以预定义验证码图片的值，提高程序的可预测性。</p>
<p> 　　为你了能够生成随机的验证码主键，定义一个类RandomGenerator如下：</p>
<pre><code>public class <span class="type">RandomGenerator</span> {

private <span class="keyword">static</span> <span class="type">String</span> rangeString = <span class="string">"0123456789qwertyuiopasdfghjklzxcvbnm"</span>;
public <span class="keyword">static</span> synchronized <span class="type">String</span> getRandomString(){
<span class="type">Random</span> random = new <span class="type">Random</span>();
<span class="type">StringBuffer</span> <span class="literal">result</span> = new <span class="type">StringBuffer</span>();
<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
    <span class="literal">result</span>.append(rangeString.charAt(random.nextInt(rangeString.length())));
}
<span class="keyword">return</span> <span class="literal">result</span>.toString();
}
}
</code></pre><p>　　该方法提供了一个线程安全且静态的方法，nextInt（）会放回一个大于等于0且小于n的整数。</p>
<h3 id="接口实现：">接口实现：</h3>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountCaptchaServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountCaptchaService</span>,<span class="title">InitializingBean</span> </span>{

    <span class="keyword">private</span> DefaultKaptcha producer;
    <span class="keyword">private</span> Map&lt;String,String&gt; captchaMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();
    <span class="keyword">private</span> List&lt;String&gt; preDefinedTexts;
    <span class="keyword">private</span> <span class="keyword">int</span> textCount = <span class="number">0</span>;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span>() <span class="keyword">throws</span> Exception {
        producer = <span class="keyword">new</span> DefaultKaptcha();
        producer.setConfig(<span class="keyword">new</span> Config(<span class="keyword">new</span> Properties()));
}

    <span class="keyword">public</span> String <span class="title">generateCaptchaKey</span>() <span class="keyword">throws</span> AccountCaptchaException {
        String key = RandomGenerator.getRandomString();
        String value = getCaptchaText();
        captchaMap.put(key, value);
        <span class="keyword">return</span> key;
    }

    <span class="keyword">private</span> String <span class="title">getCaptchaText</span>() {
        <span class="keyword">if</span>(preDefinedTexts != <span class="keyword">null</span> &amp;&amp; !preDefinedTexts.isEmpty()){
            String text = preDefinedTexts.get(textCount);
            textCount = (textCount+<span class="number">1</span>)%preDefinedTexts.size();
            <span class="keyword">return</span> text;
        }
        <span class="keyword">else</span> {
            <span class="keyword">return</span> producer.createText();
        }

    }

<span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">generateCaptchaImage</span>(String captchaKey)
        <span class="keyword">throws</span> AccountCaptchaException {
    String text = captchaMap.get(captchaKey);
    <span class="keyword">if</span> (text == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captaha key"</span>+captchaKey+<span class="string">"not found"</span>);
    }
    BufferedImage image = producer.createImage(text);
    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();
    <span class="keyword">try</span> {
        ImageIO.write(image,<span class="string">"jpg"</span> , out);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"failed to write image"</span>);
    }
    <span class="keyword">return</span> out.toByteArray();
}

<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateCaptcha</span>(String captchaKey, String captchaValue)
        <span class="keyword">throws</span> AccountCaptchaException {
    String text = captchaMap.get(captchaKey);
    <span class="keyword">if</span> (text == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountCaptchaException(<span class="string">"captaha key"</span>+captchaKey+<span class="string">"not found"</span>);
    }
    <span class="keyword">if</span> (text.equals(captchaValue)) {
        captchaMap.remove(captchaKey);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }<span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

}

<span class="keyword">public</span> List&lt;String&gt; <span class="title">getPreDefinedTexts</span>() {

    <span class="keyword">return</span> preDefinedTexts;
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPreDefinedTexts</span>(List&lt;String&gt; preDefinedTexts) {
    <span class="keyword">this</span>.preDefinedTexts = preDefinedTexts;

}

}
</code></pre><p>　　afterPropertiesSet会在framework初始化的时候调用，这个方法初始化验证码生成器，并提供默认配置。</p>
<p>   　generateCaptchaKey()首先生成一个随机的验证码主键，每个主键将和一个验证码字符串相关联，然后这组关联会被存储到中captchaMap以备将来验证。主键的目的仅仅是标识验证码图片，其本身没有实际的意义。getCaptchaText()用来生成验证码字符串，当preDefinedTexts存在或者为空的时候，就是用验证码图片生成器producer创建一个随机的字符串。当preDefinedTexts，不为空的时候，就顺序地循环该字符串列表读取值。preDefinedTexts有其对应的一组get和stet方法，这样就能让用户预定义验证码字符串的值。generateCaptchaImage方法就能通过producer来生成一个Bufferedlmage ,随后的代码将这个图片对象转换成jpg格式的字节数组并返回。有了该字节数组，用户就能随意地将其保存成文件，或者在网页上显示。</p>
<p>　　用户得到了验证码图片以及主键后。就会识别图片中所包含的字符串信息，然后将此验证码的值与主键一起反馈给 validateCaptcha方法以进行验证。</p>
<h3 id="测试代码：">测试代码：</h3>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountCaptchaServiceTest</span> </span>{
<span class="keyword">private</span> AccountCaptchaService service;
<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span>() <span class="keyword">throws</span> Exception{
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_captcha.xml"</span>);
    service = (AccountCaptchaService) ctx.getBean(<span class="string">"accountCaptchaService"</span>);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenerateCaptcha</span>() <span class="keyword">throws</span> Exception{
    String captchaKey = service.generateCaptchaKey();
    assertNotNull(captchaKey);

    <span class="keyword">byte</span>[] captchaImage = service.generateCaptchaImage(captchaKey);
    assertTrue(captchaImage.length&gt;<span class="number">0</span>);

    File image = <span class="keyword">new</span> File(<span class="string">"target"</span>+captchaKey +<span class="string">".jpg"</span>);
    OutputStream output = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        output = <span class="keyword">new</span> FileOutputStream(image);
        output.write(captchaImage);
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span> (output != <span class="keyword">null</span>) {
            output.close();
        }
    }
    assertTrue(image.exists() &amp;&amp; image.length()&gt;<span class="number">0</span>);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValidateCaptchaCorrect</span>() <span class="keyword">throws</span> Exception{
    List&lt;String&gt; preDefinedTexts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    preDefinedTexts.add(<span class="string">"12345"</span>);
    preDefinedTexts.add(<span class="string">"abcde"</span>);
    service.setPreDefinedTexts(preDefinedTexts);
    String captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertTrue(service.validateCaptcha(captchaKey, <span class="string">"12345"</span>));
    captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertTrue(service.validateCaptcha(captchaKey, <span class="string">"abcde"</span>));
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValidateCaptchaIncorrect</span>()
        <span class="keyword">throws</span> Exception
{
    List&lt;String&gt; preDefinedTexts = <span class="keyword">new</span> ArrayList&lt;String&gt;();
    preDefinedTexts.add(<span class="string">"12345"</span>);
    service.setPreDefinedTexts(preDefinedTexts);
    String captchaKey = service.generateCaptchaKey();
    service.generateCaptchaImage(captchaKey);
    assertFalse(service.validateCaptcha(captchaKey, <span class="string">"67809"</span>));
}
}
</code></pre><p>　　</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomGeneratorTest</span> </span>{
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetRandomTest</span>() <span class="keyword">throws</span> Exception{
    Set&lt;String&gt; randoms = <span class="keyword">new</span> HashSet&lt;String&gt;(<span class="number">100</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
        String random = RandomGenerator.getRandomString();
        assertFalse(randoms.contains(random));
        randoms.add(random);
    }

}
}
</code></pre><p>　　这个测试代码比较容易看懂。运行测试后可以在项目的target目录下看到生成的验证码图片。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　验证码生成模块，配置信息基本和前面的模块一样。account-captcha需要提供的服务是生成随机的验证码主键，然后用户可以使用这个主键要求服务生成一个验证码图片，这个图片对应的值应该是随机的，最后用户用肉眼读取图片的值，并将验证码的主键与这个值交给服务进行验证。这一]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小项目注册服务(一)--email和persist模块]]></title>
    <link href="http://silencewt.github.io/2015/01/11/maven%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1-%E4%B8%80-email%E5%92%8Cpersist%E6%A8%A1%E5%9D%97/"/>
    <id>http://silencewt.github.io/2015/01/11/maven小项目注册服务-一-email和persist模块/</id>
    <published>2015-01-11T01:32:06.000Z</published>
    <updated>2015-01-11T01:38:29.000Z</updated>
    <content type="html"><![CDATA[<p>跟着书里的讲解，跟着做了一遍该项目：</p>
<p>首先明白注册账户的需求：</p>
<p>　　账号的lD和Email地址都可以用来唯一地标识某个用户，而显示名称则用来显示在页面下，方便浏览。注册的时候用户还需要输入两次密码，以确保没有输错，系统则需要负责检查ID和email的唯一性，验证两次输入的密码是否一致，验证码是由系统随机生成的只能由肉眼识别其内容的图片，若输入正确的验证码信息，系统则会进行检查，如果验证码错误。系统会生成并返回新的验证码。所有检查都没问题了，系统就会生成一个激活链接，并发送到用户的邮箱。单击激活链接后，账户就被激活了，这时账户注册完成，用户可以进行登录。对于一个账户注册服务，还需要考虑一些安全因素，例如，需要在服务器端密文地保存密码，检查密码的强弱程度，更进一步则需要考虑验证码的失效时间，激活链接的失效时间等等。</p>
<p><strong>需求用例</strong>：</p>
<p><strong>主要场景</strong>：</p>
<p>1、用户访问注册页面</p>
<p>2、系统随机生成验证码图片</p>
<p>3、用户输入ID、Email等注册信息</p>
<p>4、输入验证码</p>
<p>5、提交注册请求</p>
<p>6、系统检查验证码、检查ID的唯一性，检查邮箱是否已被注册、密码和确认密码是否一致</p>
<p>7、系统保存未激活的账户信息</p>
<p>8、系统生成激活连接，发送给用户邮箱</p>
<p>9、用户打开邮箱，访问激活链接</p>
<p>10、系统解析激活连接，激活相关用户</p>
<p>11、用户使用ID和密码登陆</p>
<p><strong>扩展场景：</strong></p>
<p>4a：用户无法看清验证码，请求重新生成    1、跳转到2</p>
<p>6a：系统检测到用户输入的验证码有误        1、提示验证码有错，2、跳转到2</p>
<p>6b：检测到 ID已被注册，邮箱，密码有误    1、提示错误信息，2、跳转到2</p>
<p>从上面可以看出该服务有几个接口：生成验证码图片、处理注册请求、激活账户以及处理登陆请求。</p>
<p><strong>接口结构：</strong></p>
<p>acountService类：<br>generateCaptchaKey()<br>generateCaptchaImage(captchakey:string)<br>signUp(signUpRequest:SignUpRequest)：接收对象，进行验证。如果验证正确。则创建一个末被激活的账户，同时在后台也需要发送一封带有激活链接的邮件。<br>activate(activationNumber:string)：方法接收一个激活码，查找时应的账户进行激活<br>login(id:string,password:string)<br>signUpRequest：包含用户的注册信息，表单信息：id、Email、displayName、password、comfirmpassword、captchaKey、captchaValue。<br>generateCaptchaKey()的简单解释就是验证码，每个captcha都需要有一个key ,根据这个key ,系统才能得到对应的验证码图片以及实际值。因此，generateCaptchaImage会生成一个captchakey使用这个key再调用generateCaptchaImage方法就能得到验证码图片。验证码的key以及验证码图片被传送到客户端，用户通过肉眼识别再输人验证码的值，伴随着key再传送到服务器端验证，服务器端就可以通过这个key查到正确的验证码值，井与客户端传过来的值进行比对验证。</p>
<p><strong>模块划分：</strong></p>
<p>com.hust.silence.accout.service：系统的核心，它封装了所有下层细节，对外暴露简单的接日，这实际上是一个Facade模式。<br>com.hust.silence.accout.web：该模块包含所有与web相关的内容，包括jsp等，直接依赖于service模块<br>com.hust.silence.accout.persist：处理账户信息的持久化，包括增、删、改、查等，根据实现，可以基于数据库或者文件<br>com.hust.silence.accout.captcha：处理验证码的key生成、图片生成以及验证等<br>com.hust.silence.accout.email： 处理邮件服务的配置，激活邮件的编写和发送等</p>
<p><strong>配置pom.xml</strong><br>加入需要的各种spring framework的模块，Greenmail是开源的邮件服务套件，Javax.mail为实现发送的一个类库。从上面的信息我们可以知道，该项目时是com.hust.silence的一个account项目，项目里有一个模块为account-email。</p>
<hr>
<h4 id="实现Email模块："><strong>实现Email模块</strong>：</h4>
<p>account-email只有一个很简单的接口。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountEmailService</span> </span>{
        <span class="keyword">void</span> sendMail(String to, String subject, String htmlText) <span class="keyword">throws</span> AccountEmailException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountEmailService</span></span>{
<span class="keyword">private</span> JavaMailSender javaMailSender;
<span class="keyword">private</span> String systemEmail;

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span>(String to, String subject, String htmlText)
        <span class="keyword">throws</span> AccountEmailException {
    <span class="comment">// TODO Auto-generated method stub</span>
    <span class="keyword">try</span> {
        MimeMessage msg = javaMailSender.createMimeMessage();
        MimeMessageHelper msgHelper = <span class="keyword">new</span> MimeMessageHelper(msg);
        msgHelper.setFrom(systemEmail);
        msgHelper.setTo(to);
        msgHelper.setSubject(subject);
        msgHelper.setText(htmlText);
        javaMailSender.send(msg);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="comment">// TODO: handle exception</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountEmailException(<span class="string">"fail to send mail"</span>,e);
    }
}
<span class="comment">//实现依赖注入</span>
<span class="keyword">public</span> JavaMailSender <span class="title">getJavaMailSender</span>(){
    <span class="keyword">return</span> javaMailSender;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJavaMailSender</span>(JavaMailSender javaMailSender){
    <span class="keyword">this</span>.javaMailSender = javaMailSender;
}
<span class="keyword">public</span> String <span class="title">getSystemEmail</span>(){
    <span class="keyword">return</span> systemEmail;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystememail</span>(String systemEmail){
    <span class="keyword">this</span>.systemEmail = systemEmail;
}
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>{
<span class="javadoc">/**
 *
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6514881539290222459</span>L;
<span class="keyword">public</span> <span class="title">AccountEmailException</span>(String message) {
    <span class="keyword">super</span>(message);
}
<span class="keyword">public</span> <span class="title">AccountEmailException</span>(String message, Throwable throwable){
    <span class="keyword">super</span>(message, throwable);
}
}
</code></pre><p><strong>配置文件</strong>：<br><strong>id=”propertyConfigurer”</strong>：这是springframework用来帮助载入properties文件的组件，代码中表示从classpath的根目录下载入名为account-email.properties文件中的属性。<br><strong>id=”javaMailSender”</strong>：定义邮件服务器的一些配置.包括协议、端口、主机，用户名、密码，是否需要认证等属性。这段配置还使用了propertyConfigurer的属性引用，比如host的值为$ { email.host }。之前定义的propertyConfigurer作用就在于此、可以将邮件服务器相关的配置分离到外部的properties文件中，比如可以定义这样一个properties文件。配置javaMailSender使用163：</p>
<p>account-email.properties（在src/test/resources文件夹里）：<br>email.protocol=smtp<br>email.host=smtp.163.com<br>email.port=25<br>email.username=test@163.com<br>email.password=password<br>email.auth=true<br>email.systemEmail=test@163.com</p>
<p><strong>测试</strong>：</p>
<p>只需要测试一个sendMail（）接口，这个就需要准备properties文件，配置并启用一个测试使用的邮件服务器，准备好后，就调用该接口实现邮件发送，然后检查是否发送成功，关闭测试邮件服务器。具体代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountEmailServiceTest</span> </span>{
<span class="keyword">private</span> GreenMail greenMail;

<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMailServer</span>() <span class="keyword">throws</span> Exception{
    greenMail = <span class="keyword">new</span> GreenMail(ServerSetup.SMTP);
    greenMail.setUser(<span class="string">"1219611916@qq.com"</span>, <span class="string">"silence"</span>);
    greenMail.start();
}

<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMail</span>() <span class="keyword">throws</span> Exception{
    <span class="comment">//根据account。xml创建一个spring framework的ApplicationContext</span>
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_email.xml"</span>);
    <span class="comment">//从ctx中获取需要测试的ID为accountEmailService的bean并转换成AccountEmailService接口，</span>
    <span class="comment">//针对接口的测试是最好的单元测试的实现</span>
    AccountEmailService accout = (AccountEmailService)ctx.getBean(<span class="string">"accountEmailService"</span>);
    String subject = <span class="string">"Test Subject"</span>;
    String htmlText = <span class="string">"&lt;h3&gt;test&lt;/h3&gt;"</span>;
    accout.sendMail(<span class="string">"1219611916@qq.com"</span>, subject, htmlText);
    greenMail.waitForIncomingEmail(<span class="number">2000</span>, <span class="number">1</span>);
    Message[] mags = greenMail.getReceivedMessages();
    assertEquals(<span class="number">1</span>,mags.length);
    assertEquals(subject, mags[<span class="number">0</span>].getSubject());
    assertEquals(htmlText, GreenMailUtil.getBody(mags[<span class="number">0</span>]).trim());
}

<span class="annotation">@After</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMailServer</span>() <span class="keyword">throws</span> Exception{
    greenMail.stop();
}
}
</code></pre><hr>
<h4 id="实现persist模块：">实现persist模块：</h4>
<p>该模块负责账户数据的持久化，以XML文件的形式保存账户数据，井支持账户的创建、读取、更新、删除等操作。</p>
<p>配置代码：</p>
<pre><code>  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.hust.silence.account<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
 <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">name</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="title">url</span>&gt;</span>

  <span class="tag">&lt;<span class="title">properties</span>&gt;</span>
<span class="tag">&lt;<span class="title">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="title">project.build.sourceEncoding</span>&gt;</span>
<span class="tag">&lt;<span class="title">dom4j.version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">dom4j.version</span>&gt;</span>
<span class="tag">&lt;<span class="title">springframework.version</span>&gt;</span>2.5.6<span class="tag">&lt;/<span class="title">springframework.version</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">properties</span>&gt;</span>

  <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">test</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${dom4j.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>${springframework.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>

  <span class="tag">&lt;<span class="title">build</span>&gt;</span>
<span class="tag">&lt;<span class="title">testResources</span>&gt;</span>
    <span class="tag">&lt;<span class="title">testResource</span>&gt;</span>
        <span class="tag">&lt;<span class="title">directory</span>&gt;</span>src/test/resources<span class="tag">&lt;/<span class="title">directory</span>&gt;</span>
        <span class="tag">&lt;<span class="title">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="title">filtering</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">testResource</span>&gt;</span>
<span class="tag">&lt;/<span class="title">testResources</span>&gt;</span>
<span class="tag">&lt;<span class="title">plugins</span>&gt;</span>
    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
            <span class="tag">&lt;<span class="title">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="title">encoding</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span>
<span class="tag">&lt;/<span class="title">plugins</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">build</span>&gt;</span>
<span class="tag">&lt;/<span class="title">project</span>&gt;</span> 　
</code></pre><p>dom4j是支持XML操作的，build元素包含testresource是开启资源过滤的，在单元测试中用到。</p>
<p>具体代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountPersistService</span> </span>{
Account createAccount(Account account) <span class="keyword">throws</span> AccountPersistException;
Account readAccount(String id) <span class="keyword">throws</span> AccountPersistException;
Account updateAccount(Account account) <span class="keyword">throws</span> AccountPersistException;
<span class="keyword">void</span> deleteAccount(String id) <span class="keyword">throws</span> AccountPersistException;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountPersistServiceImpl</span>
<span class="keyword">implements</span> <span class="title">AccountPersistService</span>
</span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ROOT = <span class="string">"account-persist"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNTS = <span class="string">"accounts"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT = <span class="string">"account"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_ID = <span class="string">"id"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_NAME = <span class="string">"name"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_EMAIL = <span class="string">"email"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_PASSWORD = <span class="string">"password"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT_ACCOUNT_ACTIVATED = <span class="string">"activated"</span>;

    <span class="keyword">private</span> String file;

    <span class="keyword">private</span> SAXReader reader = <span class="keyword">new</span> SAXReader();

    <span class="keyword">public</span> String <span class="title">getFile</span>()
    {
        <span class="keyword">return</span> file;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFile</span>( String file )
    {
        <span class="keyword">this</span>.file = file;
    }

    <span class="keyword">public</span> Account <span class="title">createAccount</span>( Account account )
        <span class="keyword">throws</span> AccountPersistException
    {
        Document doc = readDocument();

        Element accountsEle = doc.getRootElement().element(ELEMENT_ACCOUNTS);

        accountsEle.add( buildAccountElement( account ) );

        writeDocument( doc );

        <span class="keyword">return</span> account;
    }

<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span>( String id )
    <span class="keyword">throws</span> AccountPersistException
{
    Document doc = readDocument();

    Element accountsEle = doc.getRootElement().element( ELEMENT_ACCOUNTS );

    <span class="keyword">for</span> ( Element accountEle : (List&lt;Element&gt;) accountsEle.elements() )
    {
        <span class="keyword">if</span> ( accountEle.elementText( ELEMENT_ACCOUNT_ID ).equals( id ) )
        {
            accountEle.detach();

            writeDocument( doc );

            <span class="keyword">return</span>;
        }
    }
}

<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
<span class="keyword">public</span> Account <span class="title">readAccount</span>( String id )
    <span class="keyword">throws</span> AccountPersistException
{
    Document doc = readDocument();

    Element accountsEle = doc.getRootElement().element( ELEMENT_ACCOUNTS );

    <span class="keyword">for</span> ( Element accountEle : (List&lt;Element&gt;) accountsEle.elements() )
    {
        <span class="keyword">if</span> ( accountEle.elementText( ELEMENT_ACCOUNT_ID ).equals( id ) )
        {
            <span class="keyword">return</span> buildAccount( accountEle );
        }
    }

    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">public</span> Account <span class="title">updateAccount</span>( Account account )
    <span class="keyword">throws</span> AccountPersistException
{
    <span class="keyword">if</span> ( readAccount( account.getId() ) != <span class="keyword">null</span> )
    {
        deleteAccount( account.getId() );

        <span class="keyword">return</span> createAccount ( account );
    }

    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">private</span> Account <span class="title">buildAccount</span>( Element element )
{
    Account account = <span class="keyword">new</span> Account();

    account.setId( element.elementText( ELEMENT_ACCOUNT_ID ) );
    account.setName( element.elementText( ELEMENT_ACCOUNT_NAME ) );
    account.setEmail( element.elementText( ELEMENT_ACCOUNT_EMAIL ) );
    account.setPassword( element.elementText( ELEMENT_ACCOUNT_PASSWORD ) );
    account.setActivated( ( <span class="string">"true"</span>.equals( element.elementText( ELEMENT_ACCOUNT_ACTIVATED ) ) ? <span class="keyword">true</span> : <span class="keyword">false</span> ) );

    <span class="keyword">return</span> account;
}

<span class="keyword">private</span> Element <span class="title">buildAccountElement</span>( Account account )
{
    Element element = DocumentFactory.getInstance().createElement( ELEMENT_ACCOUNT );

    element.addElement( ELEMENT_ACCOUNT_ID ).setText( account.getId() );
    element.addElement( ELEMENT_ACCOUNT_NAME ).setText( account.getName() );
    element.addElement( ELEMENT_ACCOUNT_EMAIL ).setText( account.getEmail() );
    element.addElement( ELEMENT_ACCOUNT_PASSWORD ).setText( account.getPassword() );
    element.addElement( ELEMENT_ACCOUNT_ACTIVATED ).setText( account.isActivated() ? <span class="string">"true"</span> : <span class="string">"false"</span> );

    <span class="keyword">return</span> element;
}

<span class="keyword">private</span> Document <span class="title">readDocument</span>()
    <span class="keyword">throws</span> AccountPersistException
{
    File dataFile = <span class="keyword">new</span> File( file );

    <span class="keyword">if</span>( !dataFile.exists() )
    {
        dataFile.getParentFile().mkdirs();

        Document doc = DocumentFactory.getInstance().createDocument();

        Element rootEle = doc.addElement( ELEMENT_ROOT );

        rootEle.addElement( ELEMENT_ACCOUNTS );

        writeDocument( doc );
    }

    <span class="keyword">try</span>
    {
        <span class="keyword">return</span> reader.read( <span class="keyword">new</span> File( file ) );
    }
    <span class="keyword">catch</span> ( DocumentException e )
    {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to read persist data xml"</span>, e );
    }
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeDocument</span>( Document doc )
    <span class="keyword">throws</span> AccountPersistException
{
    Writer out = <span class="keyword">null</span>;

    <span class="keyword">try</span>
    {
        out = <span class="keyword">new</span> OutputStreamWriter( <span class="keyword">new</span> FileOutputStream( file ), <span class="string">"utf-8"</span> );

        XMLWriter writer = <span class="keyword">new</span> XMLWriter( out, OutputFormat.createPrettyPrint() );

        writer.write( doc );
    }
    <span class="keyword">catch</span> ( IOException e )
    {
        <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to write persist data xml"</span>, e );
    }
    <span class="keyword">finally</span>
    {
        <span class="keyword">try</span>
        {
            <span class="keyword">if</span> ( out != <span class="keyword">null</span>)
            {
                out.close();
            }
        }
        <span class="keyword">catch</span> ( IOException e )
        {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountPersistException( <span class="string">"Unable to close persist data xml writer"</span>, e );
        }
    }
}
}
</code></pre><p>Account是一个简单的类：对变量的读取和设置</p>
<p>private String id;<br>private String name;<br>private String email;<br>private String password;<br>private boolean activated;　</p>
<p>　　该测试用例遵守了测试接口而不测试实现这一原则:也就是说，测试代码不能引用实现类，由于测试是从接口用户的角度编写的，这样就能保证接口的用户无须知晓接口的实现细节，既保证了代码的解藕，也促进了代码的设计。</p>
<p> 测试代码：这里只给出了读取readAccount的test</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountPersistServiceTest</span> </span>{
<span class="keyword">private</span> AccountPersistService service;
<span class="annotation">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span>() <span class="keyword">throws</span> Exception{
    File persistDataFile = <span class="keyword">new</span> File(<span class="string">"target/persist-classes/persist_data.xml"</span>);
    <span class="keyword">if</span>(persistDataFile.exists()){
        persistDataFile.delete();
    }
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"account_persist.xml"</span>);
    service = (AccountPersistService) ctx.getBean(<span class="string">"accountPersistService"</span>);
    Account account = <span class="keyword">new</span> Account();
    account.setId(<span class="string">"ww"</span>);
    account.setName(<span class="string">"wwss"</span>);
    account.setEmail(<span class="string">"16@qq.com"</span>);
    account.setPassword(<span class="string">"####"</span>);
    account.setActivated(<span class="keyword">true</span>);
    service.createAccount(account);
}
<span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadAccount</span>() <span class="keyword">throws</span> Exception{
    Account account = service.readAccount(<span class="string">"ww"</span>);
    assertEquals(<span class="string">"ww"</span>,account.getId());
    assertEquals(<span class="string">"wwss"</span>,account.getName());
    assertEquals(<span class="string">"126@qq.com"</span>,account.getEmail());
    assertEquals(<span class="string">"####"</span>,account.getPassword());
    assertTrue(account.isActivated());
}
}
</code></pre><p>　　想要将上面的代码单个模块运行成功，还需要给出相应的配置文件，xml文件放在src/main/resources下，properties文件放在src/test/resources。尤其是这里只给出了相应的两个模块的代码，有兴趣的可以继续写完成。<br>account_email.properties:<br>email.protocol=smtp<br>email.host=”127.0.0.1”<br>email.port=”25”<br>email.username=16@qq.com<br>email.password=####<br>email.auth=true<br>email.systemEmail=16@qq.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>跟着书里的讲解，跟着做了一遍该项目：</p>
<p>首先明白注册账户的需求：</p>
<p>　　账号的lD和Email地址都可以用来唯一地标识某个用户，而显示名称则用来显示在页面下，方便浏览。注册的时候用户还需要输入两次密码，以确保没有输错，系统则需要负责检查ID和emai]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014图灵技术图书最受欢迎TOP15]]></title>
    <link href="http://silencewt.github.io/2015/01/09/2014%E5%9B%BE%E7%81%B5%E6%8A%80%E6%9C%AF%E5%9B%BE%E4%B9%A6%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8ETOP15/"/>
    <id>http://silencewt.github.io/2015/01/09/2014图灵技术图书最受欢迎TOP15/</id>
    <published>2015-01-09T01:12:34.000Z</published>
    <updated>2015-01-09T01:22:26.000Z</updated>
    <content type="html"><![CDATA[<p>来自：图灵社区昨晚给我发的邮件，感觉不错，和大家分享，mark下。</p>
<p>【小编语】 回首2014，感谢小伙伴们一路相随。让我们2015一起更快乐地玩耍。今天小编为大家盘点一下过去2014年表现最给力的技术图书，它们受到了小伙伴们的一致认可。大家一起阅读下吧~</p>
<p><strong>1、Python基础教程（第2版·修订版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook1.jpg" alt="tulin1"></p>
<p>Python入门第一书</p>
<p>全面详尽，10个项目引人入胜</p>
<p><strong>2、iOS开发指南：从零基础到App Store上架（第2版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook2.jpg" alt="图林2"></p>
<p>数百个项目案例 + 两个真实项目开发全过程</p>
<p>iOS开发者推荐图书，免费视频学习更轻松</p>
<p><strong>3、JavaScript高级程序设计（第3版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook3.jpg" alt="图林3"></p>
<p>JavaScript进阶首选</p>
<p>全能前端人员必读经典</p>
<p><strong>4、深入浅出Node.js</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook4.jpg" alt="图林4"></p>
<p>阿里巴巴一线Node开发者朴灵巨献</p>
<p>深度讲解Node.js</p>
<p><strong>5、啊哈！算法</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook5.jpg" alt="图林5"></p>
<p>萌系算法第一书</p>
<p>充满趣味和智慧，人人都能看懂</p>
<p><strong>6、机器学习实战</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook6.jpg" alt="图林6"></p>
<p>使用Python阐述机器学习第一书</p>
<p>实例经典，循序渐进</p>
<p><strong>7、CCNA学习指南：路由和交换认证（100-101，200-101，200-120）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook7.jpg" alt="图林7"></p>
<p>首屈一指的CCNA应试宝典</p>
<p>针对思科认证最新考纲编写</p>
<p><strong>8、Objective-C基础教程（第2版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook8.jpg" alt="图林8"></p>
<p>全面系统讲述Objective-C基础知识和面向对象编程</p>
<p>作者均为苹果顶级开发高手</p>
<p><strong>9、R语言实战</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook9.jpg" alt="图林9"> </p>
<p>全面详尽的R语言指南</p>
<p>畅销多年，广受好评</p>
<p><strong>10、Android编程权威指南</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook10.jpg" alt="图林10"><br>原版亚马逊Android畅销第一书</p>
<p>国际知名移动训练营Big Nerd Ranch出品</p>
<p><strong>11、第一行代码——Android</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook11.jpg" alt="图林11"></p>
<p>国内最受欢迎的Android入门书</p>
<p>CSDN超人气博主郭霖力作</p>
<p><strong>12、图解HTTP</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook12.jpg" alt="图林12"></p>
<p>最简单易读的HTTP入门书</p>
<p>涵盖基础知识、最新动向<br><strong>13、图解TCP/IP（第5版）</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook13.jpg" alt="图林13"></p>
<p>原版畅销36万册</p>
<p>TCP/IP圣经级教材<br><strong>14、大数据：互联网大规模数据挖掘与分布式处理</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook14.jpg" alt="图林14"></p>
<p>全球著名数据库技术专家力作</p>
<p>理论与实际算法实现并重</p>
<p><strong>15、Java性能优化权威指南</strong><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/tulinbook16.jpg" alt="图林15"></p>
<p>Java性能优化圣经</p>
<p>Java之父重磅推荐</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来自：图灵社区昨晚给我发的邮件，感觉不错，和大家分享，mark下。</p>
<p>【小编语】 回首2014，感谢小伙伴们一路相随。让我们2015一起更快乐地玩耍。今天小编为大家盘点一下过去2014年表现最给力的技术图书，它们受到了小伙伴们的一致认可。大家一起阅读下吧~</p]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔记" scheme="http://silencewt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven小试牛刀]]></title>
    <link href="http://silencewt.github.io/2015/01/09/maven%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>http://silencewt.github.io/2015/01/09/maven小试牛刀/</id>
    <published>2015-01-09T01:07:34.000Z</published>
    <updated>2015-01-09T01:27:43.000Z</updated>
    <content type="html"><![CDATA[<p>　　Maven是一个采用纯Java编写的开源项目管理工具。Maven采用了一种被称之为project object model (POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，构建，测试，发布，报告等等。目前Apache下绝大多数项目都已经采用Maven进行管理。而Maven本身还支持多种插件，可以方便更灵活的控制项目。
　　</p>
<hr>
<h3 id="构建">构建</h3>
<p>　　理解maven的第一步我们需要知道构建是什么？《maven实战》这本书里写的很清楚，早上我们会从代码库里签出最新的代码，然后进行单元测试，如果发现bug就会找同事一起解决，之后回到自己的工作上，编写单元测试或者产品代码，然后测试，午饭后可能会需要开个会，汇报工作进度，查看测试报告那么就需要用IDE使用相关的工具集成，生成报告给经理查看，也可能QA发来了几个bug,于是熟练地用IDE生成了一个WAR包，部署到Web容器下，启动容器。看到熟悉的界面了，遵循bug报告，一步步重现了bug。。。修改好bug，提交代码，通知QA，下班。就会发现，在一天的工作中，我们出了编写代码就是在编译，运行生成文档，打包和部署等烦琐且不起眼的工作上，这就是构建。如果手工这样做，那成本也太高了，于是有人用软件的方法让这一系列工作完全自动化，使得软件的构建可以像全自动流水线一样，只需要一条简单的命令，所有烦琐的步骤都能够自动完成，很快就能得到最终结果。</p>
<p>　　Maven的用途之一是服务于构建，它是一个异常强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。我们要做的是使用Maven配置好项目，然后输入简单的命令(如mvn clean install)，Maven会帮我们处理那些烦琐的任务。Maven是跨平台的，无论是在Windows上，还是在Linux或者Mac上，都可以使用同样的命令。maven 能最大化的消除重复的构建，我们不需要去定义繁琐的构建过程，只要在maven里配置好相关的信息就好。最简单的例子是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编写好测试用例，当我们运行构建的时候，这些测试便会自动运行。maven可以帮助标准化构建过程，有了Maven之后，所有项目的构建命令都是简单一致的，这极大地避免了不必要的学习成本，而且有利于促进项目团队的标准化。Maven作为一个构建工具，不仅能帮我们自动化构建，还能够抽象构建过程，提供构建任务实现；它跨平台，对外提供了一致的操作接口，这一切足以使它成为优秀的、流行的构建工具。</p>
<p>　　maven不仅仅是一个构建工具，他还是一个依赖管理工具和项目信息管理工具，它提供了中央仓库，可以帮我们自动的下载构件。比如在使用javaweb开发是，会用到各种的第三方的库或者框架，这些类库都可以通过依赖的方式注入到项目中，随着依赖的增多，版本的不一致，版本的兼容性，臃肿的问题就会出现。每次手工的解决这些问题会很烦躁，maven就提供了一个优秀的解决方案，它通过一个坐标系统准确地定位每一个构件（artifact），也就是通过一组坐标Maven能够找到任何一个Java类库（如jar文件）。Maven给这个类库世界引入了经纬，让它们变得有秩序，于是我们可以借助它来有序地管理依赖，轻松地解决那些繁杂的依赖问题。</p>
<p>　　Maven还能帮助我们管理原本分散在项目中各个角落的项目信息，包括项目描述、开发者列表、版本控制系统地址、许可证、缺陷管理系统地址等。这些微小的变化看起来很琐碎，并不起眼，但却在不知不觉中为我们节省了大量寻找信息的时间。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，我们还能够轻松获得项目文档、测试报告、静态分析报告、源码版本日志报告等非常具有价值的项目信息。</p>
<h4 id="maven与IDE的比较：">maven与IDE的比较：</h4>
<p>　　IDE虽然提高了编码的效率，但IDE依赖大量的手工操作。编译、测试、代码生成等工作都是相互独立的，很难一键完成所有工作。手工劳动往往意味着低效，意味着容易出错。</p>
<p>　　很难在项目中统一所有的IDE配置，每个人都有自己的喜好。也正是由于这个原因，一个在机器A上可以成功运行的任务，到了机器B的IDE中可能就会失败。</p>
<p>　　我们应该合理利用IDE，而不是过多地依赖它。对于构建这样的任务，在IDE中一次次地点击鼠标是愚蠢的行为。Maven是这方面的专家，而且主流IDE都集成了Maven，我们可以在IDE中方便地运行Maven执行构建。</p>
<h4 id="maven于ant的区别：">maven于ant的区别：</h4>
<p>　　ant意指“另一个整洁的工具”（Another Neat Tool），它最早用来构建著名的Tomcat。可以将Ant看成是一个Java版本的Make，也正因为使用了Java，Ant是跨平台的。此外，Ant使用XML定义构建脚本build.xml。Ant是没有依赖管理的，所以很长一段时间Ant用户都不得不手工管理依赖，现在可以借助Ivy管理依赖。而Maven内置了依赖管理。
　　</p>
<hr>
<h4 id="使用maven的情况：">使用maven的情况：</h4>
<p>　　比如你是一个小软件公司的程序员，他所在的公司要开发一个新的Web项目。经过协商，决定使用Spring、iBatis和Tapstry。jar包去哪里找呢？公司里估计没有人能把Spring、iBatis和Tapstry所使用的jar包一个不少地找出来。大家的做法是，先到Spring的站点上去找一个spring.with.dependencies，然后去iBatis的网站上把所有列出来的jar包下载下来，对Tapstry、Apache commons等执行同样的操作。项目还没有开始，WEB.INF/lib下已经有近百个jar包了，带版本号的、不带版本号的、有用的、没用的、相冲突的，怎一个“乱”字了得！  在项目开发过程中，不时地会发现版本错误和版本冲突问题，这时只能硬着头皮逐一解决。项目开发到一半，经理发现最终部署的应用的体积实在太大了，要求去掉一些没用的jar包，于是只能加班加点地一个个删…… 这时就会想，要是能有一个系统或者框架来管理这些依赖就好了， 这时maven就发挥到作用了。</p>
<p>　　<em>书籍看到这里，让我想起大四的时候进来实验室时的一个项目，就是基于SSH框架的某公司管理系统，当时，在搭建环境的时候就需要一天的时候（网络卡），到不同的网站去下不同的jar包，和安装不同的框架，期间出错了几次，为了避免在次出错自己就手动的备份了所有资料，单独列了一个清单，记录各个依赖的版本。现在回过头来看，如果当时师兄师姐使用这个来构建项目的话，会有多轻松啊。实验室所学到的东西确实是有限的，很多新技术没有跟不上社会的变化。</em></p>
<hr>
<h3 id="maven与极限编程">maven与极限编程</h3>
<p>　　maven能很好的使用极限编程XP的一些实践当中去测试驱动开发（TDD）。TDD强调测试先行，所有产品都应该由测试用例覆盖。而测试是Maven生命周期的最重要的组成部分之一，并且Maven有现成的成熟插件支持业界流行的测试框架，如JUnit和TestNG。</p>
<p>　　<strong>十分钟构建</strong>。十分钟构建强调我们能够随时快速地从源码构建出最终的产品。这正是Maven所擅长的，只需要一些配置，之后用一条简单的命令就能让Maven帮你清理、编译、测试、打包、部署，然后得到最终的产品。</p>
<p>　　<strong>持续集成（CI）</strong>。CI强调项目以很短的周期（如15分钟）集成最新的代码。实际上,CI的前提是源码管理系统和构建系统。</p>
<p>　　在传统的瀑布模型开发中，项目依次要经历需求开发、分析、设计、编码、测试和集成发布阶段。从设计和编码阶段开始，就可以使用Maven来建立项目的构建系统。在设计阶段，也完全可以针对设计开发测试用例，然后再编写代码来满足这些测试用例。然而，有了自动化构建系统，我们可以节省很多手动的测试时间。此外，尽早地使用构建系统集成团队的代码，对项目也是百利而无一害。最后，Maven还能帮助我们快速地发布项目。</p>
<hr>
<h3 id="maven安装：">maven安装：</h3>
<p>　　最新的eclipse中集成的是3.2.1的maven，为了和命令行一起使用，我在插件里面使用3.2.5的，本机上安装的也是3.2.5，这个只要在eclipse里面设置一下就好了。当然也可以设置回去的。
　　</p>
<hr>
<h3 id="maven使用">maven使用</h3>
<h4 id="（一）_生成pom">（一） 生成pom</h4>
<p> 　　pom.xml文件是maven对一个项目的核心配置，这个文件将包含你希望如何构建项目的大多数配置信息，用于描述项目如何构建，声明项目依赖，等等。虽然很难列出一张非常全面的表，但在此可先列出最普通的默认的生命周期阶段：</p>
<p>　　<strong>validate</strong>：验证工程是否正确，所有需要的资源是否可用。<br>　　<strong>compile</strong>：编译项目的源代码。<br>　　<strong>test</strong>：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。<br>　　<strong>Package</strong>：把已编译的代码打包成可发布的格式，比如jar。<br>　　<strong>integration-test</strong>：如有需要，将包处理和发布到一个能够进行集成测试的环境。<br>　　<strong>verify</strong>：运行所有检查，验证包是否有效且达到质量标准。<br>　　<strong>install</strong>：把包安装在本地的repository中，可以被其他工程作为依赖来使用。<br>　　<strong>Deploy</strong>：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。<br>　　<strong>clean</strong>：清除先前构建的artifacts（在maven中，把由项目生成的包都叫作artifact）。<br>　　<strong>site</strong>：为项目生成文档站点。</p>
<p>　　首先创建一个空文件夹，在改文件夹里新建一个文佳pom.xml，配置文件，具体内容为：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span>
     <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
           <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.silence<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">name</span>&gt;</span>Maven Hello World Project<span class="tag">&lt;/<span class="title">name</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">project</span>&gt;</span>  
</code></pre><p>　　第二行：project元素，这是pom.xml的根元素，声明pom相关的命名空间，这里面的属性可以让我们的IDE跟快速的编辑pom第一行：制定了该xml文档的版本和编码方式。<br>　　第六行：根元素下的第一个子元素modelVersion指定了当前POM模型的版本，对于Maven2及Maven 3来说，它只能是4.0.0。<br>　　第7行到9行是最重要的代码段，groupId，artifactId和version这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者war都是以基于这些基本的坐标进行区分的。<br>　　<br>　　<strong>groupId</strong>定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联，譬如你在googlecode上建立了一个名为myapp的项目，那么groupId就应该是com.googlecode.myapp，如果你的公司是mycom，有一个项目为myapp，那么groupId就应该是com.mycom.myapp。<br>　　<br>　　<strong>artifactId</strong>定义了当前Maven项目在组中唯一的ID，我们为这个Hello World项目定义artifactId为hello-world，本书其他章节代码会被分配其他的artifactId。而在前面的groupId为com.googlecode.myapp的例子中，你可能会为不同的子项目（模块）分配artifactId，如：myapp-util、myapp-domain、myapp-web等等。</p>
<p>　　<strong>version</strong>指定了Hello World项目当前的版本——1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。随着项目的发展，version会不断更新，如升级为1.0、1.1-SNAPSHOT、1.1、2.0等等。</p>
<p>　　第十行：name元素声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但我还是推荐为每个POM声明name，以方便信息交流。</p>
<h4 id="（二）编写主代码">（二）编写主代码</h4>
<p> 　　项目主代码和测试代码不同，项目的主代码会被打包到最终的构件中（比如jar），而测试代码只在运行测试时用到，不会被打包。默认情况下，Maven假设项目主代码位于src/main/java目录，我们遵循Maven的约定，创建该目录，然后在该目录下创建文件com/juvenxu/mvnbook/helloworld/HelloWorld.java，<br> 　　写好这个之后，可以回到项目根目录下，运行mvn clean compile就可以生成编译java文件，生成对应的class文件</p>
<h4 id="（三）测试代码">（三）测试代码</h4>
<p>　　Maven项目中默认的测试代码目录是src/test/java。com/juvenxu/mvnbook/helloworld/testHelloWorld.java要有测试代码得为Hello World项目添加一个JUnit依赖，即在pom.xml中添加<dependencies>元素；</dependencies></p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span> 
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</code></pre><p>　　</p>
<p>　　第6行：scope为依赖范围，若依赖范围为test则表示该依赖只对测试有效，换句话说，测试代码中的import JUnit代码是没有问题的，但是如果我们在主代码中用import JUnit代码，就会造成编译错误。如果不声明依赖范围，那么默认值就是compile，表示该依赖对主代码和测试代码都有效。有了这段声明，Maven就能够自动从中央仓库（<a href="http://repo1.maven.org/maven2/）里下载junit-4.7.jar。" target="_blank" rel="external">http://repo1.maven.org/maven2/）里下载junit-4.7.jar。</a></p>
<h4 id="（四）执行">（四）执行</h4>
<p>　　mvn clean compile、mvn clean test（测试）、mvn clean package（打包）、mvn clean install（安装）。执行test之前是会先执行compile的，执行package之前是会先执行test的，而类似地，install之前会执行package。</p>
<p> 　　命令行输入的是mvn clean test，而maven实际执行的可不止这两个任务，还有clean:clean、resources:resources、compiler:compile、resources:testResources以及compiler:testCompile。暂时我们需要了解的是，在Maven执行测试（test）之前，它会先自动执行项目主资源处理，主代码编译，测试资源处理，测试代码编译等工作，这是Maven生命周期的一个特性。</p>
<h4 id="（五）简单的原型Archetype">（五）简单的原型Archetype</h4>
<p>　　可以快速的生成项目骨架，避免每次都一个个的创建文件夹，可以执行mvn archetype:generate，也可以在eclipse中选择。当然也可以根据自己的需要开发使用自定义的archetype来快速生成项目骨架。</p>
<hr>
<h3 id="maven坐标">maven坐标</h3>
<p>　　为了能自动的解析任何一个java构件，maven就将他们用坐标唯一标识，坐标元素包括:groupId,artifactId,version,packaging,classifier，只要设置这几个元素就可以很轻松地从中央仓库那儿获得对应的构件。前三天上面有介绍过，这里说说packaging：定义maven的打包方式，一般为jar（默认），当然也可以是war行的，最终会生成war的文件。classifier：帮助定义构建输出的一些附属构件。如某项目的主构件是nexus-index-2.0.0.jar，可能还会有nexus-index-2.0.0-Javadoc.jar和nexus-index-2.0.0-sources.jar这样一些附属构件（java文档和源代码），这里javadoc和sources就是这两个附属构件的classifier,这样附属的构件也会有自己唯一的坐标。</p>
<hr>
<h3 id="maven依赖">maven依赖</h3>
<p>　　每个依赖包含的元素有：groupId、artifactId、version还有type：<br>　　<strong>scope</strong>：依赖范围。用来控制依赖与这三种classpath的关系（编译classpath、运行classpath、测试classpath），如果没有指定依赖范围则默认使用compile，在编译、运行和测试的时候都需要用到该依赖。test则只对测试classpath有效，在编译主代码和运行项目的时候不会包含进去。runtime运行时的依赖，对测试运行有效，在编译主代码时无效。其实，还有provided和system两种。</p>
<p>　　<strong>optional</strong>：标记依赖是否可选，比如项目A依赖于项目B，B依赖于X和Y（XY可选的），根基依赖传递性，ＸＹ会是A的传递性依赖，但是由于XY是可选的，那么依赖不会传递，XY对A不会有影响。也就是说XY只对B起作用，不会被传递，如果A中需要XY则需要显示的声明。这个并不推荐，最好的方式就是排除依赖。可以使用maven命令分析依赖关系：mvn dependency:analyze</p>
<p>　　<strong>exclusions</strong>：用来排除传递性依赖maven引人的传递性依赖机制。一方面大大简化和方便了依赖声明。另一方面，大部分情况下我们只需要关心项目的直接依赖是什么，而不用考虑这些直接依赖会引人什么传递性依赖。但有时候，当传递性依赖造成问题的时候，我们就需要清楚地知道该传递性依赖是从哪条依赖路径引人的。这个可以以后遇到了在了解。</p>
<hr>
<h4 id="依赖范围">依赖范围</h4>
<p>　　就是用来控制依赖与这三种classpath(编译classpath、测试classpath、运行classpath)的关系，Maven有以下几种依赖范围：</p>
<p>　　<strong>compile</strong>: 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。</p>
<p>　　<strong>test</strong>:测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子就是JUnit，它只有在编译测试代码及运行测试的时候才需要。</p>
<p>　　<strong>provided:</strong> 已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。</p>
<p>　　<strong>runtime:</strong> 运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</p>
<p>　　<strong>system:</strong> 系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量</p>
<hr>
<h3 id="maven仓库">maven仓库</h3>
<p>　　简单来说就是，maven依赖构件存放的地方，所有的依赖构件都从仓库里下载，除了本地的项目依赖。maven有提供一个中央仓库，里面有各种开源的构件，可很方便的从上面获得。当然，这个仓库是远程的，也可以在本地设置一个私服，Nexus就是一个流行的开源maven仓库管理软件。现在我只需要使用仓库里的就可以了，没必要去建立私服。此处略过。</p>
<hr>
<h3 id="maven生命周期和插件：">maven生命周期和插件：</h3>
<p> 　　maven的生命周期就是为了对所有的构建过程进行抽象和统一，从大量项目和构建工具中学习和反思，然后总结了一套高度完善的、易扩展的生命周期。这个生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。也就是说，几乎所有项目的构建，都能映射到这样一个生命周期上。</p>
<p> 　　在maven的设计中，实际的任务(如编译源代码)都交由插件来完成。这种思想与设计模式中的模板方法非常相似。模板方法模式在父类中定义算法的整体结构，子类可以通过实现或者重写父类的方法来控制实际的行为，这样既保证了算法有足够的可扩展性，又能够严格控制算法的整体结构。</p>
<p>　　这本书里写的很清楚：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> AbstractBuild{
<span class="keyword">public</span> <span class="keyword">void</span> Build（）{
    initialize（）；
    compile（）；
    test（）；
    packagee（）；
    integrate（）；
    deploy（）；
}
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> initialize（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> compile（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> test（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> packagee（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> integrate（）；
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> deploy（）；
}
</code></pre><p>　　生命周期抽象了构建的各个步骤，定义它们的次序，但没有提供具体实现，那么谁来实现这些步骤呢？不能有用户为了编译而写一堆代码。为测试又写一堆代码，那么就在重复发明轮子了?maven考虑了，因此设计插件机制。每个构建步骤都可以绑定一个或者多个插件行为，而maven为大多数构建步骤编写并绑定了默认插件。插件完成具体的任务，是实现着。maven有自动绑定的插件，当然也可以自定义绑定，在pom中设置build plugins plugin属性。 </p>
<p>　　maven有三套独立的生命周期：clean（清理项目）、default（构建项目）、site（建立项目站点）。每个生命周期都有几个阶段，这些阶段是有顺序的，调用后面的阶段时，必须先调用前面的阶段。我们从命令行执行maven命令就是在调用其生命周期阶段，比如：mvn clean：就是执行pre-clean和clean阶段。mvn test：执行default周期的validate、initialize……直到test阶段。mvn clean install：就是clean阶段加上default周期的直到install阶段。</p>
<hr>
<h3 id="maven聚合和继承">maven聚合和继承</h3>
<p>　　我们通常会将不一个项目分成不同的模块向，注册服务会分成persist，service等模块，maven的聚合特性能够把项日的各个模块聚合在一起构建，而maven继承特性则能帮助抽取各模块相同的依赖和插件等配置。在众多模块中，不可能对每个项目都进行构建，执行maven命令，会想用一个命令就运行几个模块的内容，为了能够一条命令就构建两个模块，需要在额外的创建一个account-aggregato模块，然后通过该模块构建整个项目的所有模块。对于聚合模块来说，pom.xml中的打包方式必须为pom,否则就无法构建。各个模块可以放在聚合模块目录下，即和pom同一个目录，聚合模块是项目目录的最顶层，其他莫快则作为其子目录存在。这个并不是唯一的，子模块也可以和聚合模块平行。</p>
<p>　　多模块项目中，各模块中会有很多相同的groupID和version，相同的spring依赖，和plugin配置。这就是重复，重复往往以为着更</p>
<p>　　更多的劳动和更多的潜在的问题。在面向对象世界中，程序员可以使用类继承在一定程度上消除重复，在maven的世界中，也有类似的机制能让我们抽取出重复的配置，这就是POM的继承。需要创建POM的斧子结构，然后在父POM中声明一些配置供子POM继承。以实现一处声明，多处使用的目的。</p>
<p>　　<strong>聚合的目的：快速构建项目</strong><br>　　<strong>继承的目的：消除重复配置</strong></p>
<hr>
<p>参考书籍：《maven实战》 <a href="http://hzbook.group.iteye.com/group/wiki/2872-Maven-in-action" target="_blank" rel="external">http://hzbook.group.iteye.com/group/wiki/2872-Maven-in-action</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　Maven是一个采用纯Java编写的开源项目管理工具。Maven采用了一种被称之为project object model (POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，]]>
    </summary>
    
      <category term="maven" scheme="http://silencewt.github.io/tags/maven/"/>
    
      <category term="软件测试" scheme="http://silencewt.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合文章系列汇总]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E6%96%87%E7%AB%A0%E7%B3%BB%E5%88%97%E6%B1%87%E6%80%BB/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合文章系列汇总/</id>
    <published>2014-12-30T06:41:27.000Z</published>
    <updated>2014-12-30T06:51:58.000Z</updated>
    <content type="html"><![CDATA[<p>　　这是实验室项目的资料汇总，一方面便于自己整理，理清思路，另一方面让大家对图像融合有个大概的了解。以后项目还没有完结，以后还会有所补充。</p>
<p>图像融合文章系列汇总：</p>
<p><a href="http://silencewt.github.io/2014/12/29/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E6%A6%82%E8%BF%B0/" target="_blank" rel="external">图像融合（一）— 概述</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E7%AE%80%E5%8D%95%E5%8A%A0%E6%9D%83%E8%9E%8D%E5%90%88/" target="_blank" rel="external">图像融合（二）— 简单加权融合</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（三）— 拉普拉斯金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%AF%B9%E6%AF%94%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（四）— 对比度金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89-%E6%A2%AF%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="external">图像融合（五）— 梯度金字塔</a></p>
<p><a href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89-%E5%B0%8F%E6%B3%A2%E8%9E%8D%E5%90%88/" target="_blank" rel="external">图像融合（六）— 小波融合</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这是实验室项目的资料汇总，一方面便于自己整理，理清思路，另一方面让大家对图像融合有个大概的了解。以后项目还没有完结，以后还会有所补充。</p>
<p>图像融合文章系列汇总：</p>
<p><a href="http://silencewt.github.io/2014/]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（六）-- 小波融合]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89-%E5%B0%8F%E6%B3%A2%E8%9E%8D%E5%90%88/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（六）-小波融合/</id>
    <published>2014-12-30T05:47:21.000Z</published>
    <updated>2014-12-30T06:35:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="基于小波的融合（wavelet）">基于小波的融合（wavelet）</h3>
<p>　　小波变换的固有特性使其在图像处理中有如下优点：完善的重构能力，保证信号在分解过程中没有信息损失和冗余信息；把图像分解成平均图像和细节图像的组合，分别代表了图像的不同结构，因此容易提取原始图像的结构信息和细节信息；小波分析提供了与人类视觉系统方向相吻合的选择性图像。</p>
<p>　　离散小波变换(Discrete Wavelet Transform, DWT)。DWT的函数基由一个称为母小波或分析小波的单一函数通过膨胀和平移获得。因而，DWT同时具有时域和频域分析能力，与一般的金字塔分解相比，DWT图像分解具有以下优势：</p>
<ol>
<li>具有方向性，在提取图像低频信息的同时，还可获得了水平、垂直和对角三个方向的高频信息；</li>
<li>通过合理的选择母小波，可使DWT在压缩噪声的同时更有效的提取纹理、边缘等显著信息；</li>
<li>金字塔分解各尺度之间具有信息的相关性，而DWT在不同尺度上具有更高的独立性。</li>
</ol>
<p>DWT融合算法基本思想与金字塔算法一致，即：首先对源图像进行小波变换，然后按照一定规则对变换系数进行合并；最后对合并后的系数进行小波逆变换得到融合图像。由于不具有移不变性，基于DWT的标准小波融合算法获取的融合图像通常会存在“振铃”干扰;特别在处理连续的图像序列时，融合结果会出现明显的闪烁和抖动现象。</p>
<h4 id="1、原理阐述">1、原理阐述</h4>
<p>　　（1）小波的简单计算原理</p>
<p>　　 [x0，x1，x2，x3]=[90，70，100，70] 为达到压缩 我们可取 (x0+x1)/2  (x0-x1)/2 来代表 x0,x1  这样 [90,70] 可表示为 [80,10] 80即平均数 10是小范围波动数（可想象出一种波的形状） [90,70] —〉[80,10] , [100,70] —〉 [85,15] 可以想象80 和85 都是局部的平均值反映大的总体的状态，是变化相对缓慢的值，可以认为他们是低频部分的值。 而10、15是小范围波动的值局部变换较快，可以认为他们是高频部分的值。</p>
<p>　　1、 FIRST：把[90,70,100,70] 写成 [80,85,10,15] 即把低频部分写在一起（记频率L） 高频部分写在一起（H) </p>
<p>　　2、 SECOND：而[80,85] 又可经同样的变换—&gt; [82.5, -2.5] 这样 82.5表示更低频的信息(记频率LL) -2.5则表示了频率L上的波动 </p>
<p>　　3、最后[90,70,100,70] —〉[82.5, -2.5, 10, 15] 这样信息就可被压缩了（数字范围小了）</p>
<p>　　现在再来扩展一下  [90,70]—-&gt; [80,10] 写成矩阵 [90,70] * [1/2, 1/2]<br>[1/2 ,-1/2] 矩阵[1,1；1,-1]/2为haar转换矩阵。</p>
<p>　　如果是[90,70,100,70]第一步就可以写成矩阵M1：[0.5,0,0.5,0; 0.5,0,-0.5,0; 0,0.5,0,0.5;0,0.5,0,-0.5]，第二步只对低频L操作，高频不变可写成M2：[1/2,  1/2, 0, 0; 1/2, -1/2, 0, 0; 0,  0,  1, 0 ;0,  0,  0, 1]。另M= M1<em>M2，可得到4</em>4的点阵操作。</p>
<p>　　第一步运算后原图像缩小至左边一半了，右边的是对应波动信息；</p>
<p>　　第二步运算后图像又缩小至左边一半了，对应波动信息。</p>
<p>　　对一幅图像先进行行变化，在进行列变化，那么就是小波变化了。</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.1.png" alt="wave1"></p>
<p>　　LL：水平低频，垂直低频</p>
<p>　　LH：水平低频，垂直高频</p>
<p>　　HL：水平高频，垂直低频</p>
<p>　　HH：水平高频，垂直高频</p>
<p>　　其中，L表示低频，H表示高频，下标1、2表示一级或二级分解。在每一分解层上，图像均被分解为LL，LH，HH和HL四个频带，下一层的分解仅对低频分量LL进行分解。这四个子图像中的每一个都是由原图与一个小波基函数的内积后，再经过在x和y方向都进行2倍的间隔采样而生成的。这是正变换，也就是图像的分解；逆变换，也就是图像的重建。是通过图像的增频采样和卷积来实现的。这里有个问题进过处理后，数据或超出255或者出现负数，需要将其归一化到0-255之间，方可显示图像。这里介绍的只是简单的小波计算，小波计算的而不同就在于选取不同的小波系数，一般有haar小波，sym2小波等。</p>
<p>资料：<a href="http://www.blogbus.com/shijuanfeng-logs/221385402.html" target="_blank" rel="external">http://www.blogbus.com/shijuanfeng-logs/221385402.html</a></p>
<h4 id="2、融合规则">2、融合规则</h4>
<p><strong>规则一</strong>：系数绝对值较大法</p>
<p>　　该融合规则适合高频成分比较丰富，亮度、对比度比较高的源图像，否则在融合图像中只保留一幅源图像的特征，其他的特征被覆盖。小波变换的实际作用是对信号解相关，并将信号的全部信息集中到一部分具有大幅值的小波系数中。这些大的小波系数含有的能量远比小系数含有的能量大，从而在信号的重构中，大的系数比小的系数更重要。</p>
<p><strong>规则二</strong>：加权平均法</p>
<p>　　权重系数可调，适用范围广，可消除部分噪声，源图像信息损失较少，但会造成图像对比度的下降，需要增强图像灰度。</p>
<p><strong>规则三</strong>：局部方差准则</p>
<p>　　设A(x,y)和B(x,y)分别为高频子图像数据值，F(x,y)为相应高频子图像融合值，将A(x,y)和B(x,y)分成若干个M×N子块图像。对每个子块图像进行数值分布统计，计算其方差。确定A和B图像每个子块图像加权系数K1和K2。如果A图像子块方差大于B图像子块方差,则K1≥K2，否则K1&lt;K2。确定每个子块图像的数据融合数值为：F(i,j)=K1A(i,j)+K2B(i,j)。</p>
<h4 id="3、融合应用">3、融合应用</h4>
<p>　　若对二维图像进行N层的小波分解,最终将有(3N+1)个高低频带，其中包含3N个高频带和一个低频带。图像融合的基本步骤如下。</p>
<p>　　1）对每一源图像分别进行小波分解，建立图像的小波金字塔分解。</p>
<p>　　2）对各分解层分别进行融合处理，采用不同的融合算子对各分解层的不同频率分量进行融合处理，最终得到融合后的小波金字塔。低频：加权平均，高频：绝对值取大。</p>
<p>　　3）对融合后所得的小波金字塔进行小波逆变换，所得到的重构图像即为融合后的图像。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.2.png" alt="wave2"></p>
<p>　　图像的低频部表现的是图像的概貌和平均特性；图像的高频反应的是图像的细节特性，如图像的边缘、区域边界等。</p>
<p>　　融合规则：</p>
<p>　　基于局部方差的融合规则：在邻域W中，图像I在以（i ，j)为中心点的局部方差定义：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.3.png" alt="wave3"></p>
<p>　　式中为图像I 的均值，M，N 分别为局部区域的行数和列数，这里取局部区域为3*3，基于局部方差的融合方式常用的方法是选择法，即通常说的局部方差取大法。方差选择法的融合规则<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.4.png" alt="wave4"></p>
<p>　　L为分解尺度， 表示图像小波系数，<img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.5.png" alt="wave5"> 表示图像小波系数， =d=H,V,D分别表示的是水平、垂直、对角高频分量。如果两幅图片直接使用局部方差法进行融合，局部方差相差较大时，采用局部方差取大法能够比较完整的存储图像的微小细节。一旦局部方差相差很小时，局部方差取大法会使图像细节失真。</p>
<p>　　图像融合有一个重要的目的，即将图像的边缘、细节等都包含到融合图像中。一种方法是将图像的边缘提取出来，将它应用到相应的融合算法中。图像边缘检测的最好的算子是 canny 算子，将canny算子和局部方差的融合规则的算法相结合，提出了一种新的改进融合方法。融合步骤如下：</p>
<p>　　（1）小波分解。对于图像 A，B 分别进行 3 层小波分解，得到低频分量AA、AB和高频分量DLH，DLV，DLD。</p>
<p>　　（2）低频融合。对低频分量AA 和AB 所有的像素点计算其局部方差Var(i ,j)AA和 Var(i ,j)BA，然后进行归一化：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.6.png" alt="wave6"></p>
<p>　　然后，利用归一化的局部方差，按照如下：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.7.png" alt="wave7"></p>
<p>　　（3）高频融合。在图像 A 和 B 的每一个高频分DLA，DLB中，对每一个高频分量用 canny 算子进行边缘提取，再对边缘图像的每一个元素计算局部方差：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.8.png" alt="wave8"></p>
<p>　　其中 <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.9.png" alt="wave9"><br>表示源图像的第l层经 canny 算子处理的高频系数 <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.10.png" alt="wave10">为源图像的第l层经 canny 算子提取后的均值。<img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.11.png" alt="wave11"> 是对源图像的第l层高频分量进行边缘提取后求得的局部方差。<br> <img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-wave1.12.png" alt="wave12"></p>
<p>　　（4）小波重构。对融合后的系数进行小波重构，得到融合后的图像。</p>
<p>　　附：这里介绍的小波是最简单的形式，融合规则也比较常用，很多红外和可见的融合也都用到了这里的规则，所以，实现这里面的算法来适用我们的应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="基于小波的融合（wavelet）">基于小波的融合（wavelet）</h3>
<p>　　小波变换的固有特性使其在图像处理中有如下优点：完善的重构能力，保证信号在分解过程中没有信息损失和冗余信息；把图像分解成平均图像和细节图像的组合，分别代表了图像的不同结构，因此]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（五）-- 梯度金字塔]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89-%E6%A2%AF%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（五）-梯度金字塔/</id>
    <published>2014-12-30T05:14:35.000Z</published>
    <updated>2014-12-30T05:34:53.000Z</updated>
    <content type="html"><![CDATA[<p>　　基于梯度金字塔(Gradient Pyramid,GP)分解的图像融合算法。GP 也是一种基于高斯金字塔的多尺度分解算法。通过对高斯金字塔每层图像进行梯度算子运算，便可获得图像的 GP表示。GP 每层分解图像都包含水平、垂直和两个对角线四个方向的细节信息，能更好地提取出图像的边缘信息，提高了稳定性和抗噪性。具有方向性的梯度塔形分解能够很好地提供图像的方向边缘和细节信息。</p>
<p>1、<strong>原理阐述</strong><br>（1）得到高斯金字塔（如上）</p>
<p>（2）对图像高斯金字塔的各分解层（最高层除外）分别进行梯度方向滤波，便可得到梯度塔形分解：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.1.png" alt="Gradius1"></p>
<p>　　这里•为卷积运算，DL K表示第L层第k方向梯度塔形图像，GL 为图像的高斯金字塔的第L层图像，dK表示第k方向梯度滤波算子，定义为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.2.png" alt="gradius2"></p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.3.png" alt="gradius3"></p>
<p>　　经过 d1、d2、d3、d4对高斯金字塔各层进行方向梯度滤波，在每一分解层上（最高层除外）均可得到包含水平、垂直以及两个对角线方向细节信息的4个分解图像。可见图像的梯度塔形分解不仅是多尺度、多分辨率分解，而且每一分解层（最高层除外）又由分别包含 4个方向细节信息的图像组成。</p>
<p>　　这里跟上面不同的就是每一层是独立的，不需要涉及到上一层的上采样结果。对应层的Gl与3*3的核做卷积，在加上Gl的值之后取相应方向的值，就可以生成对应方向的系数了。</p>
<p>   （3）重构</p>
<p>　　对金字塔图像每一层各方向分别融合后，就需要由梯度金字塔重构原图像，须引入FSD 拉普拉斯金字塔作为中间结果，即将梯度金字塔转换为拉普拉斯金字塔，再由拉普拉斯金字塔重构原图像，其构建过程如下：</p>
<p>　　1、将方向梯度金字塔转换为方向拉普拉斯金字塔（FSD型）filter-subtract-decimate。设 FSD型金字塔的第L层图像为LL，<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.4.png" alt="gradius4"></p>
<p>　　2、将FSD 拉普拉斯金字塔图像变换为拉普拉斯金字塔图像。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.5.png" alt="gradiu5"></p>
<p>　　注意I不是单位矩阵，只是中间一个元素为1。（不懂）</p>
<p>　　3、由拉普拉斯金字塔重构原图像将GL内插值进行放大，使放大后的图像尺寸与GL - 1的尺寸相同。这里就和前面的一样（pyrup）。</p>
<p>2、融合应用</p>
<p>　　采用基于区域的融合规则，基于区域的融合方法的基本思想是：在对某一分解层图像进行融合处理时，为了确定融合后图像的像素，不仅要考虑参加融合的源图像中对应的各像素，而且要考虑参加融合的像素的局部领域。即比较源图像的某方面特征，从而动态地选这方面特征突出的源图像组成融合结果。</p>
<p>　　梯度是一个矢量，指向边缘法线方向上取得局部的最大值的方向，和图像的边缘方向总 是正交（垂直）的。所以基于梯度的滤波器，又称边缘算子。图像经梯度滤波器滤波后，突出了相邻点间灰度级的变化，达到增强边缘的目的。以区域各点灰度值之和为特征量，进行源图像分解层的融合时，来自哪个区域的特征的值大，就将该区域中心像素点的灰度值作为融合后图像分解层上该位置的像素灰度值。这样就能很好的提取图像的边缘信息。<br>　　<img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-gp1.6.png" alt="gradius6"></p>
<p>2、<strong>融合的基本步骤</strong></p>
<p>2.1、对每一源图像分别进行梯度塔形分建立图像的梯度金字塔。</p>
<p>2.2、对图像梯度金字塔的各分解层分别进行融合处理；不同的分解层、不同方向细节图像采用不同的融合算子进行融合处理，最终得到融合后图像的梯度金字塔。</p>
<p>2.3、对融合后所得梯度金字塔进行逆塔形变换（即进行图像重构），所得到的重构图像即融合图像对于融合规则可以选用基于区域信息的，也可以简单的取最大值的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　基于梯度金字塔(Gradient Pyramid,GP)分解的图像融合算法。GP 也是一种基于高斯金字塔的多尺度分解算法。通过对高斯金字塔每层图像进行梯度算子运算，便可获得图像的 GP表示。GP 每层分解图像都包含水平、垂直和两个对角线四个方向的细节信息，能更好地提取出]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（四）-- 对比度金字塔]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%AF%B9%E6%AF%94%E5%BA%A6%E9%87%91%E5%AD%97%E5%A1%94/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（四）-对比度金字塔/</id>
    <published>2014-12-30T04:59:55.000Z</published>
    <updated>2014-12-30T05:10:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="对比度金字塔融合">对比度金字塔融合</h3>
<p>　　在考虑人类视觉系统对局部对比度敏感这一视觉特性的基础上，提出了基于对比度金字塔(Contrast Pyramid，CP)分解的图像融合算法。CP 分解类似于 LP 分解，但它的每一层图像是高斯金字塔相邻两层图像的比率。 CP 融合算法应用于合成孔径雷达和前视红外图像融合。</p>
<h4 id="1、原理阐述">1、原理阐述</h4>
<p>　　<strong>（1）得到高斯金字塔（如上篇）</strong></p>
<p>　　<strong>（2）对比度金字塔</strong></p>
<p>　　用高斯金字塔得到上采样并高斯卷积之后的预测图像<em>Gl，</em>Gl的尺寸和Cl-1相同，即经过放大算子的处理（pyrup）。图像的对比度通常定义为：C = (g -gb)/gb= g/gb-I，这里g为图象某位置处的灰度值、gb为该位置处的背景灰度值、I表示单位灰度值图像。因窗口函数w(m，n)具低通滤波特性，所以G*l+1可以看作是Gl的背景，故可定义图像的对比度金字塔为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-cp1.1.jpg" alt="contrast1"></p>
<p>　　就是0层的G0除以G1上采样的得到的*G1再减去1，得到的就是对比度金字塔。</p>
<p>　　<strong>（3）重构</strong><br>　　<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-cp1.2.png" alt="contrast2"></p>
<p>　　从对比度金字塔(CN、CN-1、、、C0)的顶层CN开始、依次令l = N、N-1、、、0逐层由上到下、可依次得到高斯金字塔的各层GN、GN-1、G0。最终精确重构原始图像（高斯金字塔的最底层G0即为原始图象）。</p>
<h4 id="2、融合应用">2、融合应用</h4>
<p>　　这里的应用和上面不同的就是融合规则的不同。</p>
<p>　　设A、B为两幅原始图像，F为融合后的图像。其融合的基本步骤如下：</p>
<p>　　1）对每一源图像分别进行对比度塔形分解，建立各图像的对比度金字塔；</p>
<p>　　2）对图像金字塔的各分解层分别进行融合处理，不同的分解层采用不同的融合算子进行融合处理，最终得到融合后图像的对比度金字塔；</p>
<p>　　3）对融合后所得对比度金字塔进行逆塔形变换（图像重构），所得到的重构图像即为融合图像。</p>
<p>　　其中<strong>一种融合规则</strong>为：采用像素取大的原则。因为对比度大的像素是图像中相对突出和比较重要的像素。即获得两个图像的对比度金字塔后，差值越大就代表处变化越大，存在明显的信息，那么对应的就取该处变化大的值，保留重要的变化信息。</p>
<p>　　<strong>另一种融合规则</strong>：基于区域特性量测的加权平均融合算子，该融合规则及融合算子的确定方法如下：</p>
<p>　　分别计算两幅图像相应分解层上对应局部区域的能量：ElA及ElB：<br>　　<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-cp1.3.png" alt="contrast3"></p>
<p>　　式中El(n,m)表示对比度金字塔第l层上，以(n,m)为中心位置的局部区域能量；Ll表示对比度金字塔的第l层图像；wl(n’ ,m’ )为与Ll对应的权系数；j、k定义了局部区域的大小(例如3<em>3、5</em>5或7*7等)；n’、m’的变化范围在j、k内。这里不知道w是怎么取值的。</p>
<p>　　这个算法有点麻烦，具体的见：<br>　　<a href="http://www.docin.com/p735309332.html" target="_blank" rel="external">http://www.docin.com/p735309332.html</a></p>
<hr>
<p><strong>基于对比度塔形分解的图像融合方法的物理意义在于</strong>：</p>
<p>1）对比度塔形分解将原始图像分别分解到具有不同分辨率、不同空间频率的一系列分解层上（从底层到顶层，空间频率依次降低），同时，每一分解层均反映了相应空间频率上图像的对比度信息。</p>
<p>2）融合过程是在各空间频率层上分别进行的，这样就可能针对不同分解层的不同频带上的特征与细节，采用不同的融合算子，以达到突出特定频带上特征与细节的目的。基于对比度塔形分解的图像融合恰恰是在不同的空间频带上进行融合处理的，因而可能获得与人的视觉特性更为接近的融合效果。</p>
<p>​</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="对比度金字塔融合">对比度金字塔融合</h3>
<p>　　在考虑人类视觉系统对局部对比度敏感这一视觉特性的基础上，提出了基于对比度金字塔(Contrast Pyramid，CP)分解的图像融合算法。CP 分解类似于 LP 分解，但它的每一层图像是高斯金字塔相邻两层]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（三）-- 拉普拉斯金字塔]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（三）-拉普拉斯金字塔/</id>
    <published>2014-12-30T03:23:08.000Z</published>
    <updated>2014-12-30T04:56:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="2、拉普拉斯金字塔融合">2、拉普拉斯金字塔融合</h3>
<p>　　图像金字塔方法的原理是：将参加融合的的每幅图像分解为多尺度的金字塔图像序列，将低分辨率的图像在上层，高分辨率的图像在下层，上层图像的大小为前一层图像大小的1/4。层数为0,1,2……N。将所有图像的金字塔在相应层上以一定的规则融合，就可得到合成金字塔，再将该合成金字塔按照金字塔生成的逆过程进行重构，得到融合金字塔。这个总的思路就是一下所有基于金字塔融合的算法过程，不同点就在于分解构造的金字塔不同，每层的融合规则不一样，重构的方法不同而已。金字塔方法最先实现了这种思想，之后小波方法进一步完善和发展了这种多尺度融和的思想。</p>
<h4 id="2-1、原理阐述">2.1、原理阐述</h4>
<h5 id="（1）高斯金字塔"><strong>（1）高斯金字塔</strong></h5>
<p>　　高斯金字塔是最基本的图像塔。首先将原图像作为最底层图像G0（高斯金字塔的第0层），利用高斯核（5*5）对其进行卷积，然后对卷积后的图像进行下采样（去除偶数行和列）得到上一层图像G1，将此图像作为输入，重复卷积和下采样操作得到更上一层图像，反复迭代多次，形成一个金字塔形的图像数据结构，即高斯金字塔。</p>
<p>高斯金字塔的构建过程为：假设高斯金字塔的第L层图像为Gl：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.1.jpg" alt="Laplacian1"></p>
<p>式中N为高斯金字塔顶层层号，Rl和Cl分别为高斯金字塔第l层的行数和列数W（m，n）是一个二维可分离的5*5窗口函数，表达式为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.2.jpg" alt="Laplace2"></p>
<p>　　由G0，G1，，，GN，就构成了一个高斯金字塔，其中G0为高斯金字塔的底层（与原图像相同）GN为金字塔的顶层。由此可见高斯金字塔的当前层图像就是对其前一层图像首先进行高斯低通滤波，然后再进行隔行和隔列的降2采样而生成的。前一层图像大小依次为当前层图像大小的4倍。</p>
<p>　　Opencv中使用pyrdown函数就可以获得高斯金字塔。</p>
<h5 id="（2）拉普拉斯金字塔"><strong>（2）拉普拉斯金字塔</strong></h5>
<p>　　在高斯金字塔的运算过程中，图像经过卷积和下采样操作会丢失部分高频细节信息。为描述这些高频信息，人们定义了拉普拉斯金字塔(Laplacian Pyramid， LP)。用高斯金字塔的每一层图像减去其上一层图像上采样并高斯卷积之后的预测图像，得到一系列的差值图像即为 LP 分解图像。</p>
<p>　　将Gl内插方法得到放大图像<em>Gl，使</em>Gl的尺寸与*Gl-1的尺寸相同，即放大算子Expand<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.3.jpg" alt="Laplace3"></p>
<p>　　该式子实现两个步骤：在偶数行和列插入0，然后使用下采样中的高斯核进行滤波处理，得到和l-1层一样大小的图像。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.4.jpg" alt="Laplace4"></p>
<p>　　N为拉普拉斯金字塔顶层的层号LPl是拉普拉斯金字塔分解的第L层图像。由LP0，LP1、LP2…LPN构成的金字塔即为拉普拉斯金字塔。它的每一层L0图像是高斯金字塔本层G0图像与其高一层图像G1经内插放大后图像*G1的差，此过程相当于带通滤波，因此拉普拉斯金字塔又称为带通金字塔分解。</p>
<p>　　内插方法：opencv中有实现的函数pyrup。可以得到*G1。然后在两个函数作差，相减就可以得到拉普拉斯金字塔。</p>
<p>　　求得每个图像的拉普拉斯金字塔后需要对相应层次的图像进行融合，具体的融合规则有，取大、取小，等等。</p>
<h5 id="（3）重构"><strong>（3）重构</strong></h5>
<p>　　对融合后的拉普拉斯金字塔，从其顶层开始逐层从上至下按下式进行递推，可以恢复其对应的高斯金字塔，并最终可得到原图像G0。就是从最高层开始使用内插的方法。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.5.jpg" alt="Laplace5"></p>
<h4 id="2-2、融合应用">2.2、融合应用</h4>
<p>　　图像拉普拉斯金字塔分解的目的是将源图像分别分解到不同的空间频带上，融合过程是在各空间频率层上分别进行的，这样就可以针对不同分解层的不同频带上的特征与细节，采用不同的融合算子以达到突出特定频带上特征与细节的目的。即有可能将来自不同图像的特征与细节融合在一起。</p>
<h5 id="（1）顶层处理"><strong>（1）顶层处理</strong></h5>
<p>　　设LAl和LBl分别为源图像A,B经过拉普拉斯金字塔分解后得到的第l层图像，融合后的结果为LFl。当l=N时，LAN和LBN分别为源图像A，B经过拉普拉斯金字塔分解后得到的顶层图像。对于顶层图像的融合，首先计算以其各个像素为中心的区域大小为M*N(M、N取奇数且M &gt;= 3、N &gt;= 3)的区域平均梯度：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.6.jpg" alt="Laplace6"></p>
<p>其中，Ix与Iy分别为像素f(x,y)在x与y方向上的一阶差分，定义如下：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.7.jpg" alt="Laplace7"></p>
<p>　　因此对于顶层图像中的每一个像素LAN(i, j)和LBN(i, j)都可以得到与之相对应的区域平均梯度GA(i, j)和GB(i, j)。由于平均梯度反映了图像中的微小细节反差和纹理变化特征，同时也反映出图像的清晰度。一般来说平均梯度越大，图像层次也丰富，则图像越清晰。因此顶层图像的融合结果为：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.8.jpg" alt="Laplace8"></p>
<h5 id="（2）各层次处理"><strong>（2）各层次处理</strong></h5>
<p>　　当0小于i小于N时，则对于经过拉普拉斯金字塔分解的第l层图像，首先计算其区域能量：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.9.jpg" alt="Laplace9"></p>
<p>则其他层次图像的融合结果为：</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/merge-lp1.10.jpg" alt="Laplace410"></p>
<p>在得到金字塔各个层次的融合图像LF1、LF2、LFN后。通过前面的重构，便可得到最终的融合图像。</p>
<p>　　第二种融合规则：</p>
<p>　　采用最高层系数取平均，其余各层系数绝对值取大的融合策略进行融合。融合后图像的系数（灰度值）越接近较清晰图像的灰度值就说明融合效果好。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="2、拉普拉斯金字塔融合">2、拉普拉斯金字塔融合</h3>
<p>　　图像金字塔方法的原理是：将参加融合的的每幅图像分解为多尺度的金字塔图像序列，将低分辨率的图像在上层，高分辨率的图像在下层，上层图像的大小为前一层图像大小的1/4。层数为0,1,2……N。将所有图]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（二）-- 简单加权融合]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E7%AE%80%E5%8D%95%E5%8A%A0%E6%9D%83%E8%9E%8D%E5%90%88/"/>
    <id>http://silencewt.github.io/2014/12/30/图像融合（一）-简单加权融合/</id>
    <published>2014-12-30T03:06:13.000Z</published>
    <updated>2014-12-30T03:09:43.000Z</updated>
    <content type="html"><![CDATA[<p>简单加权融合也叫做<strong>像素加权平均法</strong>（Weighted Averaging，WA）是最简单、直接的图像融合方法。它具有简单易实现、运算速度快的优点，并能提高融合图像的信噪比，但是这种方法削弱了图像中的细节信息，降低了图像的对比度，在一定程度上使得图像中的边缘变模糊，在多数应用场合难以取得满意的融合效果。</p>
<p>　　优化：<strong>主成分分析</strong>(Principal Component Analysis，PCA)就是一种常用的系数优化方法，利用主成分分析确定的权值可以得到一幅亮度方差最大的融合图像。PCA方法运用于高分辨率全色图像与低分辨率多光谱图像的融合时，通过用高分辨率全色图像替代由低分辨率多光谱图像提取出的第一主成分，得到同时具有高空间分辨率和高光谱分。</p>
<p>　　从性能上讲，主成分分析法更像是对源图像的选择而不是对源图像中显著信息的融和。局限性：以全局方差作为信息显著性度量通常会把较大的权值分配给方差较大的源图像。实际应用中，当某一传感器输出图像对比度较低时，这种权值分配方法效果会比较好，但就一般情况而言，这种分配方法并不科学。此外，主成分分析法对图像中的死点、噪声等干扰信息非常敏感，这些干扰信息会显著的提高图像的全局方差。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单加权融合也叫做<strong>像素加权平均法</strong>（Weighted Averaging，WA）是最简单、直接的图像融合方法。它具有简单易实现、运算速度快的优点，并能提高融合图像的信噪比，但是这种方法削弱了图像中的细节信息，降低了图像的对比度，在一定程度上使]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR系统系列文章汇总]]></title>
    <link href="http://silencewt.github.io/2014/12/30/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"/>
    <id>http://silencewt.github.io/2014/12/30/车牌识别LPR系统系列文章汇总/</id>
    <published>2014-12-30T02:50:35.000Z</published>
    <updated>2014-12-30T02:51:19.000Z</updated>
    <content type="html"><![CDATA[<p>　　这里的LPR的的几篇文章是之前项目的一些相关资料的整理，涉及实验室内部的资料就没有放上来，希望能对想了解这方面的同学，有所帮助，那怕了解个大概也好。知道整体的思路就好。当初就是一个人瞎摸索，走了很多的弯路，也算给其他人一点建议吧。</p>
<p>车牌识别LPR系统系列文章汇总：</p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%80%EF%BC%89-%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF/" target="_blank" rel="external">车牌识别LPR（一）— 研究背景</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BD%A6%E7%89%8C%E7%89%B9%E5%BE%81%E5%8F%8A%E9%9A%BE%E7%82%B9/" target="_blank" rel="external">车牌识别LPR（二）— 车牌特征及难点</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%89%EF%BC%89-LPR%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/" target="_blank" rel="external">车牌识别LPR（三）— LPR系统整体结构</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%9B%9B%EF%BC%89-%E8%BD%A6%E7%89%8C%E5%AE%9A%E4%BD%8D/" target="_blank" rel="external">车牌识别LPR（四）— 车牌定位</a> </p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%BA%94%EF%BC%89-%E4%B8%80%E7%A7%8D%E8%BD%A6%E7%89%8C%E5%AE%9A%E4%BD%8D%E6%B3%95/" target="_blank" rel="external">车牌识别LPR（五）— 一种车牌定位法</a> </p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AD%EF%BC%89-%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2/" target="_blank" rel="external">车牌识别LPR（六）— 字符分割</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E4%B8%83%EF%BC%89-%E5%AD%97%E7%AC%A6%E7%89%B9%E5%BE%81/" target="_blank" rel="external">车牌识别LPR（七）— 字符特征</a></p>
<p><a href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AB%EF%BC%89-%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/" target="_blank" rel="external">车牌识别LPR（八）— 字符识别</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这里的LPR的的几篇文章是之前项目的一些相关资料的整理，涉及实验室内部的资料就没有放上来，希望能对想了解这方面的同学，有所帮助，那怕了解个大概也好。知道整体的思路就好。当初就是一个人瞎摸索，走了很多的弯路，也算给其他人一点建议吧。</p>
<p>车牌识别LPR系统系列文]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像融合（一）-- 概述]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89-%E6%A6%82%E8%BF%B0/"/>
    <id>http://silencewt.github.io/2014/12/29/图像融合（一）-概述/</id>
    <published>2014-12-29T12:28:00.000Z</published>
    <updated>2014-12-29T12:33:59.000Z</updated>
    <content type="html"><![CDATA[<p>　　这是2014年第二部分的内容。关于三光检测融合的一些资料整理，部分内容由于保密原因没有写出来，这里整理的内容都是网上或者文章里可以看到的。</p>
<h3 id="一、概述">一、概述</h3>
<p>　　图像融合是图像处理中重要部分，能够协同利用同一场景的多种传感器图像信息，输出一幅更适合于人类视觉感知或计算机进一步处理与分析的融合图像。它可明显的改善单一传感器的不足，提高结果图像的清晰度及信息包含量，有利于更为准确、更为可靠、更为全面地获取目标或场景的信息。</p>
<p>　　图像融合主要应用于军事国防上、遥感方面、医学图像处理、机器人、安全和监控、生物监测等领域。用于较多也较成熟的是红外和可见光的融合，在一副图像上显示多种信息，突出目标。</p>
<p>　　融合过程可以在不同的层次上进行，可分为：信号级、像素级、特征级，决策级。</p>
<h4 id="1-1、信号级">1.1、信号级</h4>
<p>　　在最低层对未经处理的传感器输出在信号域进行混合，产生一个融合后的信号。融合后的信号与源信号形式相同但品质更好，来自传感器的信号可建模为混有不同相关噪声的随机变量。此种情况下，融合可以考虑为一种估计过程，信号级图像融合在很大程度上是信号的最优集中或分布检测问题，对信号时间和空间上的配准要求最高。</p>
<h4 id="1-2、像素级">1.2、像素级</h4>
<p>　　像素级图像融合是三个层次中最基本的融合，经过像素级图像融合以后得到的图像具有更多的细节信息，如边缘、纹理的提取，有利于图像的进一步分析、处理与理解，还能够把潜在的目标暴露出来，利于判断识别潜在的目标像素点的操作，这种方法才可以尽可能多的保存源图像中的信息，使得融合后的图片不论是内容还是细节都有所增加，这个优点是独一无二的，仅存在于像素级融合中。但像素级图像融合的局限性也是不能忽视的，由于它是对像素点进行操作，所以计算机就要对大量的数据进行处理，处理时所消耗的时间会比较长，就不能够及时地将融合后图像显示出来，无法实现实时处理；另外在进行数据通信时，信息量较大，容易受到噪声的影响；还有如果没有将图片进行严格的配准就直接参加图像融合，会导致融合后的图像模糊，目标和细节不清楚、不精确。</p>
<h4 id="1-3、特征级">1.3、特征级</h4>
<p>　　特征级图像融合是从源图像中将特征信息提取出来，这些特征信息是观察者对源图像中目标或感兴趣的区域，如边缘、人物、建筑或车辆等信息，然后对这些特征信息进行分析、处理与整合从而得到融合后的图像特征。对融合后的特征进行目标识别的精确度明显的高于原始图像的精确度。特征级融合对图像信息进行了压缩，再用计算机分析与处理，所消耗的内存与时间与像素级相比都会减少，所需图像的实时性就会有所提高。特征级图像融合对图像匹配的精确度的要求没有第一层那么高，计算速度也比第一层快，可是它提取图像特征作为融合信息，所以会丢掉很多的细节性特征。</p>
<h4 id="1-4、决策级">1.4、决策级</h4>
<p>　　决策级图像融合是以认知为基础的方法，它不仅是最高层次的图像融合方法，抽象等级也是最高的。决策级图像融合是有针对性的，根据所提问题的具体要求，将来自特征级图像所得到的特征信息加以利用，然后根据一定的准则以及每个决策的可信度（目标存在的概率）直接作出最优决策。三个融合层级中，决策级图像融合的计算量是最小的，可是这种方法对前一个层级有很强的依赖性，得到的图像与前两种融合方法相比不是很清晰。将决策级图像融合实现起来比较困难，但图像传输时噪声对它的影响最小。</p>
<p>　　综合以上，<strong>研究和应用最多的是像数级图像融合</strong>，目前提出的绝大多数的图像融合算法均属于该层次上的融合。图像融合狭义上指的就是像数级图像融合。本文研究的也正是像素级图像融合算法。</p>
<p>　　<strong>红外和可见的融合很多文献都是从像素级入手，基于已有的融合算法，根据实际情况，来设立融合规则，得到适合实际应用场景的融合图像。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这是2014年第二部分的内容。关于三光检测融合的一些资料整理，部分内容由于保密原因没有写出来，这里整理的内容都是网上或者文章里可以看到的。</p>
<h3 id="一、概述">一、概述</h3>
<p>　　图像融合是图像处理中重要部分，能够协同利用同一场景的多种传感器图]]>
    </summary>
    
      <category term="图像融合" scheme="http://silencewt.github.io/tags/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[车牌识别LPR（八）-- 字符识别]]></title>
    <link href="http://silencewt.github.io/2014/12/29/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%ABLPR%EF%BC%88%E5%85%AB%EF%BC%89-%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"/>
    <id>http://silencewt.github.io/2014/12/29/车牌识别LPR（八）-字符识别/</id>
    <published>2014-12-29T08:35:10.000Z</published>
    <updated>2014-12-29T08:43:04.000Z</updated>
    <content type="html"><![CDATA[<p>​第八篇：字符识别</p>
<p>　　车牌定位、车牌倾斜校正、车牌字符分割都是为车牌字符识别做的前提工作，这些前提工作直接关系到车牌识别系统的性能。车牌字符识别是车牌识别系统的核心部分，车牌字符识别的准确率是衡量车牌识别系统的一个很重要的指标。</p>
<p>　　一般字符识别的方法就是采用模式识别方法，简单的来说模式识别就是先通过提取输入模板的特征，然后通过模板的特征对样本进行分类，从而识别出样本。模式识别主要包括：数据采集、预处理、特征提取、特征匹配，其结构框架如图：</p>
<p>　　字符识别是模式识别的一个重要应用，首先提取待识别字符的特征；然后对提取出来的特征跟字符模板的特征匹配；最后根据准则判定该字符所属的类别。不同的训练方法，不同的特征提取， 不同的匹配规则，就相应的有不同的字符识别方法，基本上很多就是在这些地方做改进，或者是采用新的规则。但是万变不离其宗。</p>
<p><strong>（1）模板匹配字符识别算法</strong></p>
<p>　　模板匹配字符识别算法是图像识别中的经典算法之一，该算法的核心思想是：通过比较待识别字符图像的字符特征和标准模板的字符特征，计算两者之间的相似性，相似性最大的标准模板的字符即为待识别的字符。该方法首先要建立标准模板库，其中标准模板库中的字符的大小是一样的；然后将待识别的字符规格化，其大小应该和模板库中的字符一样；最后将待识别的字符和标准模板库中的所有字符进行匹配，计算相似度。模板匹配字符识别算法适用于印刷字体、字体规范的字符等，但是对字符变形、弯曲、字符旋转等情况的抗干扰能力差。</p>
<p><strong>（2）神经网络字符识别算法</strong></p>
<p>　　主要思想是：通过神经网络学习大量字符样本，从而得到字符的样本特征。当对待识别的字符进行识别时，神经网络就会将待识别字符的特征和之前得到的样本特征匹配，从而识别出字符。该算法主要利用神经网络的学习和记忆功能。神经网络虽然有其优点，但是由于采用神经网络识别字符依赖于初始的样本的选择，并且容易陷入局部最优和收敛速度慢，因此采用神经网络识别字符的算法仍需要改进。</p>
<p><strong>（3）支持向量机</strong></p>
<p>　　主要思想：同上，都是先得到样本特征，进行训练，然后再分类。SVM应该算是用的的最多的分类方法，一般大多适合于二分类问题，在这里就需要使用多分类器来构造。</p>
<h3 id="字符识别步骤："><strong>字符识别步骤：</strong></h3>
<h4 id="1、归一化">1、归一化</h4>
<p>　　主要包括位置归一化和大小归一化。由于本文处理的车牌字符都是标准的印刷体字符，且都进行过倾斜校正，所以不需要对其进行位置归一化。但由于摄像距离大小不一样，导致拍摄到的车辆图像中的车牌字符大小不一，为了达到更好的识别效果，就需要对分割出来的单个车牌字符进行大小归一化。常用的归一化方法有两种：一种是将字符图像的外边框按比例线性放大或缩小到规定尺寸；另一种是根据水平和垂直两个方向像素的分布进行大小归一化。一般用第一种。当映射到原图像的点的坐标不是整数，即位于几个像素之间，这就需要利用插值算法来决定该像素的值。使用常见的双线性插值法。将图像归一化为32*64的。</p>
<h4 id="2、特征">2、特征</h4>
<p>　　根据上一篇的介绍，采用LBP特征来识别汉字，均匀网格特征来识别字母和数字。</p>
<h4 id="3、分类器">3、分类器</h4>
<p>　　SVM作为分类器。支持向量机的原理，其所涉及到的数学知识比较复杂，自己编程实现的话有一定难度。采用现成的支持 SVM 的工具箱，公认做的比较好的是台湾大学林智仁(Chih-Jen Lin)教授开发的 LibSVM，支持 SVM 的各种算法，可以解决回归和分类识别问题。LibSVM 不但提供了 Windows 系统的可执行文件，还提供了 C 语言的源代码，方便科研工作者根据自己的需要进行改进，而且还提供了Java、Matlab、C#、Ruthon 等语言的接口。当然可以直接调用opencv中的SVM工具。 </p>
<p>　　汉字的笔画很稠密，字符分辨率非常低:如果对车牌汉字字符进行二值化，将会丢失汉字的很多重要的结构信息，产生不必要的噪声，导致笔画断裂和笔画粘连等。</p>
<h4 id="4、二次识别">4、二次识别</h4>
<p>　　总的来说，单个字符的识别率比较高，容易识别错的主要是相近字符，解决这类问题的最佳办法就是二次识别。将相似字符中的一个识别出来后，便能确定其属于哪一类相近字符类别,利用区分相近字符的细节特征，将这个字符到专门识别这类相近字符的分类器中进行二次识别。车牌字符中相近字符主要有5类，分为为“0”、“D”、“Q”，“B”、“8”，“2”、”Z”，“5”、”S”和“A”、“4”。</p>
<p>　　(1) “0”、“D、“Q”</p>
<p>　　从字符图像中可以看出,它们的区分在左侧和右下角，其中“D”的左边为直线，黑色像素点较多，而“0”和“Q”的左边均为弧线,黑色像素点相对较少；字符“Q”的右下角的笔画丰富，黑色像素较多。具体局部特征如图：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.1.png" alt="0dq"></p>
<p> 　　(2)“B、8“</p>
<p>　　它们的区别在字符的左侧,“8”的左侧为弧线,而“B”的左侧为直线。具体局部<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.2.png" alt="b8"></p>
<p>　　(3) “2、Z”</p>
<p>　　它们的区别在字符的上方，“2”的上方为弧线，“Z”的上方为直线，具体局部特征。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.3.png" alt="2z"></p>
<p>　　(4)“5、S”</p>
<p>　　它们的区别在字符的上半部分，“5”的上半部分中，上方和左侧均为直线,而”S”的上半部分为弧线。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.4.png" alt="5s"></p>
<p> 　　(5)“A、4”</p>
<p>　　由于存在倾斜等情况,仅仅通过基本特征会出现误识别,它们的区别在左下角。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/lpr8.5.png" alt="a4"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>​第八篇：字符识别</p>
<p>　　车牌定位、车牌倾斜校正、车牌字符分割都是为车牌字符识别做的前提工作，这些前提工作直接关系到车牌识别系统的性能。车牌字符识别是车牌识别系统的核心部分，车牌字符识别的准确率是衡量车牌识别系统的一个很重要的指标。</p>
<p>　　一般字符识]]>
    </summary>
    
      <category term="LPR" scheme="http://silencewt.github.io/tags/LPR/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
</feed>
