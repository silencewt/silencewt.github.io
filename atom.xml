<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Sissy 婷婷 Blog]]></title>
  <subtitle><![CDATA[既然选择远方，便风雨兼程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://silencewt.github.io/"/>
  <updated>2015-05-11T02:11:27.937Z</updated>
  <id>http://silencewt.github.io/</id>
  
  <author>
    <name><![CDATA[Wangt]]></name>
    <email><![CDATA[wangt_hust@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[【转载】String、StringBuffer与StringBuilder之间区别]]></title>
    <link href="http://silencewt.github.io/2015/05/11/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91String%E3%80%81StringBuffer%E4%B8%8EStringBuilder%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB/"/>
    <id>http://silencewt.github.io/2015/05/11/【转载】String、StringBuffer与StringBuilder之间区别/</id>
    <published>2015-05-11T01:59:40.000Z</published>
    <updated>2015-05-11T02:11:19.000Z</updated>
    <content type="html"><![CDATA[<p>文章来源：<a href="http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html" target="_blank" rel="external">http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html</a></p>
<p>　　这两天在看Java编程的书，看到String的时候将之前没有弄懂的都理清了一遍，本来想将String之间的区别记录下来的，在找资料的时候发现这位网友整理的很不错，值得借鉴。我就在这个上面添一点自己的理解了。原文地址在上面。</p>
<p>　　关于这三个类在字符串处理中的位置不言而喻，那么他们到底有什么优缺点，到底什么时候该用谁呢？下面我们从以下几点说明一下:</p>
<p>　　1.三者在执行速度方面的比较：StringBuilder &gt;  StringBuffer  &gt;  String</p>
<p>　　2.String &lt;（StringBuffer，StringBuilder）的原因</p>
<p>　　　　String：字符串常量</p>
<p>　　　　StringBuffer：字符串变量</p>
<p>　　　　StringBuilder：字符串变量</p>
<p>　　从上面的名字可以看到，String是“字符串常量”，也就是不可改变的对象。对于这句话的理解你可能会产生这样一个疑问，比如这段代码：</p>
<pre><code> 　<span class="type">String</span> s = <span class="string">"abcd"</span>;
  s = s+<span class="number">1</span>;
  <span class="type">System</span>.<span class="keyword">out</span>.print(s);// <span class="literal">result</span> : abcd1
</code></pre><p>　　我们明明就是改变了String型的变量s的，为什么说是没有改变呢? 其实这是一种欺骗，JVM是这样解析这段代码的：首先创建对象s，赋予一个abcd，然后再创建一个新的对象s用来执行第二行代码，也就是说我们之前对象s并没有变化，所以我们说String类型是不可改变的对象了，由于这种机制，每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉，可想而知这样执行效率会有多底。String类中每一个看起来会修改String值的方法，实际上都是创建一个全新的String对象，已包含修改后的字符串，而最初的String对象则丝毫未动。</p>
<p>　　而StringBuffer与StringBuilder就不一样了，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，这样就不会像String一样创建一些而外的对象进行操作了，当然速度就快了。StringBuffer和String有很多相似之处，但是其内部的实现却有很大的差别，StringBuffer其实是一个分装一个字符数组，同时提供了对这个字符数组的相关操作。StringBuffer（）构造一个字符缓冲区，其初始容量为16个字符。</p>
<p>　　3.一个特殊的例子：</p>
<pre><code>String str = “This <span class="keyword">is</span> <span class="keyword">only</span> <span class="keyword">a</span>” + “ simple” + “ test”;
StringBuffer builder = <span class="keyword">new</span> StringBuilder(“This <span class="keyword">is</span> <span class="keyword">only</span> <span class="keyword">a</span>”).<span class="built_in">append</span>(“ simple”).<span class="built_in">append</span>(“ test”);
</code></pre><p>　　你会很惊讶的发现，生成str对象的速度简直太快了，而这个时候StringBuffer居然速度上根本一点都不占优势。其实这是JVM的一个把戏，实际上：<br>String str = “This is only a” + “ simple” + “test”;<br>其实就是：<br>String str = “This is only a simple test”;</p>
<p>　　所以不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的String对象的话，速度就没那么快了，譬如：</p>
<p>　　String str2 = “This is only a”;<br>　　String str3 = “ simple”;<br>　　String str4 = “ test”;<br>　　String str1 = str2 +str3 + str4;</p>
<p>　这时候JVM会规规矩矩的按照原来的方式去做。</p>
<p>　　4.StringBuilder与 StringBuffer</p>
<p>　　　StringBuilder：线程非安全的</p>
<p>　　　StringBuffer：线程安全的</p>
<p>　　 当我们在字符串缓冲区被多个线程使用时，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。</p>
<p> 对于三者使用的总结：</p>
<blockquote>
<p>1.如果要操作少量的数据用 = String</p>
<p>2.单线程操作字符串缓冲区下操作大量数据 = StringBuilder</p>
<p>3.多线程操作字符串缓冲区下操作大量数据 = StringBuffer</p>
</blockquote>
<p>关于三者的速度，自己写了个测试代码：</p>
<pre><code>package com.wt.others;
<span class="keyword">public</span> <span class="keyword">class</span> StringCompare {

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    <span class="comment">// TODO Auto-generated method stub</span>
    String text = <span class="string">""</span>;
    <span class="keyword">long</span> beginTime = <span class="number">0</span>l;
    <span class="keyword">long</span> endTime = <span class="number">0</span>l;
    StringBuffer buffer = <span class="keyword">new</span> StringBuffer();
 StringBuilder builder = <span class="keyword">new</span> StringBuilder();
    beginTime = System.currentTimeMillis();
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20000</span>; i++){
        buffer.append(String.valueOf(i));
    }
    endTime = System.currentTimeMillis();
    System.<span class="keyword">out</span>.println(<span class="string">"StringBuffer time is : "</span>+ (endTime - beginTime));

    beginTime = System.currentTimeMillis();
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20000</span>; i++){
        builder.append(String.valueOf(i));
    }
    endTime = System.currentTimeMillis();
    System.<span class="keyword">out</span>.println(<span class="string">"StringBuilder time is : "</span>+ (endTime - beginTime));

    beginTime = System.currentTimeMillis();
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20000</span>; i++){
        text = text + i;
    }
    endTime = System.currentTimeMillis();
    System.<span class="keyword">out</span>.println(<span class="string">"String time is : "</span>+ (endTime - beginTime));
}
}
</code></pre><p>　</p>
<p>　运行结果可以直观的看出：</p>
<p>　　StringBuffer time is : 5<br>　　StringBuilder time is : 3<br>　　String time is : 1550</p>
<p>　　如果将20000</p>
<p>改为100，结果为：</p>
<p>　　StringBuffer time is : 1<br>　　StringBuilder time is : 0<br>　　String time is : 1</p>
<p>　　还是可以直观看出在单线程</p>
<p>使用时，StringBuilder速度很快。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>文章来源：<a href="http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html" target="_blank" rel="external">http://www.cnblogs.com/A_ming]]>
    </summary>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java异常处理机制]]></title>
    <link href="http://silencewt.github.io/2015/05/11/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://silencewt.github.io/2015/05/11/Java异常处理机制/</id>
    <published>2015-05-11T01:59:24.000Z</published>
    <updated>2015-05-11T02:00:27.000Z</updated>
    <content type="html"><![CDATA[<p>　　异常允许我们强制停止程序运行，并告诉我们出现了什么问题，或者强制程序去处理问题，并返回到稳定状态。</p>
<p>　　Java提供一个Throwable类，该类是所有异常和错误类的超类。只有当对象是此类的实例时，才能通过Java虚拟机或者Java的throw语句抛出。throwable类及其子类的结构图：</p>
<h2 id="一、异常类型">一、异常类型</h2>
<p>　　<strong>Error：</strong>一般是指严重的系统错误，与虚拟机相关的问题，如系统崩溃，虚拟机出错，动态链接失败等，这一类的错误一般无法修复或不可能捕获，将导致应用程序中断。</p>
<p>　　<strong>Exception：</strong>是指一些可以捕获且可能恢复的异常情况，如数组下标越界ArrayIndexOutOfBoundsException、数字被零除产生异常ArithmeticException、输入输出异常IOException等。</p>
<p>　　可以知道Error属于JVM需要负担的责任，RuntimeException类是程序应该负担的责任，受检异常是具体应用负担的责任。作为程序员关心的就是Exception。</p>
<p><strong>1、非受检异常</strong></p>
<p>　　是指编译器不要求强制处置的异常，一般是编程时的逻辑错误，是程序员应该避免的，RuntimeException类以及他的子类都是非受检异常的，具体如下：</p>
<p>　　1）错误的类型转换：ClassCastException</p>
<p>　　2）组下标越界：ArrayIndexOutOfBoundsException</p>
<p>　　3）空指针访问异常：NullPointerException</p>
<p>　　4）被零除产生异常：ArithmeticException</p>
<p><strong>2、受检异常</strong></p>
<p>　　编译器要求必须处置的异常，及程序运行时由于外界因素造成的一般性异常，具体如下：</p>
<p>　　1）没有找到具体指定名称的类异常：ClassNotFoundException</p>
<p>　　2）访问不存在的文件异常：FileNotFoundException</p>
<p>　　3）操作文件异常：IOException</p>
<p>　　4）操作数据库时发生异常：SQLException</p>
<p>　　Java要求Java程序必须捕获或声明所有的受检异常，对于这类异常，如果程序不做处理，则将会带来意想不到的结果，而非受检异常可以不做任何处理。
　　</p>
<h2 id="二、捕获异常语句">二、捕获异常语句</h2>
<p>　　<strong>1、try……catch……finally……</strong></p>
<p>　　try选定要捕获异常的范围，在执行时，catch后面括号内的代码会产生异常对象并抛出，然后用catch块来处理异常。</p>
<p>　　finally不管是否有异常发生都要执行的语句块，如数据库的关闭。要注意：如果try语句块中有一个明确的return语句，finally快也总是在return前执行。</p>
<p>　　<strong>2、throws 和 throw</strong></p>
<p>　　<strong>throw：</strong>语句明确的抛出一个异常，必须是一个throwable 的类，或者new来创建一个实例：throw new XXException（）；</p>
<p>　　执行throw语句后，运行流程将立即停止throw的下一条语句也将暂停执行。</p>
<p>　　<strong>throws：</strong>如果一个方法a可以引发异常，而他本身并不对该异常进行处理，那么a方法必须将这个异常抛给调用方法，以使程序能够继续执行下去。用法：method（）throws 　　Exception1，Exception2,。即throws用来声明一个方法可能会抛出的所有异常，如果一个方法声明的是受检异常，那么调用这个方法的类必须处理这个异常。可以使用try……catch……来捕获，也可以在该方法上声明throws。
　</p>
<pre><code>public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub
    <span class="type">int</span> number = <span class="number">0</span>;
    <span class="keyword">try</span> {
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"aaaaaaaa"</span>);
        number = <span class="type">Integer</span>.parseInt(args[<span class="number">0</span>]);
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"bbbbbbbb"</span>);
    } catch (<span class="type">Exception</span> e) {
        // <span class="type">TODO</span>: handle exception
        throw new <span class="type">ArrayIndexOutOfBoundsException</span>(<span class="string">"out of bounds"</span>);
        //<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"非法的数字"</span>);
    }
    <span class="keyword">finally</span>{
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"你输入的数字为："</span>+number);
    }
}　
</code></pre><p>结果：</p>
<blockquote>
<p>　aaaaaaaa</p>
<p>　　你输入的数字为：0</p>
<p>　　Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException:<br>out of bounds</p>
<p>　　at com.wt.others.ThrowTest.main(ThrowTest.java:12)</p>
</blockquote>
<p>　　<strong>原理：</strong>但抛出异常后将使用使用new在堆上创建异常对象，然后你的执行路径被终止，并且从当前环境中弹出对异常对象的引用，此时异常处理机制接管程序，并开始找一个恰当的地方执行程序，这个恰当的地方就是异常处理程序，它的任务就是将程序从错误状态中恢复。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    testThrows(args);
}
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testThrows</span>(String[] tmp) {
    <span class="keyword">try</span> {
        createThrows(tmp);
    } <span class="keyword">catch</span> (Exception e) {
        <span class="comment">// TODO: handle exception</span>
        System.<span class="keyword">out</span>.println(<span class="string">"come from createThrows "</span>);
    }
}
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2Throws</span>(String[] tmp) throws Exception {
    createThrows(tmp);
}
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createThrows</span>(String[] tmp){
    <span class="keyword">int</span> num = <span class="number">0</span>;
    num = Integer.parseInt(tmp[<span class="number">0</span>]);
    System.<span class="keyword">out</span>.println(<span class="string">"你输入的数字为："</span>+num);
}
</code></pre><p>　　throws和throw可以组合在一起使用，就是在捕获异常后抛出一个明确的异常个调用者。</p>
<p><strong>二者的区别：</strong></p>
<p>　　throw是用在方法中的，throws是用在方法签名之后的，在同一个地方使用这些的时候要注意，throws抛出异常的类型范围要比throw的大才行。
　</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    <span class="keyword">try</span> {
        methodA();
    } <span class="keyword">catch</span>(Exception e)  {
        <span class="comment">// TODO: handle exception</span>
        System.<span class="keyword">out</span>.println(e.getMessage());
    }
    methodB();
}
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodA</span>() {
    <span class="keyword">try</span> {
        System.<span class="keyword">out</span>.println(<span class="string">"come in A"</span>);
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"制造异常"</span>);
    } <span class="keyword">finally</span>  {
        <span class="comment">// TODO: handle exception</span>
        System.<span class="keyword">out</span>.println(<span class="string">"用A的finally "</span>);
    }
}
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodB</span>() {
    <span class="keyword">try</span> {
        System.<span class="keyword">out</span>.println(<span class="string">"come in B"</span>);
        <span class="keyword">return</span>;  <span class="comment">//这里返回，在执行完finally语句后才返回</span>
    } <span class="keyword">finally</span>  {
        <span class="comment">// TODO: handle exception</span>
        System.<span class="keyword">out</span>.println(<span class="string">"用B的finally "</span>);
    }
}
</code></pre><p>结果：　</p>
<blockquote>
<p>　　come in A</p>
<p>　　用A的finally </p>
<p>　　制造异常</p>
<p>　　come in B</p>
<p>　　用B的finally</p>
</blockquote>
<p>　　<strong>3、getMessage和printStackTrace方法</strong></p>
<p>　　<strong>getMessage：</strong>返回此throwable对象的详细消息字符串</p>
<p>　　<strong>printStackTrace：</strong>将此throwable对象及其追踪输出至标准错误流</p>
<pre><code><span class="keyword">try</span>{
fun();
}<span class="keyword">catch</span>(<span class="keyword">Exception</span> e){
e.getMessage(e);
<span class="comment">// e.printStackTrace(e)；</span>
}
</code></pre><h2 id="三、自定义异常类">三、自定义异常类</h2>
<p>　　一般都选择Exception作为父类，如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>{
<span class="keyword">public</span> <span class="title">MyException</span>(){
    <span class="keyword">super</span>();
}
<span class="keyword">public</span> <span class="title">MyException</span>(String msg){
    <span class="keyword">super</span>(msg);
}
<span class="keyword">public</span> <span class="title">MyException</span>(Throwable cause){
    <span class="keyword">super</span>(cause);
}
<span class="keyword">public</span> <span class="title">MyException</span>(String msg,Throwable cause){
    <span class="keyword">super</span>(msg, cause);
}
}
</code></pre><p>　　其实并不是所有的异常都需要处理，异常处理会占用一定的资源，影响程序的执行效率。认真观察异常的名字和行号，尽量减少try语句块的体积，在处理异常的时候应该打印出该异常的堆栈信息以方便调试使用。</p>
<p>　　对异常对象的清理并不需要过多的关心，因为他们都是用new在堆上建立的，垃圾回收器会自动将他们清理掉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　异常允许我们强制停止程序运行，并告诉我们出现了什么问题，或者强制程序去处理问题，并返回到稳定状态。</p>
<p>　　Java提供一个Throwable类，该类是所有异常和错误类的超类。只有当对象是此类的实例时，才能通过Java虚拟机或者Java的throw语句抛出。t]]>
    </summary>
    
      <category term="Java" scheme="http://silencewt.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://silencewt.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Segmentation Fault错误原因总结]]></title>
    <link href="http://silencewt.github.io/2015/05/11/Segmentation-Fault%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://silencewt.github.io/2015/05/11/Segmentation-Fault错误原因总结/</id>
    <published>2015-05-11T01:57:10.000Z</published>
    <updated>2015-05-11T02:08:24.000Z</updated>
    <content type="html"><![CDATA[<p>　　最近在项目上遇到了Segmentation Fault的错误，一直调试不出来是哪里出了问题，对于刚接触嵌入式的，也不知道该如何去调试一个项目，定位内存问题，纠结了好几天，好阿红整理下自己的思路。从头开始。</p>
<p>　　以下内容只为整理来自己使用的，大多来源于网络，感谢大家的分享：</p>
<p>　　<a href="http://www.cnblogs.com/no7dw/archive/2013/02/20/2918372.html" target="_blank" rel="external">http://www.cnblogs.com/no7dw/archive/2013/02/20/2918372.html</a></p>
<p>　　<a href="http://blog.chinaunix.net/uid-20780355-id-538814.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20780355-id-538814.html</a></p>
<h2 id="一、什么是“Segmentation_fault_in_Linux”">一、什么是“Segmentation fault in Linux”</h2>
<pre><code>A segmentation fault (often shortened <span class="built_in">to</span> SIGSEGV) is <span class="operator">a</span> particular error condition that can occur during <span class="operator">the</span> operation <span class="operator">of</span> computer software. A segmentation fault occurs when <span class="operator">a</span> program attempts <span class="built_in">to</span> access <span class="operator">a</span> memory location that <span class="keyword">it</span> is <span class="operator">not</span> allowed <span class="built_in">to</span> access, <span class="operator">or</span> attempts <span class="built_in">to</span> access <span class="operator">a</span> memory location <span class="operator">in</span> <span class="operator">a</span> way that is <span class="operator">not</span> allowed (<span class="keyword">for</span> example, attempting <span class="built_in">to</span> <span class="built_in">write</span> <span class="built_in">to</span> <span class="operator">a</span> <span class="built_in">read</span>-only location, <span class="operator">or</span> <span class="built_in">to</span> overwrite part <span class="operator">of</span> <span class="operator">the</span> operating <span class="keyword">system</span>).

Segmentation is <span class="constant">one</span> approach <span class="built_in">to</span> memory management <span class="operator">and</span> protection <span class="operator">in</span> <span class="operator">the</span> operating <span class="keyword">system</span>. It has been superseded <span class="keyword">by</span> paging <span class="keyword">for</span> most purposes, but much <span class="operator">of</span> <span class="operator">the</span> terminology <span class="operator">of</span> segmentation is still used, <span class="string">"segmentation fault"</span> being <span class="operator">an</span> example. Some operating systems still have segmentation <span class="keyword">at</span> some logical level although paging is used <span class="keyword">as</span> <span class="operator">the</span> main memory management policy.

On Unix-like operating systems, <span class="operator">a</span> <span class="built_in">process</span> that accesses <span class="operator">an</span> invalid memory address receives <span class="operator">the</span> SIGSEGV signal. On Microsoft Windows, <span class="operator">a</span> <span class="built_in">process</span> that accesses invalid memory receives <span class="operator">the</span> STATUS_ACCESS_VIOLATION exception.
</code></pre><p>　　就是：所谓的段错误就是指访问的内存超出了系统所给这个程序的内存空间，通常这个值是由gdtr来保存的，他是一个48位的寄存器，其中的32位是保存由它指向的gdt表，后13位保存相应于gdt的下标，最后3位包括了程序是否在内存中以及程序的在cpu中的运行级别,指向的gdt是由以64位为一个单位的表，在这张表中就保存着程序运行的代码段以及数据段的起始地址以及与此相应的段限和页面交换还有程序运行级别还有内存粒度等等的信息。一旦一个程序发生了越界访问，cpu就会产生相应的异常保护，于是segmentation fault就出现了。</p>
<p>　　即“当程序试图访问不被允许访问的内存区域（比如，尝试写一块属于操作系统的内存），或以错误的类型访问内存区域（比如，尝试写一块只读内存）。这个描述是准确的。为了加深理解，我们再更加详细的概括一下SIGSEGV。段错误应该就是访问了不可访问的内存，这个内存区要么是不存在的，要么是受到系统保护的。</p>
<blockquote>
<p>SIGSEGV是在访问内存时发生的错误，它属于内存管理的范畴</p>
<p>SIGSEGV是一个用户态的概念，是操作系统在用户态程序错误访问内存时所做出的处理。</p>
<p>当用户态程序访问（访问表示读、写或执行）不允许访问的内存时，产生SIGSEGV。</p>
<p>当用户态程序以错误的方式访问允许访问的内存时，产生SIGSEGV。</p>
</blockquote>
<p>　　用户态程序地址空间，特指程序可以访问的地址空间范围。如果广义的说，一个进程的地址空间应该包括内核空间部分，只是它不能访问而已</p>
<h2 id="二、SIGSEGV产生的可能情况">二、SIGSEGV产生的可能情况</h2>
<p>　　指针越界和SIGSEGV是最常出现的情况，经常看到有帖子把两者混淆，而这两者的关系也确实微妙。在此，我们把指针运算（加减）引起的越界、野指针、空指针都归为指针越界。SIGSEGV在很多时候是由于指针越界引起的，但并不是所有的指针越界都会引发SIGSEGV。一个越界的指针，如果不解引用它，是不会引起SIGSEGV的。而即使解引用了一个越界的指针，也不一定会引起SIGSEGV。这听上去让人发疯，而实际情况确实如此。SIGSEGV涉及到操作系统、C库、编译器、链接器各方面的内容，我们以一些具体的例子来说明。</p>
<p><strong>（1）错误的访问类型引起</strong></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="keyword">int</span> main()
{
     <span class="keyword">char</span> *c = <span class="string">"hello world"</span>;
     c[<span class="number">1</span>] = <span class="string">'H'</span>;
}
</code></pre><p>　　上述程序编译没有问题，但是运行时弹出SIGSEGV。此例中，”hello world”作为一个常量字符串，在编译后会被放在rodata节（GCC），最后链接生成目标程序时.rodata节会被合并到text segment与代码段放在一起，故其所处内存区域是只读的。这就是错误的访问类型引起的SIGSEGV。</p>
<p><strong>（2）访问了不属于进程地址空间的内存</strong></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="keyword">int</span> main()
{
    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="number">0xC0000fff</span>;
     *p = <span class="number">10</span>;
}　
</code></pre><p>还有另一种可能，往受到系统保护的内存地址写数据，最常见就是给一个指针以0地址：</p>
<pre><code><span class="keyword">int</span>  i=<span class="number">0</span>;
<span class="built_in">scanf</span> (<span class="string">"%d"</span>, i);  <span class="comment">/* should have used &amp;i */</span>
<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, i);
<span class="keyword">return</span> <span class="number">0</span>;　
</code></pre><p><strong>（3）访问了不存在的内存</strong></p>
<p> 最常见的情况不外乎解引用空指针了，如：</p>
<p>int <em>p = null;
</em>p = 1;</p>
<p>在实际情况中，此例中的空指针可能指向用户态地址空间，但其所指向的页面实际不存在。</p>
<p><strong>（4）内存越界，数组越界，变量类型不一致等</strong></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="keyword">int</span>  main()
{
    <span class="keyword">char</span> test[<span class="number">1</span>];
    <span class="built_in">printf</span>(<span class="string">"%c"</span>, test[<span class="number">10</span>]);
    <span class="keyword">return</span> <span class="number">0</span>;
}　
</code></pre><p>这就是明显的数组越界了，或者这个地址根本不存在。</p>
<p><strong>（5）试图把一个整数按照字符串的方式输出</strong></p>
<pre><code>    <span class="keyword">int</span>  main()
    {
        <span class="keyword">int</span> b = <span class="number">10</span>;
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\n"</span>, b);
        <span class="keyword">return</span> <span class="number">0</span>;
    }
</code></pre><p>这是什么问题呢？由于还不熟悉调试动态链接库，所以我只是找到了printf的源代码的这里。</p>
<pre><code>声明部分：
int pos =<span class="number">0</span> ,cnt_printed_chars =<span class="number">0</span> ,i ;
unsigned char *chptr ;
va_list ap ;
%s格式控制部分：
case <span class="string">'s'</span>:
    chptr =va_arg (ap ,unsigned char *);
    i =<span class="number">0</span> ;
    <span class="keyword">while</span> (chptr [i ])
    {<span class="keyword">...</span>
        cnt_printed_chars ++;
        putchar (chptr [i ++]);
　　}
</code></pre><p>　　仔细看看，发现了这样一个问题，在打印字符串的时候，实际上是打印某个地址开始的所有字符，但是当你想把整数当字符串打印的时候，这个整数被当成了一个地址，然后printf从这个地址开始去打印字符，直到某个位置上的值为\0。所以，如果这个整数代表的地址不存在或者不可访问，自然也是访问了不该访问的内存——segmentation fault。<br>　　类似的，还有诸如：sprintf等的格式控制问题，比如，试图把char型或者是int的按照%s输出或存放起来，如：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span>
<span class="keyword">char</span> c=<span class="string">'c'</span>;
<span class="keyword">int</span> i=<span class="number">10</span>;
<span class="keyword">char</span> buf[<span class="number">100</span>];
<span class="built_in">printf</span>(<span class="string">"%s"</span>, c);        <span class="comment">//试图把char型按照字符串格式输出，这里</span>
字符会解释成整数，再解释成地址，所以原因同上面那个例子
<span class="built_in">printf</span>(<span class="string">"%s"</span>, i);            <span class="comment">//试图把int型按照字符串输出</span>
<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">100</span>);
<span class="built_in">sprintf</span>(buf, <span class="string">"%s"</span>, c);    <span class="comment">//试图把char型按照字符串格式转换</span>
<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">100</span>);
<span class="built_in">sprintf</span>(buf, <span class="string">"%s"</span>, i);   <span class="comment">//试图把int型按照字符串转换</span>
</code></pre><p><strong>（6）栈溢出了，有时SIGSEGV，有时却啥都没发生</strong></p>
<p>　　大部分C语言教材都会告诉你，当从一个函数返回后，该函数栈上的内容会被自动“释放”。“释放”给大多数初学者的印象是free()，似乎这块内存不存在了，于是当他访问这块应该不存在的内存时，发现一切都好，便陷入了深深的疑惑。</p>
<h2 id="三、调试定位SIGSEGV">三、调试定位SIGSEGV</h2>
<p>　　在用C/C++语言写程序的时侯，内存管理的绝大部分工作都是需要我们来做的。实际上，内存管理是一个比较繁琐的工作，无论你多高明，经验多丰富，难免会在此处犯些小错误，而通常这些错误又是那么的浅显而易于消除。但是手工“除虫”（debug），往往是效率低下且让人厌烦的，使用gdb来快速定位这些”段错误”的语句。其实还有很多其他的方法。对于一些大型一点的程序，如何跟踪并找到程序中的段错误位置就是需要掌握的一门技巧拉。</p>
<p>　　1）在程序内部的关键部位输出(printf)信息，那样可以跟踪段错误在代码中可能的位置</p>
<p>　　为了方便使用这种调试方法，可以用条件编译指令#ifdef DEBUG和#endif把printf函数给包含起来，编译的时候加上-DDEBUG参数就可以查看调试信息。反之，不加上该参数进行调试就可以。</p>
<p>　　2）用gdb来调试，在运行到段错误的地方，会自动停下来并显示出错的行和行号<br>　　这个应该是很常用的，如果需要用gdb调试，记得在编译的时候加上-g参数，用来显示调试信息。gcc应该都有安装的。</p>
<p>　　首先安装gdb: sudo aot-get install gdb</p>
<p>下面是对某个小程序的的调试过程截图：</p>
<p>　　运行gcc的时候加上-g这个参数查看调试信息，</p>
<p>　　l：(list)显示我们的源代码</p>
<p>　　b 行号：在相应的行上设置断点，我在第六行设置</p>
<p>　　r : run 运行程序至断点</p>
<p>　　p：p(print)打印变量的值</p>
<p>　　n：n(next)执行下一步 出现错误信息了</p>
<p>　　c : continue 继续执行</p>
<p>　　quit ： 退出gdb</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20150508103418.jpg" alt="ｇｃｃ"><br><img src="http://7te8s4.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20150508103445.jpg" alt="ggc"></p>
<p>防止segmentation fault的出现就要注意：</p>
<p>　　1、定义了指针后记得初始化，在使用的时候记得判断是否为NULL<br>　　2、在使用数组的时候是否被初始化，数组下标是否越界，数组元素是否存在等<br>　　3、在变量处理的时候变量的格式控制是否合理等</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　最近在项目上遇到了Segmentation Fault的错误，一直调试不出来是哪里出了问题，对于刚接触嵌入式的，也不知道该如何去调试一个项目，定位内存问题，纠结了好几天，好阿红整理下自己的思路。从头开始。</p>
<p>　　以下内容只为整理来自己使用的，大多来源于网络，]]>
    </summary>
    
      <category term="Linux" scheme="http://silencewt.github.io/tags/Linux/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="Linux" scheme="http://silencewt.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[纪念汪国真--那些曾经伴我度过岁月的诗]]></title>
    <link href="http://silencewt.github.io/2015/04/29/%E7%BA%AA%E5%BF%B5%E6%B1%AA%E5%9B%BD%E7%9C%9F-%E9%82%A3%E4%BA%9B%E6%9B%BE%E7%BB%8F%E4%BC%B4%E6%88%91%E5%BA%A6%E8%BF%87%E5%B2%81%E6%9C%88%E7%9A%84%E8%AF%97/"/>
    <id>http://silencewt.github.io/2015/04/29/纪念汪国真-那些曾经伴我度过岁月的诗/</id>
    <published>2015-04-29T12:16:16.000Z</published>
    <updated>2015-04-29T12:21:45.000Z</updated>
    <content type="html"><![CDATA[<p>我不是一个文艺女，但确确实实喜欢着一些现代诗人，一些诗，比如汪国真、比如海子、比如戴望舒。我喜欢诗里的意境，喜欢诗里的情怀。对于他们可能我了解的也不是很多，但是他们的某一首诗却深深地印在我的那海里。前几天看到汪国真去世的消息，着实让我小小的伤感了一下，忽然就翻起了以前的笔记本，本子上密密麻麻的都是手抄的各种现代诗。看了一眼电脑右上角的座右铭：既然选择远方，便只顾风雨兼程。感谢汪老的诗激励着我，伴我走过一个又一个的低潮，给我力量。感谢海子的诗给我春暖花开，给我幸福。</p>
<hr>
<p><strong>热爱生命</strong>   —汪国真</p>
<p>我不去想，<br>是否能够成功 ，<br>既然选择了远方 ，<br>便只顾风雨兼程。<br>我不去想，<br>能否赢得爱情 ，<br>既然钟情于玫瑰 ，<br>就勇敢地吐露真诚 。<br>我不去想，<br>身后会不会袭来寒风冷雨 ，<br>既然目标是地平线，<br>留给世界的只能是背影 。<br>我不去想，<br>未来是平坦还是泥泞 ，<br>只要热爱生命 ，<br>一切，都在意料之中。</p>
<h2><img src="http://7te8s4.com1.z0.glb.clouddn.com/reai.jpg" alt="热爱生命"></h2>
<p><strong>面朝大海，春暖花开</strong>  —海子</p>
<p>从明天起，做一个幸福的人<br>喂马、劈柴，周游世界<br>从明天起，关心粮食和蔬菜<br>我有一所房子，面朝大海，春暖花开<br>从明天起，和每一个亲人通信<br>告诉他们我的幸福<br>那幸福的闪电告诉我的<br>我将告诉每一个人<br>给每一条河每一座山取一个温暖的名字<br>陌生人，我也为你祝福<br>愿你有一个灿烂的前程<br>愿你有情人终成眷属<br>愿你在尘世获得幸福<br>我只愿面朝大海，春暖花开</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/haizi.jpg" alt="海"></p>
<hr>
<p><strong>再别康桥</strong>  —徐志摩</p>
<p>轻轻的我走了，<br>正如我轻轻的来；<br>我轻轻的招手，<br>作别西天的云彩。</p>
<p>那河畔的金柳，<br>是夕阳中的新娘；<br>波光里的艳影，<br>在我的心头荡漾。</p>
<p>软泥上的青荇，<br>油油的在水底招摇；<br>在康河的柔波里，<br>甘心做一条水草！</p>
<p>那榆荫下的一潭，<br>不是清泉，是天上虹；<br>揉碎在浮藻间，<br>沉淀着彩虹似的梦。</p>
<p>寻梦？撑一支长篙，<br>向青草更青处漫溯；<br>满载一船星辉，<br>在星辉斑斓里放歌。</p>
<p>但我不能放歌，<br>悄悄是别离的笙箫；<br>夏虫也为我沉默，<br>沉默是今晚的康桥！</p>
<p>悄悄的我走了，<br>正如我悄悄的来；<br>我挥一挥衣袖，<br>不带走一片云彩。</p>
<h2 id="-1"><img src="http://7te8s4.com1.z0.glb.clouddn.com/xuzhimo.jpg" alt="康桥"></h2>
<p>愿生活美好，世界和平</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我不是一个文艺女，但确确实实喜欢着一些现代诗人，一些诗，比如汪国真、比如海子、比如戴望舒。我喜欢诗里的意境，喜欢诗里的情怀。对于他们可能我了解的也不是很多，但是他们的某一首诗却深深地印在我的那海里。前几天看到汪国真去世的消息，着实让我小小的伤感了一下，忽然就翻起了以前的笔记]]>
    </summary>
    
      <category term="生活感悟" scheme="http://silencewt.github.io/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
      <category term="生活感悟" scheme="http://silencewt.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gcc编译代码报错及编译方式]]></title>
    <link href="http://silencewt.github.io/2015/04/29/gcc%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99%E5%8F%8A%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F/"/>
    <id>http://silencewt.github.io/2015/04/29/gcc编译代码报错及编译方式/</id>
    <published>2015-04-29T12:16:02.000Z</published>
    <updated>2015-04-29T12:30:16.000Z</updated>
    <content type="html"><![CDATA[<p>一、error: ‘for’ loop initial declarations are only allowed in C99 mode</p>
<p>前段时间写了一个小C程序，放在linux下用gcc编译出错，弹</p>
<p>出以下错误：</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/c99.jpg" alt="c99"></p>
<p>百度后才知道，是gcc的模式问题。</p>
<p>我在for循环里习惯直接定义并</p>
<p>初始化变量来使用：</p>
<pre><code><span class="keyword">for</span>（int <span class="built_in">i</span>=<span class="number">0</span>；<span class="built_in">i</span>&lt;<span class="built_in">length</span>； <span class="built_in">i</span>++）
</code></pre><p>而在gcc编译时是错误的，应该在循环外定义变量：</p>
<pre><code>int <span class="built_in">i</span>;
<span class="keyword">for</span>（<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span>&lt;<span class="built_in">length</span>; <span class="built_in">i</span>++）
</code></pre><p>这样才编译通过。</p>
<p>这是因为gcc基于c89标准，换成C99标准就可以在for循环内定义i变量了。</p>
<p>如果一定要在for循环语句里定</p>
<p>义并初始化，可以将文件按照下面的方式编译就会通过了：</p>
<pre><code><span class="attribute">gcc src.c -std</span>=<span class="string">c99 -o src</span>
</code></pre><h2 id="二、gcc编译C文件">二、gcc编译C文件</h2>
<p>常用编译命令选项<br>假设源程序文件名为test.c。</p>
<p><strong>1. 无选项编译链接</strong><br>用法：#gcc test.c<br>作用：将test.c预处理、汇编、编译并链接形成可执行文件。这里未</p>
<p>指定输出文件，默认输出为a.out。</p>
<p><strong>2. 选项 -o</strong><br>用法：#gcc test.c -o test<br>作用：将test.c预处理、汇编、编译并链接形成可执行文件</p>
<p>test。-o选项用来指定输出文件的文件名。</p>
<p><strong>3. 选项 -E</strong><br>用法：#gcc -E test.c -o test.i<br>作用：将test.c预处理输出test.i文件。</p>
<p><strong>4. 选项 -S</strong><br>用法：#gcc -S test.i<br>作用：将预处理输出文件test.i汇编成test.s文件。</p>
<p><strong>5. 选项 -c</strong><br>用法：#gcc -c test.s<br>作用：将汇编输出文件test.s编译输出test.o文件。</p>
<p><strong>6. 无选项链接</strong><br>用法：#gcc test.o -o test<br>作用：将编译输出文件test.o链接成最终可执行文件test。</p>
<p><strong>7. 选项-O</strong><br>用法：#gcc -O1 test.c -o test<br>作用：使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。</p>
<p><strong>多源文件的编译方法</strong></p>
<p>如果有多个源文件，基本上有两种编译方法：<br>假设有两个源文件为a.c和b.c，b.h，在a.c文件里调用b.c的函数</p>
<p><strong>1. 多个文件一起编译</strong><br>用法：#gcc b.c a.c -o a<br>作用：将testfun.c和test.c分别编译后链接成test可执行文件。</p>
<p><strong>2. 分别编译各个源文件，之后对编译后输出的目标文件链接。</strong><br>用法：</p>
<pre><code>#gcc -<span class="built_in">c</span> b.<span class="built_in">c</span> <span class="comment">//将b.c编译成b.o</span>
#gcc -<span class="built_in">c</span> a.<span class="built_in">c</span> <span class="comment">//将a.c编译成a.o</span>
#gcc -o b.o a.o -o a <span class="comment">//将b.o和a.o链接成a</span>
</code></pre><p>以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，</p>
<p>未修改的文件不用重新编译。</p>
<ol>
<li>如果要编译的文件都在同一个目录下，可以用通配符gcc *.c -o 来进行编译。</li>
</ol>
<p>如果是有成千上万的项目文件，可以把上述的编译过程写进以下一个文本文件中：<br>Linux下称之为makefile</p>
<p>感谢各位网友的分享，仅作总结学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一、error: ‘for’ loop initial declarations are only allowed in C99 mode</p>
<p>前段时间写了一个小C程序，放在linux下用gcc编译出错，弹</p>
<p>出以下错误：</p>
<p><img sr]]>
    </summary>
    
      <category term="Linux" scheme="http://silencewt.github.io/tags/Linux/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="Linux" scheme="http://silencewt.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[YUV到RGB的转换]]></title>
    <link href="http://silencewt.github.io/2015/04/29/YUV%E5%88%B0RGB%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://silencewt.github.io/2015/04/29/YUV到RGB的转换/</id>
    <published>2015-04-29T12:12:31.000Z</published>
    <updated>2015-04-29T12:15:01.000Z</updated>
    <content type="html"><![CDATA[<p>以下内容来源于网络，下面三个链接里的内容是比较好的，感谢博主的分享。</p>
<p><a href="http://blog.csdn.net/housisong/article/details/1859084" target="_blank" rel="external">http://blog.csdn.net/housisong/article/details/1859084</a><br><a href="http://blog.csdn.net/tommy_wxie/article/details/37909643" target="_blank" rel="external">http://blog.csdn.net/tommy_wxie/article/details/37909643</a><br><a href="http://www.cnblogs.com/qinjunni/archive/2012/04/06/2434393.html" target="_blank" rel="external">http://www.cnblogs.com/qinjunni/archive/2012/04/06/2434393.html</a>   这里有介绍YUV转RGB的优化 位运算和查表法</p>
<hr>
<hr>
<p>YUV到RGB的转换公式：网上收集到的各种公式</p>
<p>  RGB颜色空间到YUV颜色空间的转换公式:</p>
<pre><code>Y= 0.256788<span class="keyword">*</span>R + 0.504129<span class="keyword">*</span>G + 0.097906<span class="keyword">*</span>B +  16;
U=-0.148223<span class="keyword">*</span>R - 0.290993<span class="keyword">*</span>G + 0.439216<span class="keyword">*</span>B + 128;
V= 0.439216<span class="keyword">*</span>R - 0.367788<span class="keyword">*</span>G - 0.071427<span class="keyword">*</span>B + 128;
</code></pre><p>（以下装换关系来自网络，本质都是一样的）</p>
<p>   YUV颜色空间到RGB颜色空间的转换公式:  （给的示例中用的是这个）</p>
<pre><code>B= 1.164383 <span class="keyword">*</span> (Y - 16) + 2.017232<span class="keyword">*</span>(U - 128);
G= 1.164383 <span class="keyword">*</span> (Y - 16) - 0.391762<span class="keyword">*</span>(U - 128) - 0.812968<span class="keyword">*</span>(V - 128);
R= 1.164383 <span class="keyword">*</span> (Y - 16) + 1.596027<span class="keyword">*</span>(V - 128);
</code></pre><p>另一种转换关系：// 转换公式(浮点方式) </p>
<pre><code>R = Y + 1.4075<span class="keyword">*</span>(V-128) 
G = Y - 0.3455<span class="keyword">*</span>(U-128) - 0.7169<span class="keyword">*</span>(V-128) 
B = Y + 1.779<span class="keyword">*</span>(U-128) 
</code></pre><p>( 补充: 在视频格式中基本上都用的上面的转换公式；但在其他一些地方可能会使用下面的转换公式(不同的使用场合可能有不同的转换系数):</p>
<pre><code>Y =  0.299<span class="keyword">*</span>R + 0.587<span class="keyword">*</span>G + 0.114<span class="keyword">*</span>B;
U = -0.147<span class="keyword">*</span>R - 0.289<span class="keyword">*</span>G + 0.436<span class="keyword">*</span>B;
V =  0.615<span class="keyword">*</span>R - 0.515<span class="keyword">*</span>G - 0.100<span class="keyword">*</span>B;

R = Y + 1.14<span class="keyword">*</span>V;
G = Y - 0.39<span class="keyword">*</span>U - 0.58<span class="keyword">*</span>V;
B = Y + 2.03<span class="keyword">*</span>U;
</code></pre><p>RGB to YUV Conversion</p>
<pre><code>Y  =   (0.257 <span class="keyword">*</span> R) + (0.504 <span class="keyword">*</span> G) + (0.098 <span class="keyword">*</span> B) + 16
Cr = V =  (0.439 <span class="keyword">*</span> R) - (0.368 <span class="keyword">*</span> G) - (0.071 <span class="keyword">*</span> B) + 128
Cb = U = -(0.148 <span class="keyword">*</span> R) - (0.291 <span class="keyword">*</span> G) + (0.439 <span class="keyword">*</span> B) + 128
</code></pre><p>YUV to RGB Conversion</p>
<pre><code><span class="constant">B</span> = <span class="number">1.164</span>(Y - <span class="number">16</span>) + <span class="number">2.018</span>(U - <span class="number">128</span>)
<span class="constant">G</span> = <span class="number">1.164</span>(Y - <span class="number">16</span>) - <span class="number">0.813</span>(V - <span class="number">128</span>) - <span class="number">0.391</span>(U - <span class="number">128</span>)
<span class="constant">R</span> = <span class="number">1.164</span>(Y - <span class="number">16</span>) + <span class="number">1.596</span>(V - <span class="number">128</span>)
</code></pre><p>　　无论是YUV444、YUV422、还是YUV420格式，根据对应的方法提取完YUV并转换为RGB数据后，其文件大小应该是： 图像的高 <em> 图像的宽 </em> 3 。由于不同的YUV码流转换为RGB数据的提取方式均不相同<br>我们知道YUYV视频格式的内存数据布局图示:</p>
<p><img src="http://7te8s4.com1.z0.glb.clouddn.com/yuv.jpg" alt="ＹＵＶ"></p>
<p>　　图中可以看出Y的数据量是U或者V的两倍，这是因为人的眼睛一般对亮度比对颜色更敏感一些，所以将连续的两个像素的U(或V)值只保存一个U(或V)值,那么每个<br>像素平均占用16bit储存空间。</p>
<p>项目中使用到的YUV转RGB格式代码：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> YUV2RGB(<span class="keyword">unsigned</span> <span class="keyword">char</span> Y, <span class="keyword">unsigned</span> <span class="keyword">char</span> U, <span class="keyword">unsigned</span> <span class="keyword">char</span> V,<span class="keyword">unsigned</span> <span class="keyword">char</span> *R, <span class="keyword">unsigned</span> <span class="keyword">char</span> *G, <span class="keyword">unsigned</span> <span class="keyword">char</span> *B)
{
*R = Y + (V - <span class="number">128</span>) + ((V - <span class="number">128</span>) * <span class="number">103</span> &gt;&gt; <span class="number">8</span>);
*G = Y - ((U - <span class="number">128</span>) * <span class="number">88</span> &gt;&gt; <span class="number">8</span>) - ((V - <span class="number">128</span>) * <span class="number">183</span> &gt;&gt; <span class="number">8</span>);
*B = Y + (U - <span class="number">128</span>) + ((U - <span class="number">128</span>) * <span class="number">198</span> &gt;&gt; <span class="number">8</span>);
<span class="keyword">if</span> (*R &gt; <span class="number">255</span>)
    *R = <span class="number">255</span>;
<span class="keyword">if</span> (*G &gt; <span class="number">255</span>)
    *G = <span class="number">255</span>;
<span class="keyword">if</span> (*B &gt; <span class="number">255</span>)
    *B= <span class="number">255</span>;
<span class="keyword">if</span> (*R &lt; <span class="number">0</span>)
    *R = <span class="number">0</span>;
<span class="keyword">if</span> (*G &lt; <span class="number">0</span>)
    *G = <span class="number">0</span>;
<span class="keyword">if</span> (*B &lt; <span class="number">0</span>)
    *B = <span class="number">0</span>;
 }
 <span class="keyword">void</span> image_data_handle(<span class="keyword">unsigned</span> <span class="keyword">char</span> *dist, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)
 {<span class="comment">//fb_buffer,将数据写入这个内存就相当于在屏幕输出，</span>
 <span class="comment">//这里就是framebuffer和v4l2的连接处</span>
 <span class="keyword">unsigned</span> <span class="keyword">long</span> *to = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)fb_buffer;
 <span class="keyword">unsigned</span> <span class="keyword">long</span> *from = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)dist; <span class="comment">//这个内存就是存储数据的，可以在这里对数据操作</span>

<span class="keyword">unsigned</span> <span class="keyword">char</span> Y0;
<span class="keyword">unsigned</span> <span class="keyword">char</span> U0;
<span class="keyword">unsigned</span> <span class="keyword">char</span> Y1;
<span class="keyword">unsigned</span> <span class="keyword">char</span> V0;

<span class="keyword">unsigned</span> <span class="keyword">char</span> R0;
<span class="keyword">unsigned</span> <span class="keyword">char</span> G0;
<span class="keyword">unsigned</span> <span class="keyword">char</span> B0;
<span class="keyword">unsigned</span> <span class="keyword">char</span> R1;
<span class="keyword">unsigned</span> <span class="keyword">char</span> G1;
<span class="keyword">unsigned</span> <span class="keyword">char</span> B1;
<span class="comment">//  为何要除以4????</span>
size &gt;&gt;= <span class="number">2</span>;
<span class="keyword">while</span>(size--)
{    <span class="comment">//取出YUYV的值 这里是4:2:2的每个像素16位</span>
    Y0 = (*from &amp; <span class="number">0x000000FF</span>) &gt;&gt; <span class="number">0</span>;
    <span class="comment">//U0 = 128;                         //white and black</span>
    U0=(*from &amp; <span class="number">0x0000FF00</span>)&gt;&gt;<span class="number">8</span>;   <span class="comment">//colorful</span>
    Y1 = (*from &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span>;
    <span class="comment">//V0 = 128;                         //white and blcak</span>
    V0=(*from &amp; <span class="number">0xFF000000</span>)&gt;&gt;<span class="number">24</span>;  <span class="comment">//colorful</span>
    YUV2RGB(Y0, U0, V0, &amp;R0, &amp;G0, &amp;B0);
    YUV2RGB(Y1, U0, V0, &amp;R1, &amp;G1, &amp;B1);
    <span class="comment">//rgb565  16位</span>
    *to = (R0 &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">11</span> | (G0 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">5</span> | (B0 &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">0</span>;
    *to |= ((R1 &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">11</span> | (G1 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">5</span> | (B1 &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">0</span>) &lt;&lt; <span class="number">16</span>;

    from++;
    to++;
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>以下内容来源于网络，下面三个链接里的内容是比较好的，感谢博主的分享。</p>
<p><a href="http://blog.csdn.net/housisong/article/details/1859084" target="_blank" rel="external"]]>
    </summary>
    
      <category term="视频处理" scheme="http://silencewt.github.io/tags/%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[YUV和RGB格式分析]]></title>
    <link href="http://silencewt.github.io/2015/04/29/YUV%E5%92%8CRGB%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
    <id>http://silencewt.github.io/2015/04/29/YUV和RGB格式分析/</id>
    <published>2015-04-29T12:12:10.000Z</published>
    <updated>2015-04-29T12:15:33.000Z</updated>
    <content type="html"><![CDATA[<p>　　做嵌入式项目的时候，涉及到YUV视频格式到RGB图像的转换，虽然之前有接触到RGB到都是基于opencv的处理，很多东西并不需要我们过多深入的去探讨，现在需要完全抛弃现有的算法程序，需要从内存中一个字节一个字节的处理，这就涉及到各个视频格式和图片格式是如何存储的。看了网上的很多资料，一下资料帮助蛮大。</p>
<p>YUV资料整理：</p>
<p><a href="http://www.fourcc.org/yuv.php" target="_blank" rel="external">http://www.fourcc.org/yuv.php</a>    YUV和RGB的分析</p>
<p><a href="http://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html" target="_blank" rel="external">http://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html</a>  对YUV的分析</p>
<p><a href="http://ticktick.blog.51cto.com/823160/568928" target="_blank" rel="external">http://ticktick.blog.51cto.com/823160/568928</a>  显示YUV数据</p>
<p><a href="http://www.cnblogs.com/qinjunni/archive/2012/02/23/2364446.html" target="_blank" rel="external">http://www.cnblogs.com/qinjunni/archive/2012/02/23/2364446.html</a></p>
<h2 id="YUV">YUV</h2>
<p>　　做视频采集与处理，自然少不了要学会分析YUV数据。因为从采集的角度来说，一般的视频采集芯片输出的码流一般都是YUV数据流的形式，而从视频处理（例如H.264、MPEG视频编解码）的角度来说，也是在原始YUV码流进行编码和解析，所以，了解如何分析YUV数据流对于做视频领域的人而言，至关重要。YUV是指亮度参量和色度参量分开表示的像素格式，而这样分开的好处就是不但可以避免相互干扰，还可以降低色度的采样率而不会对图像质量影响太大。</p>
<p>　　人眼对色度的敏感程度要低于对亮度的敏感程度。</p>
<p>　　YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。与我们熟知的RGB类似，YUV也是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p>
<p>　　YUV码流有多种不同的格式，要分析YUV码流，就必须搞清楚你面对的到底是哪一种格式，并且必须搞清楚这种格式的YUV采样和分布情况。</p>
<p>　　YUV格式有两大类：planar和packed。<br>　　对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。<br>　　对于packed的YUV格式，每个像素点的Y,U,V是连续交叉存储的。</p>
<p><strong>1.  采样方式</strong>   </p>
<p>　　YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0，如何根据其采样格式来从码流中还原每个像素点的YUV值，因为只有正确地还原了每个像素点的YUV值，才能通过YUV与RGB的转换公式提取出每个像素点的RGB值，然后显示出来。</p>
<p>　　用三个图来直观地表示采集的方式吧，以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/yuv1.jpg" alt="ＹＵＶ１"></p>
<p>先记住下面这段话，以后提取每个像素的YUV分量会用到。</p>
<blockquote>
<p>YUV 4:4:4采样，每一个Y对应一组UV分量，每像素32位</p>
<p>YUV 4:2:2采样，每两个Y共用一组UV分量，每像素16位</p>
<p>YUV 4:2:0采样，每四个Y共用一组UV分量，每像素16位</p>
</blockquote>
<p>　　平常所讲的YUV A:B:C的意思一般是指基于4个象素来讲,其中Y采样了A次，U采样了B次,V采样了C次. </p>
<p>　　YUV 格式可以分为打包格式packed format和平面格式planar format。打包格式将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素（macro-pixel）；而平面格使用三个数组分开存放YUV三个分量，就像是一个三维平面一样。Packed format和planner format的区别在于，packed format中的YUV是混合在一起的，因此就有了UYVY、YUYV等等，他们在码流中排列的方式有所不同。而对于planner format每一个Y分量，U分量和V分量都是以独立的平面组织的，也就是说所有的U分量都在Y分量之后出现，而V分量在所有的U分量之后。就像三个大色块一样。</p>
<p><strong>2.  存储方式</strong></p>
<p>　　下面用图的形式给出常见的YUV码流的存储方式，并在存储方式后面附有取样每个像素点的YUV数据的方法，其中，Cb、Cr的含义等同于U、V。因为我们在实验中芷使用到YUV422的格式，这里只介绍这个，其他的可以去其他博文了找。</p>
<p>（1） YUYV 格式 （属于YUV422）<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/yuv2.jpg" alt="ＹＵＶ２"></p>
<p>　　YUYV（YUY2）为YUV422采样的存储格式中的一种，相邻的两个Y共用其相邻的两个Cb（U）、Cr（V），分析，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00，其他的像素点的YUV取值依次类推。YVYU（YVY2）也一样，只是ＵＶ的位置调换了一下，先V后U。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/yuyv.jpg" alt="yuyv"></p>
<p>（2） UYVY 格式 （属于YUV422）<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/yuv3.jpg" alt="yuv3"></p>
<p> UYVY格式也是YUV422采样的存储格式中的一种，只不过与YUYV不同的是UV的排列顺序不一样而已，还原其每个像素点的YUV值的方法与上面一样。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/uyvy.jpg" alt="uyuv"></p>
<p>（3） YUV422P（属于YUV422）<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/yuv4.jpg" alt="yuv4"></p>
<p>　　YUV422P也属于YUV422的一种，它是一种Plane模式，即打包模式，并不是将YUV数据交错存储，而是先存放所有的Y分量，然后存储所有的U（Cb）分量，最后存储所有的V（Cr）分量，如上图所示。其每一个像素点的YUV值提取方法也是遵循YUV422格式的最基本提取方法，即两个Y共用一个UV。比如，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00。</p>
<p>　　以YUV420 planar数据为例， 以720×480大小图象YUV420 planar为例，</p>
<p>　　其存储格式是： 共大小为(720×480×3&gt;&gt;1)字节，</p>
<p>　　分为三个部分:Y,U和V</p>
<p>　　Y分量：    (720×480)个字节  </p>
<p>　　U(Cb)分量：(720×480&gt;&gt;2)个字节</p>
<p>　　V(Cr)分量：(720×480&gt;&gt;2)个字节</p>
<p>　　三个部分内部均是行优先存储，三个部分之间是Y,U,V 顺序存储。</p>
<p>　　即YUV数据的0－－720×480字节是Y分量值，         </p>
<p>　　720×480－－720×480×5/4字节是U分量    </p>
<p>　　720×480×5/4 －－720×480×3/2字节是V分量。</p>
<p>　　这里Y分量其实就是我们常说的灰度值，所以需要对图片进行灰度处理的话，可以直接提取出图片的Y分量。这点对我们后面的处理很重要。</p>
<p><strong>YUV4:4:4</strong>  </p>
<p>下面的四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]<br>存放的码流为: Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3<br>映射出像素点保持原样</p>
<p><strong>YUV4:2:2</strong></p>
<p>每个色差信道的抽样率是亮度信道的一半，所以水平方向的色度抽样率只是4:4:4的一半。对非压缩的8比特量化的图像来说，每个由两个水平方向相邻的像素组成的宏像素需要占用4字节内存。  </p>
<p>下面的四个像素为：[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]<br>存放的码流为：Y0 U0 Y1 V1 Y2 U2 Y3 V3<br>映射出像素点为：[Y0 U0 V1] [Y1 U0 V1] [Y2 U2 V3] [Y3 U2 V3]</p>
<p><strong>YUV 4:1:1</strong> </p>
<p>4:1:1的色度抽样，是在水平方向上对色度进行4:1抽样。对于低端用户和消费类产品这仍然是可以接受的。对非压缩的8比特量化的视频来说，每个由4个水平方向相邻的像素组成的宏像素需要占用6字节内存。  </p>
<p>原来四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]<br>存放的码流为: Y0 U0 Y1 Y2 V2 Y3<br>还原出像素点为：[Y0 U0 V2] [Y1 U0 V2] [Y2 U0 V2] [Y3 U0 V2] </p>
<p>用6个YUV分量描述了原来的12个YUV分量，因此压缩比为1/2，平均来讲，就是用了12bit表示了一个象素点，原来YUV(8bit*3)是24bit。 </p>
<p><strong>YUV4:2:0</strong><br>　　4:2:0并不意味着只有Y，Cb而没有Cr分量。它指得是对每行扫描线来说，只有一种色度分量以2:1的抽样率存储。相邻的扫描行存储不同的色度分 量，也就是说，如果一行是4:2:0的话，下一行就是4:0:2，再下一行是4:2:0…以此类推。对每个色度分量来说，水平方向和竖直方向的抽样率 都是2:1，所以可以说色度的抽样率是4:1。对非压缩的8比特量化的视频来说，每个由2x2个2行2列相邻的像素组成的宏像素需要占用6字节内存。<br>　　<br>下面八个像素为：[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3] [Y5 U5 V5] [Y6 U6 V6] [Y7U7 V7] [Y8 U8 V8]<br>存放的码流为：Y0 U0 Y1 Y2 U2 Y3 Y5 V5 Y6 Y7 V7 Y8<br>映射出的像素点为：[Y0 U0 V5] [Y1 U0 V5] [Y2 U2 V7] [Y3 U2 V7] [Y5 U0 V5] [Y6 U0 V5] [Y7U2 V7] [Y8 U2 V7] </p>
<h2 id="RGB">RGB</h2>
<p>　　计算机彩色显示器显示色彩的原理与彩色电视机一样，都是采用R（Red）、G（Green）、B（Blue）相加混色的原理：通过发射出三种不同强度的电子束，使屏幕内侧覆盖的红、绿、蓝磷光材料发光而产生色彩。这种色彩的表示方法称为RGB色彩空间表示（它也是多媒体计算机技术中用得最 多的一种色彩空间表示方法）。根据色度学的介绍，不同波长的单色光会引起不同的彩色感觉，但相同的彩色感觉却可以来源于不同的光谱成分组合。自然界中几乎所有的颜色都能用三种基本彩色混合配出，在彩色电视技术中选择红色、绿色、和蓝色作为三基色。其他的颜色都可以用红色、绿色和蓝色按照不同的比例混合而成。所选取的红色、绿色和蓝色三基色空间。简称为RGB颜色空间。</p>
<blockquote>
<p>RGB565    每个像素用16位表示，RGB分量分别使用5位、6位、5位</p>
<p>RGB555    每个像素用16位表示，RGB分量都使用5位（剩下1位不用）</p>
<p>RGB24    每个像素用24位表示，RGB分量各使用8位</p>
<p>RGB32    每个像素用32位表示，RGB分量各使用8位（剩下8位不用）</p>
<p>ARGB32    每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）</p>
</blockquote>
<p><strong>RGB565</strong>（我们使用的格式）</p>
<p>使用16位表示一个像素，这16位中的5位用于R，6位用于G，5位用于B。</p>
<p>程序中通常使用一个字（WORD，一个字等于两个字节）来操作一个像素。当读出一个像素后，这个字的各个位意义如下：      </p>
<p>高字节              低字节 </p>
<p>R R R R R G G G     G G G B B B B B </p>
<p>可以组合使用屏蔽字和移位操作来得到RGB各分量的值：  </p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> RGB565_MASK_RED    0xF800 </span>
<span class="preprocessor">#<span class="keyword">define</span> RGB565_MASK_GREEN  0x07E0 </span>
<span class="preprocessor">#<span class="keyword">define</span> RGB565_MASK_BLUE   0x001F </span>
R = (wPixel &amp; RGB565_MASK_RED) &gt;&gt; <span class="number">11</span>;   <span class="comment">// 取值范围0-31 </span>
G = (wPixel &amp; RGB565_MASK_GREEN) &gt;&gt; <span class="number">5</span>;  <span class="comment">// 取值范围0-63 </span>
B =  wPixel &amp; RGB565_MASK_BLUE;         <span class="comment">// 取值范围0-31</span>
<span class="preprocessor">#<span class="keyword">define</span> RGB(r,g,b) (unsigned int)( (r|0x08 &lt;&lt; 11) | (g|0x08 &lt;&lt; 6) | b|0x08 )</span>
<span class="preprocessor">#<span class="keyword">define</span> RGB(r,g,b) (unsigned int)( (r|0x08 &lt;&lt; 10) | (g|0x08 &lt;&lt; 5) | b|0x08 )</span>
</code></pre><p>该代码可以解决24位与16位相互转换的问题</p>
<p><strong>RGB555</strong></p>
<p>是另一种16位的RGB格式，RGB分量都用5位表示（剩下的1位不用）。</p>
<p>使用一个字读出一个像素后，这个字的各个位意义如下：     </p>
<p> 高字节             低字节 </p>
<p>X R R R R G G       G G G B B B B B       （X表示不用，可以忽略）  </p>
<p>RGB24使用24位来表示一个像素，RGB分量都用8位表示，取值范围为0-255 </p>
<p>RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位不用</p>
<p><strong>RGB24</strong><br>　　RGB24使用24位来表示一个像素，RGB分量都用8位表示，取值范围为0-255。注意在内存中RGB各分量的排列顺序为：BGR BGR BGR…。通常可以使用RGBTRIPLE数据结构来操作一个像素，它的定义为：</p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBTRIPLE</span> </span>{
    BYTE rgbtBlue; <span class="comment">// 蓝色分量</span>
    BYTE rgbtGreen; <span class="comment">// 绿色分量</span>
    BYTE rgbtRed; <span class="comment">// 红色分量</span>
} RGBTRIPLE;
</code></pre><p><strong>RGB32</strong><br>　　RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha通道或者不用。（ARGB32就是带Alpha通道的RGB24。）注意在内存中RGB各分量的排列顺序为：BGRA BGRA BGRA…。通常可以使用RGBQUAD数据结构来操作一个像素，它的定义为：</p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> </span>{
    BYTE rgbBlue; <span class="comment">// 蓝色分量</span>
    BYTE rgbGreen; <span class="comment">// 绿色分量</span>
    BYTE rgbRed; <span class="comment">// 红色分</span>
    BYTE rgbReserved; <span class="comment">// 保留字节（用作Alpha通道或忽略）</span>
} RGBQUAD。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>　　做嵌入式项目的时候，涉及到YUV视频格式到RGB图像的转换，虽然之前有接触到RGB到都是基于opencv的处理，很多东西并不需要我们过多深入的去探讨，现在需要完全抛弃现有的算法程序，需要从内存中一个字节一个字节的处理，这就涉及到各个视频格式和图片格式是如何存储的。看了网]]>
    </summary>
    
      <category term="视频处理" scheme="http://silencewt.github.io/tags/%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[v4l2的学习建议和流程解析]]></title>
    <link href="http://silencewt.github.io/2015/04/29/v4l2%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE%E5%92%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://silencewt.github.io/2015/04/29/v4l2的学习建议和流程解析/</id>
    <published>2015-04-29T12:11:52.000Z</published>
    <updated>2015-04-29T12:14:10.000Z</updated>
    <content type="html"><![CDATA[<p>　　v4l2，一开始听到这个名词的时候，以为又是一个很难很难的模块，涉及到视频的处理，后来在网上各种找资料后，才发现其实v4l2已经分装好了驱动程序，只要我们根据需要调用相应的接口和函数，从而实现视频的获取和处理。只要认真的看几篇文章就对v4l2有一定的了解了，由于是第一次接触，网上的资料良莠不齐，难得可以找到几篇自己感觉很不错的。记录下来：（没必要看太多，很多都是一样的意思）<br>这里的格式可能有点乱，可以到博客园去看：<br><a href="http://www.cnblogs.com/silence-hust/p/4464291.html" target="_blank" rel="external">http://www.cnblogs.com/silence-hust/p/4464291.html</a>   本人博客整理的</p>
<p><a href="http://www.embedu.org/Column/Column320.htm" target="_blank" rel="external">http://www.embedu.org/Column/Column320.htm</a>   这篇是不错的介绍，很讨厌有弹窗<br><a href="http://www.cnblogs.com/emouse/archive/2013/03/04/2943243.html" target="_blank" rel="external">http://www.cnblogs.com/emouse/archive/2013/03/04/2943243.html</a>  这个可以作为第一篇来看，博主整理的不错<br><a href="http://blog.chinaunix.net/uid-11765716-id-2855735.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-11765716-id-2855735.html</a>    这篇也比较详细<br><a href="http://blog.csdn.net/ddddwant/article/details/8475211" target="_blank" rel="external">http://blog.csdn.net/ddddwant/article/details/8475211</a>   这篇提到的问题和我遇到的一样，花屏了，内存没有读取好<br><a href="http://my.oschina.net/u/1024767/blog/210801#OSC_h2_14" target="_blank" rel="external">http://my.oschina.net/u/1024767/blog/210801#OSC_h2_14</a>    对capture.c文件的解读<br><a href="http://blog.csdn.net/g_salamander/article/details/8107692" target="_blank" rel="external">http://blog.csdn.net/g_salamander/article/details/8107692</a>    对各个结构体有比较好的说明</p>
<h4 id="一、Video_for_Linux_two">一、Video for Linux two</h4>
<p>　　v4l2为linux下视频设备程序提供了一套接口规范。包括一套数据结构和底层V4L2驱动接口。只能在linux下使用。它使程序有发现设备和操作设备的能力。它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。当然也可以用于其他多媒体的开发，如音频等。</p>
<p>　　在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文是/dev/v4l/video0。为了通用，可以建立一个到/dev/video0的链接。V4L2支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)。V4L2在include/linux/videodev.h文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。V4L2从Linux 2.5.x版本的内核中开始出现。</p>
<p>　　V4L2规范中不仅定义了通用API元素(Common API Elements)，图像的格式(Image Formats)，输入/输出方法(Input/Output)，还定义了Linux内核驱动处理视频信息的一系列接口(Interfaces)，这些接口主要有：</p>
<p>　　视频采集接口——Video Capture Interface;</p>
<p>　　视频输出接口—— Video Output Interface;</p>
<p>　　视频覆盖/预览接口——Video Overlay Interface;</p>
<p>　　视频输出覆盖接口——Video Output Overlay Interface;</p>
<p>　　编解码接口——Codec Interface。</p>
<h4 id="二、v4l2结构体介绍">二、v4l2结构体介绍</h4>
<p>1、常用的结构体在内核目录include/linux/videodev2.h中定义</p>
<p>  struct v4l2_requestbuffers        //申请帧缓冲，对应命令VIDIOC_REQBUFS<br>        struct v4l2_capability        //视频设备的功能，对应命令VIDIOC_QUERYCAP<br>        struct v4l2_input        //视频输入信息，对应命令VIDIOC_ENUMINPUT<br>        struct v4l2_standard        //视频的制式，比如PAL，NTSC，对应命令VIDIOC_ENUMSTD<br>        struct v4l2_format        //帧的格式，对应命令VIDIOC_G_FMT、VIDIOC_S_FMT等<br>        struct v4l2_buffer        //驱动中的一帧图像缓存，对应命令VIDIOC_QUERYBUF<br>        struct v4l2_crop        //视频信号矩形边框<br>        v4l2_std_id        //视频制式</p>
<p>常用结构体的内容：</p>
<pre><code><span class="keyword">struct</span> v4l2_capability{
    <span class="keyword">u8</span> driver[<span class="number">16</span>]; <span class="comment">// 驱动名字</span>
    <span class="keyword">u8</span> card[<span class="number">32</span>]; <span class="comment">// 设备名字</span>
    <span class="keyword">u8</span> bus_info[<span class="number">32</span>]; <span class="comment">// 设备在系统中的位置</span>
    <span class="keyword">u32</span> version; <span class="comment">// 驱动版本号</span>
    <span class="keyword">u32</span> capabilities; <span class="comment">// 设备支持的操作</span>
    <span class="keyword">u32</span> reserved[<span class="number">4</span>]; <span class="comment">// 保留字段</span>
};
</code></pre><p>　其中域 capabilities 代表设备支持的操作模式，常见的值有V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING 表示是一个视频捕捉设备并且具有数据流控制模式；另外 driver 域需要和 struct video_device 中的 name 匹配。</p>
<pre><code><span class="keyword">struct</span> v4l2_format { 
<span class="keyword">enum</span> v4l2_buf_type type; 
<span class="keyword">union</span> { 
    <span class="keyword">struct</span> v4l2_pix_format pix;     <span class="comment">/*V4L2_BUF_TYPE_VIDEO_CAPTURE */</span> 
    <span class="keyword">struct</span> v4l2_window             win;     <span class="comment">/* V4L2_BUF_TYPE_VIDEO_OVERLAY */</span> 
    <span class="keyword">struct</span> v4l2_vbi_format         vbi;     <span class="comment">/* V4L2_BUF_TYPE_VBI_CAPTURE */</span> 
    <span class="keyword">struct</span> v4l2_sliced_vbi_format  sliced;  <span class="comment">/* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */</span> 
    __u8   raw_data[<span class="number">200</span>];                   <span class="comment">/* user-defined */</span> 
} fmt; 
}; 
<span class="keyword">enum</span> v4l2_buf_type { 
V4L2_BUF_TYPE_VIDEO_CAPTURE        = <span class="number">1</span>, 
V4L2_BUF_TYPE_VIDEO_OUTPUT         = <span class="number">2</span>, 
V4L2_BUF_TYPE_VIDEO_OVERLAY        = <span class="number">3</span>, 
... 
V4L2_BUF_TYPE_PRIVATE              = <span class="number">0</span>x80, 
}; 
<span class="keyword">struct</span> v4l2_pix_format { 
__u32                   width; 
__u32                   height; 
__u32                   pixelformat; 
<span class="keyword">enum</span> v4l2_field         field; 
__u32                   bytesperline;   <span class="comment">/* for padding, zero if unused */</span> 
__u32                   sizeimage; 
<span class="keyword">enum</span> v4l2_colorspace    colorspace; 
__u32                   priv;           <span class="comment">/* private data, depends on pixelformat */</span> 
</code></pre><p>};</p>
<p>　　常见的捕获模式为 V4L2_BUF_TYPE_VIDEO_CAPTURE 即视频捕捉模式，在此模式下 fmt 联合体采用域 v4l2_pix_format：其中 width 为视频的宽、height 为视频的高、pixelformat 为视频数据格式（常见的值有 V4L2_PIX_FMT_YUV422P | V4L2_PIX_FMT_RGB565）、bytesperline 为一行图像占用的字节数、sizeimage 则为图像占用的总字节数、colorspace 指定设备的颜色空间.</p>
<p>struct v4l2_requestbuffers 与 VIDIOC_REQBUFS ，VIDIOC_REQBUFS 命令通过结构 v4l2_requestbuffers 请求驱动申请一片连续的内存用于缓存视频信息：</p>
<pre><code><span class="title">struct</span> v4l2_requestbuffers {
<span class="title">__u32</span>                   count;
<span class="title">enum</span> v4l2_buf_type      type;
<span class="title">enum</span> v4l2_memory        memory;
<span class="title">__u32</span>                   reserved[<span class="number">2</span>]
};
<span class="title">enum</span> v4l2_memory {
<span class="title">V4L2_MEMORY_MMAP</span>             = <span class="number">1</span>,
V4L2_MEMORY_USERPTR          = <span class="number">2</span>,
V4L2_MEMORY_OVERLAY          = <span class="number">3</span>,
};
</code></pre><p>count 指定根据图像占用空间大小申请的缓存区个数，type 为视频捕获模式，memory 为内存区的使用方式。</p>
<pre><code><span class="keyword">struct</span> v4l2_buffer {
__u32   index;
<span class="keyword">enum</span> v4l2_buf_type    type;
__u32    bytesused;
__u32    flags;
<span class="keyword">enum</span> v4l2_field  field;
<span class="keyword">struct</span> timeval    timestamp;
<span class="keyword">struct</span> v4l2_timecode   timecode;
__u32     sequence;

<span class="comment">/* memory location */</span>
<span class="keyword">enum</span> v4l2_memory    memory;
<span class="keyword">union</span> {
        __u32   offset;
        <span class="keyword">unsigned</span> <span class="keyword">long</span>   userptr;
} m;
__u32    length;
__u32    input;
__u32    reserved;
};
</code></pre><p>　　index 为缓存编号<br>　　type 为视频捕获模式<br>　　bytesused 为缓存已使用空间大小<br>　　flags 为缓存当前状态（常见值有 V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE，分别代表当前缓存已经映射、缓存可以采集数据、缓存可以提取数据）<br>　　timestamp 为时间戳<br>　　sequence为缓存序号<br>　　memory 为缓存使用方式<br>　　offset 为当前缓存与内存区起始地址的偏移<br>　　length 为缓存大小<br>　　reserved 一般用于传递物理地址值。<br>　　另外 VIDIOC_QBUF 和 VIDIOC_DQBUF 命令都采用结构 v4l2_buffer 与驱动通信：VIDIOC_QBUF 命令向驱动传递应用程序已经处理完的缓存，即将缓存加入空闲可捕获视频的队列，传递的主要参数为 index；VIDIOC_DQBUF 命令向驱动获取已经存放有视频数据的缓存，v4l2_buffer 的各个域几乎都会被更新，但主要的参数也是 index，应用程序会根据 index 确定可用数据的起始地址和范围。</p>
<p>2、常用的IOCTL接口命令也在include/linux/videodev2.h中定义</p>
<p>VIDIOC_REQBUFS //分配内存<br>       VIDIOC_QUERYBUF         //把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址<br>        VIDIOC_QUERYCAP        //查询驱动功能<br>        VIDIOC_ENUM_FMT        //获取当前驱动支持的视频格式<br>        VIDIOC_S_FMT        //设置当前驱动的频捕获格式<br>        VIDIOC_G_FMT        //读取当前驱动的频捕获格式<br>        VIDIOC_TRY_FMT        //验证当前驱动的显示格式<br>        VIDIOC_CROPCAP        //查询驱动的修剪能力<br>        VIDIOC_S_CROP        //设置视频信号的矩形边框<br>        VIDIOC_G_CROP        //读取视频信号的矩形边框<br>        VIDIOC_QBUF        //把数据从缓存中读取出来<br>        VIDIOC_DQBUF        //把数据放回缓存队列<br>        VIDIOC_STREAMON        //开始视频显示函数<br>        VIDIOC_STREAMOFF        //结束视频显示函数<br>        VIDIOC_QUERYSTD         //检查当前视频设备支持的标准，例如PAL或NTSC。</p>
<h4 id="三、调用v4l2的工作流程">三、调用v4l2的工作流程</h4>
<p>　　打开设备－&gt; 检查和设置设备属性－&gt; 设置帧格式－&gt; 设置一种输入输出方法（缓冲 区管理）－&gt; 循环获取数据－&gt; 关闭设备。</p>
<p><strong>（1）打开设备文件</strong></p>
<p>　　打开视频设备非常简单，在V4L2中，视频设备被看做一个文件。使用open函数打开这个设备：</p>
<p>　　1. 用非阻塞模式打开摄像头设备<br>　　int cameraFd;<br>　　cameraFd = open(“/dev/video0”, O_RDWR | O_NONBLOCK);<br>　　2. 如果用阻塞模式打开摄像头设备，上述代码变为：<br>　　cameraFd = open(“/dev/video0”, O_RDWR);<br>　　关于阻塞模式和非阻塞模式<br>　　应用程序能够使用阻塞模式或非阻塞模式打开视频设备，如果使用非阻塞模式调用视频设备，即使尚未捕获到信息，驱动依旧会把缓存（DQBUFF）里的东西返回给应用程序。</p>
<p><strong>（2）取得设备的capability</strong></p>
<pre><code>      <span class="keyword">struct</span> v4l2_capability capability；
      <span class="keyword">int</span> ret = ioctl(fd, VIDIOC_QUERYCAP, &amp;capability);
</code></pre><p>　　看看设备具有什么功能，比如是否具有视频输入特性。
　　</p>
<pre><code><span class="keyword">struct</span> v4l2_capability cap;
memset(&amp;cap, <span class="number">0</span>, <span class="keyword">sizeof</span>(cap));<span class="comment">/* 获取设备支持的操作 */</span>
<span class="keyword">if</span>(ioctl(dev-&gt;fd, VIDIOC_QUERYCAP, &amp;cap) &lt; <span class="number">0</span>){
<span class="keyword">if</span>(EINVAL == errno){   <span class="comment">/*EINVAL为返回的错误值*/</span>
    printf(stderr,<span class="string">"%s is no V4L2 device\n"</span>, dev-&gt;dev);
    <span class="keyword">return</span> TFAIL;
}
<span class="keyword">else</span>
{
    printf(stderr,<span class="string">"%s is not V4L2 device,unknow error\n"</span>, dev-&gt;dev);
    <span class="keyword">return</span> TFAIL;
}
}
<span class="comment">//获取成功，检查是否有视频捕获功能</span>
<span class="keyword">if</span>(!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)){
printf(stderr, <span class="string">"%s is no video capture device\n"</span>,dev-&gt;dev);
<span class="keyword">return</span> TFAIL;
}
<span class="comment">/* streaming I/O ioctls */</span>
<span class="keyword">if</span>(!(cap.capabilities &amp; V4L2_CAP_STREAMING)){
printf(stderr, <span class="string">"%s does not support streaming i/o\n"</span>,dev-&gt;dev);
<span class="keyword">return</span> TFAIL;
}
</code></pre><p><strong>（3）选择视频输入</strong></p>
<pre><code>      struct v4l2_input <span class="built_in">input</span>；
              ……初始化<span class="built_in">input</span>
              <span class="keyword">int</span> <span class="keyword">ret</span> = ioctl(fd, VIDIOC_QUERYCAP, &amp;<span class="built_in">input</span>);
</code></pre><p>　　一个视频设备可以有多个视频输入。如果只有一路输入，这个功能可以没有。</p>
<p>　　VIDIOC_G_INPUT 和 VIDIOC_S_INPUT 用来查询和选则当前的 input，一个 video 设备节点可能对应多个视频源，比如 saf7113 可以最多支持四路 cvbs 输入，如果上层想在四个cvbs视频输入间切换，那么就要调用 ioctl(fd, VIDIOC_S_INPUT, &amp;input) 来切换。VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的 video input和output的index.<br>struct v4l2_input {<br><strong>u32 index; /<em> Which input </em><br>/</strong>u8 name[32]; /<em> Label </em>/<br><strong>u32 type; /<em> Type of input </em>/
</strong>u32 audioset; /<em> Associated audios (bitfield) </em>/<br><strong>u32 tuner; /<em> Associated tuner </em>/<br>v4l2_std_id std;
</strong>u32 status;<br>__u32 reserved[4];<br>};<br><strong>（4）检测视频支持的制式</strong></p>
<pre><code>      v4l2_std_id <span class="built_in">std</span>;
              <span class="keyword">do</span> {
                      ret = ioctl(fd, VIDIOC_QUERYSTD, &amp;<span class="built_in">std</span>);
               } <span class="keyword">while</span> (ret == -<span class="number">1</span> &amp;&amp; errno == EAGAIN);
            <span class="keyword">switch</span> (<span class="built_in">std</span>) {
            <span class="keyword">case</span> V4L2_STD_NTSC: 
                            <span class="comment">//……</span>
            <span class="keyword">case</span> V4L2_STD_PAL:
                            <span class="comment">//……</span>
            }
</code></pre><p><strong>（5）设置视频捕获格式</strong></p>
<p>　　v4l2_format 结构体用来设置摄像头的视频制式、帧格式等，在设置这个参数时应先填 好 v4l2_format 的各个域，如 type（传输流类型），fmt.pix.width(宽)，fmt.pix.heigth(高)，fmt.pix.field(采样区域，如隔行采样)，fmt.pix.pixelformat(采样类型，如 YUV4:2:2)，然后通过 VIDIO_S_FMT 操作命令设置视频捕捉格式。</p>
<pre><code><span class="keyword">struct</span> v4l2_format fmt;
memset(&amp;fmt, <span class="number">0</span>, <span class="keyword">sizeof</span>(fmt));
fmt.<span class="keyword">type</span>                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.width       = g_display_width;
fmt.fmt.pix.height      = g_display_height;
fmt.fmt.pix.pixelformat = g_fmt;
fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;
<span class="comment">/* 设置设备捕获视频的格式 */</span>
<span class="keyword">if</span>(ioctl(dev-&gt;fd, VIDIOC_S_FMT, &amp;fmt) &lt; <span class="number">0</span>)
{
    printf(stderr, <span class="string">"%s iformat not supported \n"</span>,dev-&gt;dev);
    close(dev-&gt;fd);
    <span class="keyword">return</span> TFAIL;
}
</code></pre><p>　　注意：如果该视频设备驱动不支持你所设定的图像格式，视频驱动会重新修改struct v4l2_format结构体变量的值为该视频设备所支持的图像格式，所以在程序设计中，设定完所有的视频格式后，要获取实际的视频格式，要重新读取struct v4l2_format结构体变量。　</p>
<p><strong>（6）向驱动申请帧缓存</strong></p>
<p>　　一般不超过5个，CAP_BUF_NUM = 4
　　</p>
<pre><code><span class="keyword">struct</span> v4l2_requestbuffers req;<span class="comment">/* 申请设备的缓存区 */</span>
memset(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));
req.count = CAP_BUF_NUM;  <span class="comment">//申请一个拥有四个缓冲帧的缓冲区</span>
req.<span class="keyword">type</span> = V4L2_BUF_TYPE_VIDEO_CAPTURE;
req.memory = V4L2_MEMORY_MMAP;

<span class="keyword">if</span> (ioctl(dev-&gt;fd, VIDIOC_REQBUFS, &amp;req) &lt; <span class="number">0</span>)
{
    <span class="keyword">if</span> (EINVAL == errno)
    {
        printf(stderr, <span class="string">"%s does not support "</span>
                 <span class="string">"memory mapping\n"</span>, dev-&gt;dev);
        <span class="keyword">return</span> TFAIL;
    }
    <span class="keyword">else</span>
    {
        printf(stderr, <span class="string">"%s does not support "</span>
                 <span class="string">"memory mapping, unknow error\n"</span>, dev-&gt;dev);
        <span class="keyword">return</span> TFAIL;
    }
}
<span class="keyword">if</span> (req.count &lt; <span class="number">2</span>)
{
    printf(stderr, <span class="string">"Insufficient buffer memory on %s\n"</span>,
             dev-&gt;dev);
    <span class="keyword">return</span> TFAIL;
}
</code></pre><p>　　v4l2_requestbuffers结构中定义了缓存的数量，驱动会据此申请对应数量的视频缓存。多个缓存可以用于建立FIFO，来提高视频采集的效率。控制命令VIDIOC_REQBUFS       </p>
<p>功能： 请求V4L2驱动分配视频缓冲区（申请V4L2视频驱动分配内存），V4L2是视频设备的驱动层，位于内核空间，所以通过VIDIOC_REQBUFS控制命令字申请的内存位于内核空间，应用程序不能直接访问，需要通过调用mmap内存映射函数把内核空间内存映射到用户空间后，应用程序通过访问用户空间地址来访问内核空间。</p>
<p>参数说明：参数类型为V4L2的申请缓冲区数据结构体类型struct v4l2_requestbuffers  ；</p>
<p>返回值说明： 执行成功时，函数返回值为 0；V4L2驱动层分配好了视频缓冲区；</p>
<p><strong>（7）获取每个缓存的信息，并mmap到用户空间</strong></p>
<p>应用程序和设备有三种交换数据的方法，直接 read/write、内存映射(memory mapping)和用户指针。这里只讨论内存映射(memory mapping)。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> VideoBuffer {   <span class="comment">//定义一个结构体来映射每个缓冲帧</span>
                      <span class="keyword">void</span> *start;
                      size_t length;
              } VideoBuffer;
      VideoBuffer* buffers = <span class="built_in">calloc</span>( req.count, <span class="keyword">sizeof</span>(*buffers) );
      <span class="keyword">struct</span> v4l2_buffer buf;
      <span class="keyword">for</span> (numBufs = <span class="number">0</span>; numBufs &lt; req.count; numBufs++) {<span class="comment">//映射所有的缓存</span>
                      <span class="built_in">memset</span>( &amp;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf) );
                      buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                      buf.memory = V4L2_MEMORY_MMAP;
                      buf.index = numBufs;
                      <span class="keyword">if</span> (ioctl(fd, VIDIOC_QUERYBUF, &amp;buf) == -<span class="number">1</span>) {<span class="comment">//获取到对应index的缓存信息，此处主要利用length信息及offset信息来完成后面的mmap操作。</span>
                              <span class="keyword">return</span> -<span class="number">1</span>;
                      }
              buffers[numBufs].length = buf.length;
                      <span class="comment">// 转换成相对地址</span>
                      buffers[numBufs].start = mmap(NULL, buf.length,
                              PROT_READ | PROT_WRITE,
                              MAP_SHARED,
                              fd, buf.m.offset);
              <span class="keyword">if</span> (buffers[numBufs].start == MAP_FAILED) {
                              <span class="keyword">return</span> -<span class="number">1</span>;
                      }
</code></pre><p>//addr 映射起始地址，一般为NULL ，让内核自动选择<br>//length 被映射内存块的长度<br>//prot 标志映射后能否被读写，其值为PROT_EXEC,PROT_READ,PROT_WRITE, PROT_NONE<br>//flags 确定此内存映射能否被其他进程共享，MAP_SHARED,MAP_PRIVATE<br>//fd,offset, 确定被映射的内存地址 返回成功映射后的地址，不成功返回MAP_FAILED ((void<em>)-1)<br>int munmap(void </em>addr, size_t length);// 断开映射<br>//addr 为映射后的地址，length 为映射后的内存长度</p>
<p><strong>（8）开始采集视频 (在缓冲区处理好之后就可以获得视频了 )</strong><br>在开始之前，还应当把缓冲帧放入缓冲队列，应用程序和设备有三种交换数据的方法，直接 read/write、内存映射(memory mapping)和用户指针。这里只讨论内存映射(memory mapping)。</p>
<p>//把四个缓冲帧放入队列<br>   for (i = 0; i &lt; CAP<em>BUF<em>NUM; i++)<br>   {<br>       memset(&amp;buf, 0, sizeof(buf));<br>       buf.type = V4L2<em>BUF<em>TYPE_VIDEO_CAPTURE;<br>       buf.memory = V4L2_MEMORY_MMAP;<br>       buf.index = i;<br>       buf.m.offset = dev-&gt;buffer[i].offset;<br>       /<em> 将空闲的内存加入可捕获视频的队列 </em>/<br>       if(ioctl(dev-&gt;fd, VIDIOC_QBUF, &amp;buf) &lt; 0)<br>       {<br>           printf(“ERROR: VIDIOC_QBUF[%s], FUNC[%s], LINE[%d]\n”, dev-&gt;dev, __FUNCTION</em></em>, __LINE</em></em>);<br>           return TFAIL;<br>       }<br>   }</p>
<p>   type = V4L2<em>BUF<em>TYPE<em>VIDEO<em>CAPTURE;<br>   /<em> 打开设备视频流 </em>/<br>   if(ioctl(dev-&gt;fd, VIDIOC_STREAMON, &amp;type) &lt; 0)<br>   {<br>       printf(“ERROR: VIDIOC_STREAMON[%s], FUNC[%s], LINE[%d]\n”, dev-&gt;dev, __FUNCTION</em></em>, __LINE</em></em>);<br>       return TFAIL;<br>   }<br>　　前期初始化完成后，只是解决了一帧视频数据的格式和大小问题，而连续视频帧数据的采集需要用帧缓冲区队列的方式来解决，即要通过驱动程序在内存中申请几个帧缓冲区来存放视频数据。</p>
<p>　　应用程序通过API接口提供的方法(VIDIOC_REQBUFS)申请若干个视频数据的帧缓冲区，申请帧缓冲区数量一般不低于3个，每个帧缓冲区存放一帧视频数据，这些帧缓冲区在内核空间。</p>
<p>　　应用程序通过API接口提供的查询方法(VIDIOC_QUERYBUF)查询到帧缓冲区在内核空间的长度和偏移量地址。</p>
<p>　　应用程序再通过内存映射方法(mmap)，将申请到的内核空间帧缓冲区的地址映射到用户空间地址，这样就可以直接处理帧缓冲区的数据。</p>
<p>　　(1)将帧缓冲区在视频输入队列排队，并启动视频采集</p>
<p>　　在驱动程序处理视频的过程中，定义了两个队列：视频采集输入队列(incoming queues)和视频采集输出队列(outgoing queues)，前者是等待驱动存放视频数据的队列，后者是驱动程序已经放入了视频数据的队列。如图2所示。</p>
<p>　　应用程序需要将上述帧缓冲区在视频采集输入队列排队(VIDIOC_QBUF)，然后可启动视频采集。</p>
<p>　　(2)循环往复，采集连续的视频数据</p>
<p>　　启动视频采集后，驱动程序开始采集一帧数据，把采集的数据放入视频采集输入队列的第一个帧缓冲区，一帧数据采集完成，也就是第一个帧缓冲区存满一帧数据后，驱动程序将该帧缓冲区移至视频采集输出队列，等待应用程序从输出队列取出。驱动程序接下来采集下一帧数据，放入第二个帧缓冲区，同样帧缓冲区存满下一帧数据后，被放入视频采集输出队列。</p>
<p>　　应用程序从视频采集输出队列中取出含有视频数据的帧缓冲区，处理帧缓冲区中的视频数据，如存储或压缩。</p>
<p><strong>（9）取出FIFO缓存中已经采样的帧缓存</strong></p>
<pre><code>struct v4l2_buffer capture_buf；
memset(&amp;capture_buf, <span class="number">0</span>, sizeof(capture_buf));
capture_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
capture_buf.memory = V4L2_MEMORY_MMAP;
<span class="regexp">/* 将已经捕获好视频的内存拉出已捕获视频的队列 */</span>
<span class="keyword">if</span> (ioctl(dev.fd, VIDIOC_DQBUF, &amp;capture_buf) &lt; <span class="number">0</span>)
 {
   <span class="keyword">printf</span>(<span class="string">"ERROR: VIDIOC_DQBUF[<span class="variable">%s</span>], FUNC[<span class="variable">%s</span>], LINE[<span class="variable">%d</span>]\n"</span>, dev, __FUNCTION_<span class="number">_</span>, __LINE_<span class="number">_</span>);
   <span class="keyword">return</span> TFAIL;
   }
 }
 image_data_handle(buffer[capture_buf.<span class="keyword">index</span>].start, capture_buf.bytesused);
</code></pre><p><strong>（10）将刚刚处理完的缓冲重新入队列尾，这样可以循环采集</strong></p>
<pre><code>      <span class="keyword">if</span> (ioctl(fd, VIDIOC_QBUF, &amp;buf) == -<span class="number">1</span>) {
                      <span class="keyword">return</span> -<span class="number">1</span>;
              }
</code></pre><p><strong>（11）停止视频的采集，解除映射</strong></p>
<pre><code>      <span class="keyword">int</span> <span class="keyword">ret</span> = ioctl(fd, VIDIOC_STREAMOFF, &amp;buf_type);
      munmap(<span class="keyword">buffer</span>[<span class="keyword">j</span>].start, <span class="keyword">buffer</span>[<span class="keyword">j</span>].length);
</code></pre><p><strong>（12）关闭视频设备</strong></p>
<pre><code>      <span class="keyword">close</span>(fd);
</code></pre><p>　　最后这个是一般mmap形式的使用流程，还有使用read/write方式的内存读写流程，具体的可以参考官方的capture.c这个文档，程序的流程很清楚，也有相关的博文有写到。</p>
<p><strong>文字描述版流程：</strong></p>
<p>　   (1)打开视频设备文件。int fd=open(“/dev/video0”,O_RDWR);</p>
<p>　　(2)查询视频设备的能力，比如是否具有视频输入,或者音频输入输出等。ioctl(fd_v4l, VIDIOC_QUERYCAP, &amp;cap)</p>
<p>　　(3)设置视频采集的参数<br>　　设置视频的制式，制式包括PAL/NTSC，使用ioctl(fd_v4l, VIDIOC_S_STD, &amp;std_id)<br>　　设置视频图像的采集窗口的大小，使用ioctl(fd_v4l, VIDIOC_S_CROP, &amp;crop)<br>　　设置视频帧格式，包括帧的点阵格式，宽度和高度等，使用ioctl(fd_v4l, VIDIOC_S_FMT, &amp;fmt)<br>　　设置视频的帧率，使用ioctl(fd_v4l, VIDIOC_S_PARM, &amp;parm)<br>　　设置视频的旋转方式，使用ioctl(fd_v4l, VIDIOC_S_CTRL, &amp;ctrl)</p>
<p>　　(4)向驱动申请视频流数据的帧缓冲区</p>
<p>　　请求/申请若干个帧缓冲区，一般为不少于3个,使用ioctl(fd_v4l, VIDIOC_REQBUFS, &amp;req)<br>　　查询帧缓冲区在内核空间中的长度和偏移量 ioctl(fd_v4l, VIDIOC_QUERYBUF, &amp;buf)</p>
<p>　　(5)应用程序通过内存映射，将帧缓冲区的地址映射到用户空间，这样就可以直接操作采集到的帧了，而不必去复制。<br>　　buffers[i].start = mmap (NULL, buffers[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, fd_v4l, buffers[i].offset);</p>
<p>　　(6)将申请到的帧缓冲全部放入视频采集输出队列，以便存放采集的数据。ioctl (fd_v4l, VIDIOC_QBUF, &amp;buf)</p>
<p>　　(7)开始视频流数据的采集。 ioctl (fd_v4l, VIDIOC_STREAMON, &amp;type)</p>
<p>　　(8) 驱动将采集到的一帧视频数据存入输入队列第一个帧缓冲区，存完后将该帧缓冲区移至视频采集输出队列。</p>
<p>　　(9)应用程序从视频采集输出队列中取出已含有采集数据的帧缓冲区。ioctl (fd_v4l, VIDIOC_DQBUF, &amp;buf) ，应用程序处理该帧缓冲区的原始视频数据。</p>
<p>　　(10)处理完后，应用程序的将该帧缓冲区重新排入输入队列,这样便可以循环采集数据。ioctl (fd_v4l, VIDIOC_QBUF, &amp;buf)<br>　　重复上述步骤8到10，直到停止采集数据。</p>
<p>　　(11)停止视频的采集。ioctl (fd_v4l, VIDIOC_STREAMOFF, &amp;type)</p>
<p>　　(12)释放申请的视频帧缓冲区unmap，关闭视频设备文件close(fd_v4l)。</p>
<p>　　以上的程序流程，包含了视频设备采集连续的视频数据的逻辑关系。而在实际运用中，往往还要加入对视频数据进行处理(如压缩编码)的工作，否则，视频流数据量相当大，需要很大的存储空间和传输带宽。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　v4l2，一开始听到这个名词的时候，以为又是一个很难很难的模块，涉及到视频的处理，后来在网上各种找资料后，才发现其实v4l2已经分装好了驱动程序，只要我们根据需要调用相应的接口和函数，从而实现视频的获取和处理。只要认真的看几篇文章就对v4l2有一定的了解了，由于是第一次]]>
    </summary>
    
      <category term="视频处理" scheme="http://silencewt.github.io/tags/%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Ubuntu下安装imx6linux系统的交叉编译环境遇到的问题总结]]></title>
    <link href="http://silencewt.github.io/2015/04/29/%E5%9C%A8Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85imx6linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://silencewt.github.io/2015/04/29/在Ubuntu下安装imx6linux系统的交叉编译环境遇到的问题总结/</id>
    <published>2015-04-29T12:08:40.000Z</published>
    <updated>2015-04-29T12:31:59.000Z</updated>
    <content type="html"><![CDATA[<p>　　这段时间一直忙于手上的嵌入式项目，可以说自己从嵌入式的菜鸟一点点的入门了，关于嵌入式和imx6核心板的开发有了一点的了解，尤其是对于板子环境的搭建。硬件的开发，搭建环境，是一个很大的工程量，也是很重要的一步，环境没有搭好就无法进行下一步。当然这个前提是对项目所使用的硬件有一定的了解。对于嵌入式开发，项目进行到现在，从一个什么都不懂的到现在可以和大家讨论v4l2，framebuffer，讨论linux的视频开发，虽然还是菜鸟级别的，但这个月确实让自己掌握了一们知识。</p>
<p>　　关于嵌入式的开发，网上有很多的教程和步骤，大概就是按照以下的步骤：确定需求、根据需求硬件选型、确定硬件并对硬件熟悉，搭建开发环境，软件部分，联机调试，各硬件间的联调，最后形成原型，裁剪系统，分装。这里的每一步都很重要，不能轻忽任何一步。下面总结了在搭建开发环境这块遇到的一些问题。不同的硬件有不同的要求，交叉编译的环境也不一样。</p>
<p>　　在Linux下搭建开发环境，你必须对linux系统的环境配置要有所了解。</p>
<hr>
<h3 id="一、环境配置">一、环境配置</h3>
<h4 id="1-1、什么是shell">1.1、什么是shell</h4>
<p>Shell：又名壳层，是“提供用户使用界面”的软件，通常指的是命令行界面的解析器，在操作系统中，提供访问内核所提供的服务的程序。</p>
<p>Shell：因为来自于操作系统（内核）与用户界面的外层界面，通常将壳层分为两类：命令行与图形界面。 命令行壳层提供一个命令行界面（CLI）； 而图形壳层提供一个图形用户界面（GUI）。</p>
<p>bash 就是一个内置的shell程序，隶属于命令行壳层。简单的说，shell提供了一个接口，让用户输入命令，接收用户命令，然后调用相应的应用程序，就相当于dos的command。</p>
<h4 id="1-2_环境的建立">1.2  环境的建立</h4>
<p>　　用户登录系统后，会启动内置的bash程序，来读取启动文件的配置脚本，这些脚本定义了所有用户共享的默认环境。 针对不通的用户需求，会对操作系统的环境变 量进行修该，以满足用户需求，bash在读取系统默 认的环境便变量后，会自动读存储在主目录下用于定义个人环境的启动文件，建立所需的环境。</p>
<h4 id="1-3_启动文件中有什么">1.3 启动文件中有什么</h4>
<p>shell会话分两种：login shell 和 non-login shell 会话。</p>
<p>login shell 的启动文件：</p>
<p>/etc/profile ：适用于所有用户的全局配置脚本</p>
<p>~./bash_profile ：个人启动文件，可扩展成全局配置脚本</p>
<p>~/.bash_login ：</p>
<p>~/.profile</p>
<p>non-login shell：读取的启动文件</p>
<p>/etc/bash.bashrc ：适用于所有用户的全局配置脚本</p>
<p>~/.bashrc ：用户的个人启动文件，而后集成父类进程环境。其中父类进程通常是一个login shell。</p>
<pre><code>eg :  .bash_profile:
<span class="comment"># .bash_profile</span>
<span class="comment"># cget the aliases and functions</span>
<span class="keyword">if</span> [ <span class="operator">-f</span>  ~/.bashrc ] ; <span class="keyword">then</span>
         .   ~/.bashrc
<span class="keyword">fi</span>
<span class="comment">#  user specific enviroment and startup  programs</span>
PATH = <span class="variable">$PATH</span>:<span class="variable">$HOME</span> / bin
<span class="keyword">export</span>  PATH      
<span class="comment"># 开始的行是注释行，shell不会读取； 此段代码被称为 if 的复合命令</span>
If the file “~/.bashrc ” exists , <span class="keyword">then</span> <span class="built_in">read</span> the <span class="string">"~/.bashrc"</span> file
PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span> /bin ： 将<span class="variable">$HOME</span>/bin添加到了PATH值的尾部
<span class="keyword">export</span> 命令告诉shell，将shell的子进程使用PATH变量的内容。
</code></pre><h4 id="1-4_修改环境">1.4 修改环境</h4>
<p>　　以上是系统启动文件的位置和内容，可以通过修改系统启动文件，来自定义个体环境。 环境变量的修改或者增加PATH目录，需要在 .bash_profile 文件中操作，根据版本的不同而不同，比如Ubuntu使用的就是./profile文件。 其他的修改应该在 .bashrc 文件中 修改工具：vim</p>
<p>　　文本编辑器分成两类：图形界面的和基于文本的 Ubuntu下常用的是基于文本的vim</p>
<p>联网安装：sudo apt-get vim<br>卸 载：rm -Rf vim<br>打开文件：vim 文件名 (一定要进入当前路径)<br>修改文件： a —&gt;进入insert模式<br>退出文件：Esc + ：+ （w，q, wq , q! ,wq! 等）<br>printenv : 打印部分或全部的环境信息<br>set : 设置shell选项<br>export : 将环境导出到随后要运行的程序中<br>alias : 为命令创建一个别名<br>source：文件路径/文件名</p>
<h3 id="二、交叉编译">二、交叉编译</h3>
<p>　　嵌入式系统开发过程中，运行程序的目标平台通常 具有有限的存储空间和运算能力，比如常见的ARM 平台： 静态存储空间：16~32MB， CPU的主频：100MHz~500MHz 因此，在ARM平台上不可能进行本机编译，因为一般的编译工具链（compilation tool chain）需要很大的存储空间，并需要很强的CPU运算能力。 我们就可以在CPU能力很强、存储控件足够的主机平台 上（比如PC上）编译出针对其他平台的可执行程序。PC机 资源丰富，可以很方便地集成开发环境和调试工具。</p>
<p>　　由于PC机与嵌入式系统环境的体系结构不同， 在PC机上可以运行的程序在目标机arm板上无法运 行，因此嵌入式开发必须采用交叉编译，以使PC机 可以生成在arm班上可以执行的代码。 编译的最主要的工作就是将程序转化成运行该程序的CPU所能识别的机器代码。此时就用到了交叉编译链。 要进行交叉编译，需要在主机平台上安装交叉编译工具链，然后用这个交叉编译工具链编译我们的源代码，最终生成可以在目标平台上运行的代码。</p>
<p>　　<strong>什么是编译工具链</strong>： 编译工具链可简单理解为编译工具集： 编译器，汇编器，链接器，C标准库。 编译器负责将源代码转换为二进制机器码（或汇编代码），像gcc； 汇编器和链接器等则负责可执行文件的构建，像 binutils，中文为二进制工具集； C标准库是通用的机器码库，供链接器用，像 glibc。</p>
<p><strong>大致流程</strong>：</p>
<ol>
<li>安装LTIB并编译BSP</li>
<li>编译Qt 4.8.5 </li>
<li>安装Qt 4.8.5 </li>
<li>并配置ARM的交叉编译 </li>
<li>ARM的交叉编译</li>
</ol>
<h3 id="三、问题总结">三、问题总结</h3>
<p>关于环境配置时遇到的一些问题总结或者是知识梳理：</p>
<h4 id="3-1、make命令简介">3.1、make命令简介</h4>
<p>　　在开发一个系统时，一般是将一个系统分成几个模块， 这样做提高了系统的可维护性，但由于各个模块间不可避免 存在关联，所以当一个模块改动后，其他模块也许会有所更 。为此，在Linux系统中，专门提供了一个make命令来自动维护目标文件。</p>
<p>　　优点：只更新修改过的文件（在Linux中，一个文件被创建或更新后有一个最后修改时间，make命令就是通过这个最后修改时间来判断此文件是否被修改），而对没修改的文 件则置之不理，并且make命令不会漏掉一个需要更新的文件。</p>
<p>　　依赖关系的确定： make命令当然不会自己知道这些依赖关系，需要程序 员将这些依赖关系写入一个叫Makefile的文件中。 Makefile文件中包含着一些目标，通常目标就是文件名，对每一个目标，提供了实现这个目标的一组命令以及和这个目标有依赖关系的其他目标或文件名。</p>
<h4 id="3-2、找不到zlib">3.2、找不到zlib</h4>
<p>　　下面是涉及到的一点工具。</p>
<p>　　LTIB(Linux Target Image Builder)工程是一个使用在不 同的目标平台下，用于开发和部署BSP(Board Support Packages)的简单工具。使用该工具，用户能够为其目标平 台开发符合GNU/Linux标准的映像。</p>
<p>　　BSP(Board Support Package)是板级支持包，是介于主 板硬件和操作系统之间的一层，应该说是属于操作系统的一 部分,主要目的是为了支持操作系统，使之能够更好的运行于硬件主板。</p>
<p><strong>问题描述</strong>：</p>
<pre><code> 运行./ltib –m config 就出错了
</code></pre><p>  　提示没安装zlib,其实系统已经安装了，也已是最新版本。</p>
<p><strong>解决方法</strong>：</p>
<p>　　Zlib是提供数据压缩用的函式库， 对自己的程序和文件进行程序内数据压缩、解压</p>
<p>　　添加路径，打开目录/ltib/bin/Ltibutils.pm 文件，search for zlib部分代码；</p>
<p>　　zlib         =&gt; sub { my @f = (glob(‘/usr/lib/libz.so*’),                                    </p>
<p>　　　　　　　　　　　　glob(‘/lib/libz.so*’),                                    </p>
<p>　　　　　　　　　　　　glob(‘/lib64/libz.so*’),+                                 </p>
<p>　　　　　　　　　　　　 glob(‘/lib/i386-linux-gnu/libz.so*’),                               </p>
<p>　　　　　　　　　　     <strong>glob(‘/usr/lib/i386-linux-gnu/libz.so*’),</strong>                                    </p>
<p>　　　　　　　　　　　　glob(‘/usr/lib32/libz.so*’),                     </p>
<p>　　　　　　　               glob(‘/usr/lib/x86_64-linux-gnu/libz.so*’) ); @f &gt; 1 ? 1 : 0 },</p>
<p> glob() 函数返回匹配指定模式的文件名或目录。</p>
<p>加粗那一行错误所在，添加进去后才可以运行。</p>
<h4 id="3-3、-/ltib错误">3.3、./ltib错误</h4>
<p><strong>问题描述：</strong></p>
<pre><code>You don't have a working TeX binary installed, <span class="keyword">but</span> <span class="keyword">the</span> texi2dvi <span class="keyword">script</span>
can't proceed <span class="keyword">without</span> <span class="keyword">it</span>. If you want <span class="keyword">to</span> use this <span class="keyword">script</span>, you have <span class="keyword">to</span> 
install <span class="keyword">some</span> kind <span class="keyword">of</span> TeX, <span class="keyword">for</span> example TeX Live Debian packages. You can do
<span class="keyword">that</span> <span class="keyword">with</span> this command:
apt-<span class="keyword">get</span> install texlive
make[<span class="number">2</span>]: *** [flex.pdf] Error <span class="number">1</span>
make[<span class="number">2</span>]: Leaving directory `/opt/freescale/ltib/usr/src/rpm/BUILD/flex-<span class="number">2.5</span><span class="number">.37</span>/doc' 
make[<span class="number">1</span>]: *** [install-recursive] Error <span class="number">1</span> 
make[<span class="number">1</span>]: Leaving directory `/opt/freescale/ltib/usr/src/rpm/BUILD/flex-<span class="number">2.5</span><span class="number">.37</span>'
make: *** [install] Error <span class="number">2</span>
<span class="keyword">error</span>: Bad <span class="keyword">exit</span> status <span class="keyword">from</span> /home/cody/i.mx6/ltib/tmp/rpm-tmp<span class="number">.99407</span> (%install)
RPM build errors:
Bad <span class="keyword">exit</span> status <span class="keyword">from</span> /home/cody/i.mx6/ltib/tmp/rpm-tmp<span class="number">.99407</span> (%install)
Build <span class="property">time</span> <span class="keyword">for</span> flex: <span class="number">27</span> seconds
Failed building flex
Died <span class="keyword">at</span> ./ltib line <span class="number">1392.</span>
traceback:
 main::build_host_rpms:<span class="number">1392</span>
 main::host_checks:<span class="number">1447</span>
 main:<span class="number">554</span>
</code></pre><p><strong>解决方案：</strong><br>sudo apt-get install texinfo<br>sudo apt-get install texlive</p>
<p><strong>原因：</strong><br>tex 是一个排版系统<br>texlive就是包含了编辑器、编译器、阅读器的一个tex套装；<br>texinfo软件依赖于bash，包含读取、写入和转换 Info 文档的程序，以提供系统文档</p>
<h4 id="3-4、找不到文件目录">3.4、找不到文件目录</h4>
<p><strong>问题描述：</strong></p>
<pre><code> bash:<span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
</code></pre><p> 因为PATH变量的设置，导致系统原有的默认路径被覆盖，此时 sudo ,ls ,chmod等命令都不能用。</p>
<p> <strong>解决方案：</strong></p>
<p>　　1,/usr/bin/sudo  vi  /etc/profile          (由于你找不到sudo，所以必须写全路径，其他命令如果提示找不到，也需要写全路径)</p>
<p>　　2.末尾添加以下内容后保存 </p>
<pre><code>export <span class="constant">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/usr/sbin</span>
</code></pre><p>　　/sbin一般是指超级用户指令，主要放置一些系统管理的必备程式；</p>
<p> 　　/usr/bin　是你在后期安装的一些软件的运行脚本；</p>
<p>　　/usr/sbin   放置一些用户安装的系统管理的必备程式；</p>
<p>要考虑root 的\$PATH里是否已经包含了这些环境变量。可以查看PATH，如果是：PATH=\$PATH:\$HOME/bin则需要添加成如下：</p>
<pre><code> PATH=$PATH:$HOME<span class="regexp">/bin:/</span>sbin:<span class="regexp">/usr/</span>bin:<span class="regexp">/usr/</span>sbin
</code></pre><p>  3.重新启动系统或执行以下命令生效</p>
<pre><code>   <span class="keyword">source</span> /etc/<span class="keyword">profile</span>
</code></pre><hr>
<hr>
<p>　　<em>以上感谢小妍师妹的整理和分享，这让我们大家又多学了一点东西。以后决定将周会的内容记录下来，学会分享和总结。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这段时间一直忙于手上的嵌入式项目，可以说自己从嵌入式的菜鸟一点点的入门了，关于嵌入式和imx6核心板的开发有了一点的了解，尤其是对于板子环境的搭建。硬件的开发，搭建环境，是一个很大的工程量，也是很重要的一步，环境没有搭好就无法进行下一步。当然这个前提是对项目所使用的硬件]]>
    </summary>
    
      <category term="Linux" scheme="http://silencewt.github.io/tags/Linux/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/categories/lab/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《赢在测试2》--读书笔记]]></title>
    <link href="http://silencewt.github.io/2015/04/07/%E3%80%8A%E8%B5%A2%E5%9C%A8%E6%B5%8B%E8%AF%952%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://silencewt.github.io/2015/04/07/《赢在测试2》-读书笔记/</id>
    <published>2015-04-07T01:01:42.000Z</published>
    <updated>2015-04-07T01:05:22.000Z</updated>
    <content type="html"><![CDATA[<p>　　从优秀的人身上总能学到很多的东西，《赢在测试2》这本书给我最多的就是激励自己，希望自己能向他们一样，在自己的事业上好好的奋斗。这些牛人给了我很多启发。</p>
<p>　　这十个牛人之间也有很多想法是一致的，有一定的相同，成功的人总有一些共同特点。</p>
<p>　　下面是我的思维导图笔记，在这个阶段我只列出了我关注的点，当然书里关于管理也有一些好的想法，像以人为核心的团队，一个团队的管理者不仅仅要带领团队做好测试，还要有能保持和调动员工的工作积极性，把团队的潜力和能力发挥出来。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/%E8%B5%A2%E5%9C%A8%E6%B5%8B%E8%AF%952%20%282%29.jpeg" alt="yzce2"><br>​</p>
<p>对于将后行业发展认识：</p>
<p>1、探索式测试和脚本化测试：探索式测试强调测试人员的思维自由度和主观能动性，</p>
<p>2、敏捷开发模式下的敏捷测试</p>
<p>3、自动化测试</p>
<hr>
<p>以下是书中的一些摘录，挺值得思考的：</p>
<blockquote>
<p>去做自己喜欢的，还是去做别人喜欢的？最终我选择了前者。这就像我之前选择测试还是开发一样，是做自己喜欢的测试还是做大家期望的研发，经过深思熟虑之后，才知道自己的真正想要的，最终我选择了前者。</p>
</blockquote>
<p>　　</p>
<blockquote>
<p>测试人员懂得思考和分析，很多人觉得测试就是点点鼠标，看看界面，但其实不这样的，测试是有技术含量的，就拿点鼠标来说，测试人员为什么要点鼠标，鼠标点在哪里？要点几次？产生结果是怎么样的？为什么会有这样的结果？怎么解决？这些都是测试人员要思考的，这也体现了他们是如何思考的，如何分析的，这才是人和人最大的区别，也是测试人员真正的价值所在。</p>
</blockquote>
<p>　　</p>
<blockquote>
<p>不需要把开发和测试在角色上鲜明的分开，说开发人员和测试人员这不是问题的关键，而死可以把他们从工作上分开，有开发类的工作，也有测试类的工作，从这个角度看，测试类的工作会存在，至于是谁去做，就要看实际情况和能力了。不管谁做测试都要保证测试上的独立性，毕竟测试有其特有的思维方式，这里的独立性是指精神上的杜丽丽，而不是物理上的独立。</p>
</blockquote>
<p>　　</p>
<blockquote>
<p>第一：要用运营的思维来考虑产品质量。例如，软件发布后怎么办？有什么办法实现持续的改进？快速的迭代中，如何做好质量保证？第二：软件研发中修复所有的问题是不可能的，有的问题从测试的角度来看是不可接受的，但是可能用户并不关心。不是说故意去对客户隐瞒，而是有的问题客户遇到的概率很低，那优先级就要下降。如何满足客户需求？做好客户经常使用的功能，优先解决客户经常遇到的问题，这才是真正的以用户为核心。</p>
</blockquote>
<p>　　</p>
<blockquote>
<p>在淘宝，在对测试工程师的绩效要求上，并不在于bug的number，更重要的是，在业务上是否有创新，有没有帮助开发解决什么问题，是如何提高自己的？</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　从优秀的人身上总能学到很多的东西，《赢在测试2》这本书给我最多的就是激励自己，希望自己能向他们一样，在自己的事业上好好的奋斗。这些牛人给了我很多启发。</p>
<p>　　这十个牛人之间也有很多想法是一致的，有一定的相同，成功的人总有一些共同特点。</p>
<p>　　下面]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读《淘宝技术这十年》--笔记]]></title>
    <link href="http://silencewt.github.io/2015/04/06/%E8%AF%BB%E3%80%8A%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>http://silencewt.github.io/2015/04/06/读《淘宝技术这十年》-笔记/</id>
    <published>2015-04-06T05:52:36.000Z</published>
    <updated>2015-04-06T05:58:40.000Z</updated>
    <content type="html"><![CDATA[<p>　　清明假期，武汉雨下得不停，将原有外出的计划打乱，于是这两天就在实验室呆着了，借着这个假期看了一些书，放松自己，也利用这个时间将之前一直没有完成的事情完成。《淘宝技术这十年》是无意中看到的，这本书大致介绍了作者子柳在淘宝8年间的所看所想，带着故事性的讲述了淘宝网的演化过程，如何从一个小型的内容网站到如今大规模的世界电商平台，主要是从技术的角度出发，讲述这个超大规模互联网系统的成长历程，及其所有主动和被动的技术变革的前因后果。也让我看到了一个网站的成长过程是怎样的复杂，如今我们便利的网上购物，疯狂的秒杀，后面是多少顶级工程师的技术和汗水。</p>
<p>　　这本书个人将其分为三部分：</p>
<p>　　第一部分：故事性的叙述淘宝发展，看着比较有意思，一点点的将整个网站的发展呈现出来，各个阶段会遇到什么问题，采用的解决方式，这里没有纤细介绍技术，只是给了一个大体的框架，两个故事（<a href="http://www.cnblogs.com/willsonchan/archive/2012/01/21/2328427.html" target="_blank" rel="external">你刚才在淘宝上买了一件毛衣</a>、超市收银）的平白叙述让人一看就懂，这部分比较吸引人看下去。</p>
<p>　　第二部分：主要重点介绍了淘宝技术体系，包括消息中间件、TDDL、分布式系统、session等，这里适合技术人员看，也只是大题给了一个框架，整体上了解了淘宝的大部分技术架构，没有涉及具体实现。</p>
<p>　　第三部分：自传，除了写作者自己在淘宝八年的发展，还有对一些牛人的采访：包括阳振坤，放翁等。在这部分从这些牛人身上可以学到一些东西。</p>
<p>　　以下是思维导图的笔记：<br>　　<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/linux-usb%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4%20%282%29.jpeg" alt="ybjszsn"></p>
<p>　　其实，一个网站规模从小做到大，技术与业务相互支撑并非一蹴而就，遇到的问题大体就是淘宝发展中所遇到的问题。</p>
<hr>
<p>　　以下对文中对我影响深的话摘录下来：</p>
<blockquote>
<p>想赚钱，想提升自己的职称，这些都是十分正常的。在这点上，我特别喜欢马总的理念——做公司要赚钱，但阿里从不把赚钱作为第一目标，我们服务好了客户，客户赚了钱，我们一定会得到自己应得的一份。在个人成长问题上也是类似的道理，这就是，一个人如果把做事、做成事作为主要目标，该他得到的东西，一定会顺理成章的、水到渠成地得到，但是，如果把上升作为主要目标，做同样的事，结果就会完全不一样。一句话，你的心态会最终决定你的成就。</p>
</blockquote>
<p>　　
　　</p>
<blockquote>
<p>如果你是向技术方向发展的人员，我们要看技术方面的专业性；然后看你的技术对公司的业务发展有多少贡献。还有一点，我比较看重的是，也许你不在其位，但能够跳出自己的范围，想到公司未来到底会面临什么问题，用什么方法来解决。当然，仅想是不够的，如果你能够落实就最好了，我们不管你落实的技术含量有多高，关键是你解决了什么样的问题。如果你能够做到这些，你这个人对公司就非常重要。</p>
</blockquote>
<p>　　
　　</p>
<blockquote>
<p>第一个是做事要自己思考后再去问别人，而不是一遇到问题就找人求助。第二个是不断地打破自己的一些想法，你不要担心自己今天已经做了50%的工作，要是推倒重来，前面的事情都白干了。我现在带的两个新人成长很快，但是都有类似的经历，就是一个东西被我反复推翻重做，在这个过程中就是不断地成长，要思考我为什么让你推倒重做，若想不清楚，下次重做的概率会更大，这样慢慢地就会学会了思考。</p>
</blockquote>
<p>　　</p>
<blockquote>
<p>给技术刚起步的人员一些技术成长的建议吧。兴趣是最好的老师，坚持是达到梦想的唯一途径，当然，在个人发展的不同阶段寻找到合适的导师很重要，看准方向会事半功倍。在刚刚参加工作还没有形成自己的判断时，方向有两个来源，一个是个人的兴趣，一个是找一个你非常佩服且能掌握未来方向的人，当然，如果这两者正好重合，那么剩下的就是脚踏实地坚持。</p>
</blockquote>
<p>　　作为新人，需要更多的向前辈们学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　清明假期，武汉雨下得不停，将原有外出的计划打乱，于是这两天就在实验室呆着了，借着这个假期看了一些书，放松自己，也利用这个时间将之前一直没有完成的事情完成。《淘宝技术这十年》是无意中看到的，这本书大致介绍了作者子柳在淘宝8年间的所看所想，带着故事性的讲述了淘宝网的演化过程]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于imx6核心板qt系统U盘挂载]]></title>
    <link href="http://silencewt.github.io/2015/04/02/%E5%85%B3%E4%BA%8Eimx6%E6%A0%B8%E5%BF%83%E6%9D%BFqt%E7%B3%BB%E7%BB%9FU%E7%9B%98%E6%8C%82%E8%BD%BD/"/>
    <id>http://silencewt.github.io/2015/04/02/关于imx6核心板qt系统U盘挂载/</id>
    <published>2015-04-02T13:44:19.000Z</published>
    <updated>2015-04-02T13:51:00.000Z</updated>
    <content type="html"><![CDATA[<p>　　在使用imx6核心板开发的时候，程序写到U盘，想通过U盘在板子上运行程序，U盘插到板子上后在minicom中有信息显示，但是无法找到挂载文件，/dev和/mnt下都没有找到相应的文件。后来百度后发现U盘在arm的Linux下需要手动挂载。方法如下：</p>
<p>1、U盘插入后会有信息显示在minicom中，如图：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/linux-usb1%20%281%29.jpg" alt="linux-usb1"></p>
<p>2、使用下列命令查看U盘设备名称（系统分配的）：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/linux-usb1%20%282%29.jpg" alt="linux-usb2"></p>
<p>然后会显示如下：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/linux-usb1%20%283%29.jpg" alt="linux-usb3"></p>
<p>看到中间Device那行，则表示U盘设备名为sda4，在/dev/目录下，直接进去/dev/sda4中是看不到文件的，会提示没有这个文件夹，这是需要我们挂载。</p>
<p>3、可以新建一个挂载目录：/mnt/udisk/<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/linux-usb1%20%284%29.jpg" alt="linux-usb4"></p>
<p>这里我是之前就建好了的，所以提示存在。<br>/mnt/udisk/这个目录就是U盘的挂载目录，该目录里的文件将会是U盘中的文件名。</p>
<p>4、挂载U盘。执行以下命令：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/linux-usb1%20%285%29.jpg" alt="linux-usb5"></p>
<p>表示将/dev/sda4/下的内容挂载到/mnt/udisk下，这样便挂载成功。</p>
<p>5、进入U盘目录/mnt/udisk，查看U盘中的数据。<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/linux-usb1%20%286%29.jpg" alt="Linux-USB6"></p>
<p> 这里显示U盘目录中的数据。</p>
<p>　　最后就可以对U盘里的程序进行操作了，发现这样比在虚拟机里用镜像快多了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　在使用imx6核心板开发的时候，程序写到U盘，想通过U盘在板子上运行程序，U盘插到板子上后在minicom中有信息显示，但是无法找到挂载文件，/dev和/mnt下都没有找到相应的文件。后来百度后发现U盘在arm的Linux下需要手动挂载。方法如下：</p>
<p>1、U]]>
    </summary>
    
      <category term="Linux" scheme="http://silencewt.github.io/tags/Linux/"/>
    
      <category term="lab" scheme="http://silencewt.github.io/tags/lab/"/>
    
      <category term="Linux" scheme="http://silencewt.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《赢在测试2》-- 推荐的阅读书籍]]></title>
    <link href="http://silencewt.github.io/2015/04/01/%E3%80%8A%E8%B5%A2%E5%9C%A8%E6%B5%8B%E8%AF%952%E3%80%8B-%E6%8E%A8%E8%8D%90%E7%9A%84%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    <id>http://silencewt.github.io/2015/04/01/《赢在测试2》-推荐的阅读书籍/</id>
    <published>2015-04-01T13:06:42.000Z</published>
    <updated>2015-04-01T13:16:18.000Z</updated>
    <content type="html"><![CDATA[<p>　　这里推荐了很多书，有一些我看过，或者准备看的书，其中最受大家推荐的就是：<strong>《软件测试经验和教训》</strong></p>
<p>1、<code>《软件测试艺术》</code></p>
<p>理由：展示大师Glenford Myers多年软件测试思想和技术，是入门的一本好教材。</p>
<p>2、<code>《软件测试经验和教训》</code>《lessons learned in software testing》</p>
<p>理由：书中分享了3位作者多年的测试经验，知道成功的测试需要什么，书中汇总了293条测试经验建议，可以用于自己的测试工作中，避免一些容易放的错误。经典必读，《赢在测试》中采访的人中有很多个推荐。“红宝书”</p>
<p>3、<code>《A Practitioners Guide  to software Test Design》</code></p>
<p>理由：关注测试用例的一本著作，其中包括白盒、黑盒、与基于经验的测试技术，每个测试技术都结合了技术原理，案例分析和优缺点分析，是每个测试人员了解和应用测试用例设计的一本好书。</p>
<p>4、<code>《思维导图--大脑使用说明书》</code></p>
<p>理由：帮助你提高记忆力和理解力，激发想象力，更好的制定生活和工作计划。</p>
<p>5、<code>《硝烟中的scrum》</code></p>
<p>理由：敏捷入门书，启蒙书</p>
<p>6、<code>《全程软件测试》</code></p>
<p>理由：作者朱少民，测试入门的一本教材，读完后对测试会有一个全面的了解</p>
<p>邰晓梅推荐：</p>
<p>7、<code>《 secret of a buccaneer scholar》</code></p>
<p>理由：中文版《学习要像加勒比海盗》作者：James bach。一本关于自我教育的书，虽然很薄，但是记录了James对自我教育、自我学习方面的认识和经验，这本书相信能让很多爱学习的人受启发。其中的学习态度和方法值得我们去思考。</p>
<p>8、<code>《essential software test design》</code></p>
<p>理由：作者：Torbjorn Ryber 一本关于测试设计的书，书中以测试分析4步法的方式讲述了常用的十几种测试设计技术的应用，并辅以实例。</p>
<p>9、<code>《XUnit test patterns :refactoring test code》</code></p>
<p>理由：作者：Gerard Meszaros 中文版《XUnit测试模式，测试代码重构》，书中对于单元测试的人来说有帮助，书中谈到很多测试代码的坏味道，以及大量被证明的好的测试模式，是的测试代码更易编写和维护。</p>
<p>肖丽琼推荐：</p>
<p>10：<code>《微软梦工厂》</code></p>
<p>理由：励志类，了解软件帝国的精英们是怎么工作和生活的，同是IT人会有很多的共鸣。</p>
<p><code>《学习要像加勒比海盗》</code></p>
<p>高翔推荐：</p>
<p><code>《软件测试经验和教训》</code></p>
<p>11：<code>《探索式软件测试》</code></p>
<p>理由：作者james a whittaker,以“漫游”为核心，提出一套有助于探索式测试的方法。</p>
<p>12：<code>《你的灯还亮着吗？》</code></p>
<p>理由：一本轻快的书，有效的探讨人们如何思考，问题如何定义，如何解决等深刻的主题。</p>
<p>步琼推荐：</p>
<p>13：<code>《beautiful testing》</code></p>
<p>理由：里面有很多项目实例和很好的经验分享，也包括一些测试趣事。</p>
<p>薛继国推荐：</p>
<p>14：<code>《质量免费》</code></p>
<p>理由：详细阐述质量的定义，扩宽思路，提高对产品质量的认识，对于从事测试的人来说有很大的帮助。</p>
<p>王冬推荐：</p>
<p>《全程软件测试》</p>
<p>《软件测试经验和教训》</p>
<hr>
<p>我自己看过觉得不错的测试书籍：</p>
<p>1、<code>《软件测试》</code></p>
<p>理由：Patton的那个版本，第三版，这个很基础，讲解了测试的各方面基础的内容，易懂，可以入门。</p>
<p>2、<code>《从菜鸟到测试架构师》</code></p>
<p>理由：讲述一个菜鸟测试工程师在IBM里是怎么一步步的走到架构师的，书中以故事的形式呈现测试的各个方面，可以当成小说看，也挺有意思的，读完后对整个测试的职业规划会有一定的了解，清楚整个测试行业的职业目标。</p>
<p>3、<code>《性能测试全程详解和案例分析》</code></p>
<p>理由：详细的讲述了性能测试的各个概念，简单易懂，比较全面，是性能测试的入门书，书中还介绍了如何使用测试工具Jmeter进行性能测试。</p>
<p>4、<code>《赢在测试2》</code></p>
<p>理由：看别人的故事总能激励自己，作者采访了十个人，每个人的故事都能给自己一点启发，且他们作为成功人士，对于测试，对于这个行业的了解，他们的经历都有一些共同点。很推荐，可以从他们身上学到很多。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　这里推荐了很多书，有一些我看过，或者准备看的书，其中最受大家推荐的就是：<strong>《软件测试经验和教训》</strong></p>
<p>1、<code>《软件测试艺术》</code></p>
<p>理由：展示大师Glenford Myers多年软件测试思想和技术]]>
    </summary>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://silencewt.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三月，关于团队管理的重要性]]></title>
    <link href="http://silencewt.github.io/2015/04/01/%E4%B8%89%E6%9C%88%EF%BC%8C%E5%85%B3%E4%BA%8E%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <id>http://silencewt.github.io/2015/04/01/三月，关于团队管理的重要性/</id>
    <published>2015-04-01T05:30:59.000Z</published>
    <updated>2015-04-01T13:07:41.000Z</updated>
    <content type="html"><![CDATA[<p>实验室有个项目进行到现在还在改需求，还在处于不确定的状态，这让我整个三月份在技术上都没有一点进步，也让我切切实实的感受到<code>项目需求</code>和<code>团队的重要性</code>。</p>
<p>　　三月份是一个很郁闷的月份，但同样也是一个有所收获的月份，最重要的是对于团队管理有了更深一步的认识，自己在这方面还有待加强。对于项目上的需求管理，项目的开发流程都有了更深的理解。这里所谓更深的理解都是针对自己，都是和自己之前的经历相比，可能这些感触对于另一些人来说是微不足道的。但是个人觉得有必要做一次总结和梳理，以便以后学习。</p>
<h3 id="项目需求管理上：">项目需求管理上：</h3>
<ul>
<li>一个项目不管大的还是小的，项目需求明确才是最重要的。在需求没有明确的情况下，就去开发，之后需求改了，变动过大，之前做的开发就是无用功，那么就是在浪费人力物力，浪费时间。</li>
<li>需求不能只是口头上说说，应该形成书面的文字，就算是小的项目也应该有正规的文档。口头上说，随意性太大，会造成今天这样说，明天忘了，又那样改，整体的变动就会很大，往往需要重新来过，这要在公司里代价就很大。</li>
<li>项目的主管人对于项目的需求要十分明确，不能团队成员问你需求的时候，模棱两可的回答，这会给成员带来不安定，怀疑的心理，进而对整个项目没有信心，缺乏认同感。</li>
</ul>
<p>去年实验室给某公司做一个小项目，开发一个简单的对数据处理的界面软件，我们实验室老板让我们自己和对方联系沟通。这个项目一开始就没有什么正式明确的需求，对方给一个大体的要求和时间，我们实现了之后，给对方看，我们每周交流一次，每周对方都会有新的需求需要我们实现（这好像有点像敏捷），我们也都尽量在原基础上完成。没想到这个小项目持续了三、四个月还没有验收，时不时的有需求要增加，直到最近还要增加一个功能，然后我们发现增加这个功能的话可能会造成原有系统较大的变化，这时改动的代价就很大了。<br>　　整个沟通的过程中，一直没有正式的需求的说明书，就算是之后口头增加的功能也没有一个正式的文档，有几次就出现这周说实现这个功能，下周就说不需要这样，要那样做，变化过大，给人感觉随意性太大。这也让我对这个公司有不好的印象。让我明白文档的重要性，当面沟通可以很好的解决问题，消除歧义，但是口头沟通的内容也需要记录下来形成正式的文档，以便后续的查阅。</p>
<p>　　</p>
<blockquote>
<p>需求阶段没有做好，调研没有做好，就匆忙的开始一个项目，只一味追求结果，那么这个项目会拖延很长的时间，消磨成员耐心。那个项目进行了好几个月，背后的几个月一直在改动，实验室人员已经对其没有兴趣和动力了，都呈现出一种疲乏的状态，大家似乎都明白，做了也白做，反正这个做了也是要改的，还不能等对方确定了再做。</p>
</blockquote>
<p> 虽然，很多时候需求时无法确定下来的，需求的变更也是可以理解的，需求本身就是一种不确定性的因素。但是一个软件，一个项目他的主体的功能是不会变动的，在大体不变的需求确定下，可以采用敏捷的方式开发，这样就不会有架构上大的变化。新需求的提出也会让团队成员更有动力，更有挑战性。而不是一味的在原有基础上改动。<strong>当然我们在做那个项目的时候没有考虑周全，没有很好的实现模块化，使得最后增加功能的时候变得比较麻烦，这也是我们的一个教训，这让我们以后在开发的时候更注重接口和模块化，少耦合</strong>。</p>
<h3 id="团队管理上：">团队管理上：</h3>
<blockquote>
<p>１、负责人需要适时的调动大家的积极性，让团队成员保持热情，增加整个团队的士气。</p>
</blockquote>
<p>　　2015年实验室有个关于嵌入式的项目，这个方面我们大家都没有接触过，大家对硬件都不是很熟。对方公司也对嵌入式不是很懂，所以很希望我们能帮忙，花了将近一个月的时间确定板子，拿到板子后对方对于具体的细节也无法给出一个确切的交代。实验室的人都对嵌入式开发没有一点头绪，这段时间的氛围就很差，都不想做硬件这方面。大家对其也没有热情。<br>　　这个时候我就觉得作为一个领导者就应该适时的增加团队的热情，稳住士气，调动大家的积极性，而不是任由这种情绪一直持续下去，我们老板在这个方面就做的不是很好，他对实验室的人不闻不问，也不在乎实验室的氛围。反而这让我感到很不好，我尽量的起到带头作用，鼓励大家多接触。但是我也知道做一件事情兴趣很重要，没有兴趣很难做成功的。所以，这里就很需要领导者能有魄力，调动大家的积极性，让团队成员保持热情，或者要明白自己的团队擅长的是社么，有挑战就是好处。</p>
<blockquote>
<p>2、一个团队里，每个人都要有一样的目标，都要有对这个团队的责任心，都要有互相沟通的意识。只要一个出现变异，不愿和成员沟通，对项目不闻不问，那么就会影响到整个团队，这种人就应该及时踢出团队（适时的教导无用下）否则会带坏整个团队氛围。维持团队氛围也是一个领导者该做的事情。</p>
</blockquote>
<p>  　　三月份是个繁忙的季节，周围的人都开始忙着找实习，我也不例外，我也想去到一个心仪的公司实习。忙着准备找实习的资料，同样的也忙着实验室的项目，恨不得每天24小时都可以工作，不要休息。实验室有一个男生不爱和我们沟通，不太愿意和我们交流，平时就是自己干自己的，三月份他自己就忙着找实习，项目的事情一点都不过问，但是合作的公司有事情又会打电话给他，他呢，收到消息也不会跟我们说，造成我们团队消息的脱节，往往都是在最后一个阶段才得到消息。<br>  　　其实，我的想法很简单，<strong>既然我们在实验室就应该做好实验室的事情，就应该对这个团队负责，有任何事情都要大家一起商量，互相沟通而不是自己干自己的，人是社会的人，不是太自私。</strong>作为一个领导者，就需要适时的对这个成员进行开导，而在学校这个环境，大家都是平等的学生，也不好说什么，委婉的告知后，还是不理睬，也只能任由他，但要保证其他人不会受到他的影响，实验室其他人都比较开朗，思想个方面都比较接近，不会受到某个人的影响。<strong>只是这些事情让我知道，团队需要一个核心，团队的氛围需要维持，团队之间需要互相交流和沟通，需要每个人的责任心，才能很好的完成一件事情，独来独往是不会成功的。这些都让我感受到团队管理的重要，以前不觉得，现在感触很深，负责人没有做好，会影响到整个团队的士气。</strong></p>
<blockquote>
<p>3、传承，一个领导者不仅要做好管理团队的事情，同时还要做好传承，训练新人的任务。</p>
</blockquote>
<p>　　在学校实验室的这个环境里，每年都会新人加入实验室，也会有人离开，那么离开的人除了做好交接之外，应该考虑如何将新人训练培养出来。实验室每年都会有一个新的负责人，这个负责人就应该统领实验室的事务。今年，师姐走了，我就是负责人，对于师弟师妹我尽可能的去帮助他们熟悉实验室项目，熟悉环境。但是这期间并不是每个人都会致力于实验室的项目的，总会有人不在乎，对实验室的事情不在意，这种人，我只能尽量的和他沟通，把我该做的做好，剩下就看他自己愿不愿意了，毕竟实验室还是一个校园的环境，很多人会过于随意，有些人读研的目的就是混日子，并不是每个人都有目标，都想要改变自己的。这个时候旁人也无法左右他的思想。</p>
<hr>
<p>最后在朋友圈里看到同学发的一个状态：</p>
<blockquote>
<p>一个人快乐或悲伤，只要不是装出来的，就必有其道理。你可以去分享他的快乐，同情他的悲伤，却不可以命令他怎样怎样，因为这是违背人类的天性的。——积极的结论</p>
</blockquote>
<p>写到这里又想到了我是歌手孙楠临时退赛的决定，这不是一个成熟的人该做的事情，退赛时是否由想到整个团队的工作人员，是否有想过整个团队，只能说太任性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>实验室有个项目进行到现在还在改需求，还在处于不确定的状态，这让我整个三月份在技术上都没有一点进步，也让我切切实实的感受到<code>项目需求</code>和<code>团队的重要性</code>。</p>
<p>　　三月份是一个很郁闷的月份，但同样也是一个有所收获的月份，最]]>
    </summary>
    
      <category term="心路历程" scheme="http://silencewt.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="心路历程" scheme="http://silencewt.github.io/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自动化测试及工具的一点理解]]></title>
    <link href="http://silencewt.github.io/2015/03/10/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>http://silencewt.github.io/2015/03/10/自动化测试及工具的一点理解/</id>
    <published>2015-03-10T03:01:39.000Z</published>
    <updated>2015-03-10T03:04:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong>1、回归测试：</strong></p>
<p>　　由于回归测试的测试目标是已有的，稳定的功能，我们会下意识的以为是不会有问题的，并且往往只需要测试一次就行，在这中情况下，如果能有一个稳定的自动化测试脚本来代替手工的操作，将极大的提高工作效率，在关注新功能的同时不会忽略回归测试。而且随着产品版本不断的迭代，叠加的功能也会越来越多，我们会更关注新功能，没有更多的精力和意识去关注既有功能是否被破坏掉了，所以自动化是不二的选择。</p>
<p><strong>2、手工测试和自动化的区别</strong>：</p>
<p> 　　手工测试：测试人员能很好的把握测试用例之间执行的先后顺序，一个个有序的执行测试，后执行的测试可以利用前一个测试执行后所创建的数据记录</p>
<p>　　自动化测试：需要在程序中将脚本的执行顺序显示的用代码表示出来，并且清晰的告诉计算机如何判断结果的正确与否，测试用例之间的依赖关系很难在脚本中清晰的表达出来，运行脚本的人员并不知道用例之间的依赖性。</p>
<p><strong>3、测试环境</strong></p>
<p> 　　我们知道，在测试之前对于测试环境的搭建是很重要的，保证测试环境的正确性、快速的搭建出测试环境，有利于之后测试的顺利进行。一般对于同一个需要测试的软件，系统的环境要求是一样的，要是在不同的机子上测试，每次都需要重新搭建一个环境，这样既耗时又耗费力气，如果能将环境的配置信息编写成脚本，每次只需要运行脚本就可以将环境搭建好，那么节省大量的人力物力。</p>
<p><strong>4、不是所有都是自动化</strong></p>
<p> 　　软件产品开发的特点就是紧急，时间紧，如何在短时间内实现自动化，是否需要自动化都是需要考虑的。如果产品周期短，脚本的开发执行成本远远大于手工执行脚本，在根据之后对于该脚本的执行次数来看，就可以简单的判断是否可以自动化。自动化测试虽然好，但不能一味的将所有的都自动化，自动化投入的时间成本会比较高。自动化框架和脚本的开发是一个投入量很大的项目，而一个可读性不高，健壮性不强的脚本，往往会让测试人员耗费大量的精力去维护，其结果往往得不偿失。所以在脚本开发时要特别注意脚本的了可读性、独立运行性和可重复性，降低后续的维护成本。</p>
<hr>
<p>对于自动化测试工具：</p>
<p>1、<strong>界面自动化测试工具</strong>，我们往往入门的时候都是用的商业或者开源的工具，例如：QTP、RFT之类，这些都是界面级别的自动化测试，界面自动化测试的有一定开发难度，但是确有不少的开源库可以提供，完全可以基于以上库开发，或者有一些开源的工具很成熟了，你所做的就是基于以上进行一下更改。例如：测试java界面的工具就有aboot、swbot、mathron等开源工具，测试web界面的有selenium、watin等，测试移动端的有robotium、monkey等。要能二次开发这些工具，主要是需要理解抓取对象和回放的原理，然后是一些配置文件的处理，对象库里主要是XML的处理，一般录制功能我觉得可以忽略。</p>
<p><strong>2、白盒测试工具</strong>，一些代码级别的测试工具，例如：对代码覆盖率的分析、对代码质量的分析等，这方面涉及较浅，就不随便造次了。</p>
<p><strong>3、接口自动化测试工具</strong>，接口自动化测试工具在开发的时候，首先需要明确业务接口类型，然后掌握一定的接口工具的应用方式，一般的接口工具都是会解析某种接口定义文件，然后将接口文件以界面的形式展现出来，可以通过对界面接口的操作：对某个接口填写参数，然后发送到服务器端，查看响应，或者直接get接口返回值。例如：SoapUI工具是针对WebService系统的测试，主要是解析WSDL接口定义文件。Jmeter和LR也可以做接口测试工具，例如：java接口和HTTP接口等。之前，开发过的接口工具包括：SNMP接口和corba接口工具，其原理也是解析mib和IOR接口定义文件，然后可以对接口进行set与get操作。所以，开发这类的工具，一定要明确什么是软件接口、然后接口描述文件是什么，最后是如何去对接口进行操作，日志和结果的展现等，还有一些就是额外的功能了，例如：录制，将测试人员对接口的操作录制下来，成为工作流等。</p>
<p><strong>4、性能自动化测试工具</strong>，看到性能测试工具，大家很容易想到LR、Jmeter之类，这方面的工具，我用的较少，但是会基于自己公司内部的产品一些特殊性能场景方面的测试，会专门开发一些这样的工具，例如：开发一个发送SNMP网络报文的工具，模拟告警最大接收和并发性能，开发一个网元模拟器，能够模拟大量不同IP的网元，可以在公司网元管理器上测试同时管理的最大网元等。所以，性能测试首先要与业务场景相结合，然后掌握一定的性能基础和指标，分析好相关的接口协议和需要模拟的业务，就可以快速开发相应的工具了。</p>
<p><strong>5、系统应用级别的自动化测试工具</strong>，这种工具需要明确应用场景，即明确需求，例如：我之前开发一些部门内部工具集合，专门提供给测试人员进行脚本录制()、公司级别的有采集和巡检工具。(对外支持)，这部分工具带来的效益是很大的。所以说，千万不要将自动化测试局限在测试方面，其实提高测试与开发的人员的效率、以及对公司产品的质量保障方面的工具都是能给公司带来直接效益的。也许几行代码也是一个能提升效率的好的工具。</p>
<hr>
<p>　　<strong>测试工具虽好但不能迷恋，不能期望测试工具可以取代手工测试。测试工具在测试工作中起的是辅助作用，一般用来提高测试效率。</strong>自动化测试弥补了手工测试的不足，减轻一定的工作量。<strong>实际上测试工具是无法替代大多数手工测试的，而一些诸如性能测试等自动化测试也是手工所不能完成的。</strong></p>
<p>　　对于自动测试技术，<strong>应当依据软件的不同情况来分别对待</strong>，一般自动技术会应用在引起大量重复性工作的地方、系统的压力点、以及任何适合使用程序解决大批量输入数据的地方。然后再<strong>寻找合适的自动测试工具，或者自己开发测试程序。一定不要为了使用测试工具而使用。</strong></p>
<p>　　<strong>我个人认为自动化测试，就是用技术和自动化去服务测试，保证质量，提高产品生产率（不是测试生产力）。无论如何这个行业需求是关键，脱离需求和具体环境，一切都是玩笑。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1、回归测试：</strong></p>
<p>　　由于回归测试的测试目标是已有的，稳定的功能，我们会下意识的以为是不会有问题的，并且往往只需要测试一次就行，在这中情况下，如果能有一个稳定的自动化测试脚本来代替手工的操作，将极大的提高工作效率，在关注新功能的]]>
    </summary>
    
      <category term="测试" scheme="http://silencewt.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试" scheme="http://silencewt.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux文件目录结构详解]]></title>
    <link href="http://silencewt.github.io/2015/03/10/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://silencewt.github.io/2015/03/10/Linux文件目录结构详解/</id>
    <published>2015-03-10T02:51:45.000Z</published>
    <updated>2015-03-10T03:01:14.000Z</updated>
    <content type="html"><![CDATA[<p>整理自《鸟哥的私房菜》</p>
<p>　　对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学好Linux的至关重要的一步.，深入了解linux文件目录结构的标准和每个目录的详细功能，对于我们用好linux系统只管重要，下面我们就开始了解一下linux目录结构的相关知识。</p>
<p>　　当在使用Linux的时候，如果您通过ls –l / 就会发现，在/下包涵很多的目录，比如etc、usr、var、bin … … 等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就象树形结构，所以我们可以把文件系统的结构形象的称为 树形结构。</p>
<p> 　　文件系统的是用来组织和排列文件存取的，所以她是可见的，在Linux中，我们可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/ 起始的树形结构。linux文件系统的最顶端是/，我们称/为Linux的root，也就是 Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。</p>
<p>　　由于linux是开放源代码，各大公司和团体根据linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的PC。因为你根本不知道一些基本的配置，文件在哪里。。。这就造成了混乱。这就是FHS（Filesystem Hierarchy Standard ）机构诞生的原因。该机构是linux爱好者自发的组成的一个团体，主要是是对linux做一些基本的要求，不至于是操作者换一台主机就成了linux的‘文盲’。</p>
<p> 　　根据FHS(<a href="http://www.pathname.com/fhs/)的官方文件指出，" target="_blank" rel="external">http://www.pathname.com/fhs/)的官方文件指出，</a> 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准。 也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。 这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。</p>
<p>　　事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动， </p>
<p>四中类型:</p>
<p>1.可分享的：</p>
<p>可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；</p>
<p>2.不可分享的：</p>
<p>自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</p>
<p>3.不变的：</p>
<p>有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</p>
<p>4.可变动的：</p>
<p>经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</p>
<p>事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：</p>
<p>/ (root, 根目录)：与开机系统有关；</p>
<p>/usr (unix software resource)：与软件安装/执行有关；</p>
<p>/var (variable)：与系统运作过程有关。</p>
<p>一. 根目录 (/) 的意义与内容：</p>
<p>　　根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。</p>
<p>　　因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。</p>
<p>根据以上原因，FHS认为根目录(/)下应该包含如下子目录：</p>
<p><strong>/bin：</strong>系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。</p>
<p><strong>/boot：</strong>主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。</p>
<p><strong>/dev：</strong>在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp<em>, / dev/hd</em>, /dev/sd*等等</p>
<p> <strong>/etc：</strong>系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop</p>
<p><strong>/etc/xinetd.d/ ：</strong>这就是所谓的super daemon管理的各项服务的设定档目录。</p>
<p><strong>/etc/X11/ ：</strong>与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。</p>
<p><strong>/home：</strong>这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号：</p>
<p><strong>~ ：</strong>代表当前使用者的家目录，<br> <strong>~guest：</strong>则代表用户名为guest的家目录。</p>
<p><strong>/lib：</strong>系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。</p>
<p><strong>/media：</strong>media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。</p>
<p><strong>/mnt：</strong>如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。</p>
<p><strong>/opt：</strong>这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。</p>
<p><strong>/root：</strong>系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。</p>
<p><strong>/sbin：</strong>Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</p>
<p><strong>/srv：</strong>srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。</p>
<p><strong>/tmp：</strong>这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。</p>
<p>　　事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下：</p>
<p><strong>/lost+found：</strong>这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found</p>
<p><strong>/proc：</strong>这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？</p>
<p><strong>/sys：</strong>这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。</p>
<p>　　除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。</p>
<p>那哪些<strong>目录不可与根目录分开</strong>呢？有底下这些：</p>
<p>/etc：配置文件</p>
<p>/bin：重要执行档</p>
<p>/dev：所需要的装置文件</p>
<p>/lib：执行档所需的函式库与核心所需的模块</p>
<p>/sbin：重要的系统执行文件</p>
<p>这五个目录千万不可与根目录分开在不同的分区。请背下来啊。</p>
<p>二. /usr 的意义与内容：</p>
<p>　　依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。</p>
<p>　　/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p>
<p>　　因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些：</p>
<p><strong>/usr/X11R6/：</strong>为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。</p>
<p><strong>/usr/bin/：</strong>绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关)</p>
<p><strong>/usr/include/</strong>：c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。</p>
<p><strong>/usr/lib/：</strong>包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生</p>
<p><strong>/usr/local/：</strong>统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录</p>
<p><strong>/usr/sbin/：</strong>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)</p>
<p><strong>/usr/share/：</strong>放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件</p>
<p><strong>/usr/share/doc：</strong>软件杂项的文件说明</p>
<p><strong>/usr/share/zoneinfo：</strong>与时区有关的时区文件</p>
<p><strong>/usr/src/：</strong>一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。</p>
<p>三.  /var 的意义与内容：</p>
<p>　　如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：</p>
<p><strong>/var/cache/：</strong>应用程序本身运作过程中会产生的一些暂存档</p>
<p><strong>/var/lib/：</strong>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去</p>
<p><strong>/var/lock/</strong>：某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用</p>
<p><strong>/var/log/</strong>：非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。</p>
<p><strong>/var/mail/</strong>：放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。</p>
<p><strong>/var/run/</strong>：某些程序或者是服务启动后，会将他们的PID放置在这个目录下</p>
<p><strong>/var/spool/</strong>：这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。</p>
<p>　　由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。</p>
<p>四. 目录树(directory tree) :</p>
<p>　　在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：</p>
<p>目录树的启始点为根目录 (/, root)；<br>　　每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。<br>　　每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。<br>如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话． </p>
<p>五. 绝对路径与相对路径</p>
<p>　　除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：</p>
<p>绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；</p>
<p>相对路径：相对于目前路径的文件名写法。 例如 ./home/n1516 或 等等。反正开头不是 / 就属于相对路径的写法</p>
<p>而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？</p>
<p>cd /var/log   (absolute)</p>
<p>cd ../var/log (relative)</p>
<p>因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：</p>
<p>.  ：代表当前的目录，也可以使用 ./ 来表示；</p>
<p>.. ：代表上一层目录，也可以 ../ 来代表。</p>
<p>这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。</p>
<p>实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？</p>
<p>命令：<br>cd /var/spool/mail<br>cd ../cron<br>说明：<br>　　由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。这个相对路径是非常有帮助的，尤其对于某些软件开发商来说。 一般来说，软件开发商会将数据放置到/usr/local/里面的各相对目录。 但如果用户想要安装到不同目录呢？就得要使用相对路径。</p>
<p>实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？<br>说明：<br>　　由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>整理自《鸟哥的私房菜》</p>
<p>　　对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学好Linux的至关重要的一步.，深入了解linux文件目录结构的标准和每个目录的详细功能，对于我们用好linux系统只管重要，下面我们就开始了解一下linux目录]]>
    </summary>
    
      <category term="Linux" scheme="http://silencewt.github.io/tags/Linux/"/>
    
      <category term="Linux" scheme="http://silencewt.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python 批量更换图片格式脚本]]></title>
    <link href="http://silencewt.github.io/2015/02/01/python-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%8D%A2%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%84%9A%E6%9C%AC/"/>
    <id>http://silencewt.github.io/2015/02/01/python-批量更换图片格式脚本/</id>
    <published>2015-02-01T13:52:23.000Z</published>
    <updated>2015-02-01T13:54:49.000Z</updated>
    <content type="html"><![CDATA[<p>问题：将某文件下的所有jpg的图片更换为png的图片</p>
<p>简单的实现:</p>
<pre><code><span class="comment"># -*- coding:utf-8 -*-</span>
<span class="keyword">from</span> os.path <span class="keyword">import</span> splitext
<span class="keyword">import</span> glob
<span class="keyword">from</span> PIL <span class="keyword">import</span> Image

<span class="function"><span class="keyword">def</span> <span class="title">get_all_file</span><span class="params">(filename)</span>:</span>
    files = glob.glob(filename)
    <span class="keyword">return</span> files

<span class="function"><span class="keyword">def</span> <span class="title">to_ather_file</span><span class="params">(files, type)</span>:</span>
    <span class="keyword">for</span> jpg <span class="keyword">in</span> files:
        im = Image.open(jpg)
        png = splitext(jpg)[<span class="number">0</span>]+<span class="string">"."</span> + type
        im.save(png)
        <span class="keyword">print</span> png


<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    filename = <span class="string">"./image/*.[Jj][Pp][Gg]"</span>
    files = get_all_file(filename)
    to_ather_file(files, <span class="string">"png"</span>)
</code></pre><p>　　这是一种很简单的是实现方法，就是先用glob获得某路径下的所有文件，该文件下都是jpg图片（题目是给定的，也可以考虑存在其他图片的情况的处理方式，就是获得文件的后缀名，判断是否为jpg），然后依次读入图片，使用splitext获得文件名和后缀名，然后按照要求重组文件名并保存就好了。</p>
<p>这里介绍两个部分：</p>
<p><strong>glob模块：</strong></p>
<p>在python中，glob模块是用来查找匹配的文件的    在查找的条件中，需要用到Unix shell中的匹配规则：     </p>
<p>  *    :   匹配所所有       </p>
<p>  ?    :   匹配一个字符       </p>
<p>*.*  :   匹配如：[hello.txt,cat.xls,xxx234s.doc]     </p>
<p>  ?.*  :   匹配如：[1.txt,h.py]     </p>
<p>  ?.gif:   匹配如：[x.gif,2.gif]   </p>
<p> 可以参考：fnmatch    如果没有匹配的，glob.glob(path)将返回一个空的list:[]</p>
<p>也就说：glob是用来寻找文件的。某种命名规则的文件的。</p>
<pre><code><span class="keyword">import</span> glob

 <span class="function"><span class="keyword">def</span> <span class="title">get_all</span><span class="params">()</span>:</span>
     <span class="string">'''获取目录[c:\\tmp]下面所有的文件'''</span>
     <span class="keyword">return</span> glob.glob(<span class="string">'c:\\tmp\\*.*'</span>)

 <span class="function"><span class="keyword">def</span> <span class="title">get_my_file</span><span class="params">()</span>:</span>
     <span class="string">'''获取目录[c:\\tmp]下面文件名为4个字符的文件'''</span>
     <span class="keyword">return</span> glob.glob(<span class="string">'c:\\tmp\\????.txt'</span>)

 <span class="function"><span class="keyword">def</span> <span class="title">get_batch_file</span><span class="params">()</span>:</span>
     <span class="string">'''获取目录[c:\\tmp]下面扩展名为\'.txt\'的文件'''</span>
     <span class="keyword">return</span> glob.glob(<span class="string">'c:\\tmp\\*.txt'</span>)

 <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>
     print(<span class="string">'获取目录[c:\\tmp]下面所有的文件：'</span>)
     tem_files = get_all()
     print(tem_files)
     print(<span class="string">'获取目录[c:\\tmp]下面文件名为4个字符的文件：'</span>)
     tem_files = get_my_file()
     print(tem_files)
     print(<span class="string">'获取目录[c:\\tmp]下面扩展名为\'.txt\'的文件：'</span>)
     tem_files = get_batch_file()
     print(tem_files)

 <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
     main()
</code></pre><p>　　</p>
<p><strong>python文件操作：</strong><br>有关文件夹与文件的查找，删除等功能 在 os 模块中实现。使用时需先导入这个模块，</p>
<p>导入的方法是:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> os</span>
</code></pre><p>1、将一个路径名分解为目录名和文件名两部分</p>
<pre><code>fpath , fname = os.path.<span class="built_in">split</span>( <span class="string">"你要分解的路径"</span>)
</code></pre><p>例如：</p>
<pre><code><span class="keyword">a</span>, <span class="keyword">b</span> = os.path.<span class="built_in">split</span>( <span class="string">"c:\\123\\456\\test.txt"</span> )

<span class="keyword">print</span> <span class="keyword">a</span>

<span class="keyword">print</span> <span class="keyword">b</span>
</code></pre><p>显示：</p>
<pre><code><span class="built_in">c</span>:\<span class="number">123</span>\<span class="number">456</span>

test.txt
</code></pre><p>2、 分解文件名的扩展名</p>
<pre><code>fpathandname , fext = <span class="built_in">os</span>.path.splitext( <span class="string">"你要分解的路径"</span>)
</code></pre><p>例如：</p>
<pre><code>a, b = os.path.splitext( <span class="string">"c:\\123\\456\\test.txt"</span> )

print a

print b
</code></pre><p>显示：</p>
<pre><code><span class="built_in">c</span>:\<span class="number">123</span>\<span class="number">456</span>\test

.txt
</code></pre><p>文件操作还有很多有用的函数，可以通过查找手册来看。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>问题：将某文件下的所有jpg的图片更换为png的图片</p>
<p>简单的实现:</p>
<pre><code><span class="comment"># -*- coding:utf-8 -*-</span>
<span class="keyword">from</s]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python类似微信未读信息图片脚本]]></title>
    <link href="http://silencewt.github.io/2015/02/01/python%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E6%9C%AA%E8%AF%BB%E4%BF%A1%E6%81%AF%E5%9B%BE%E7%89%87%E8%84%9A%E6%9C%AC/"/>
    <id>http://silencewt.github.io/2015/02/01/python类似微信未读信息图片脚本/</id>
    <published>2015-02-01T13:32:18.000Z</published>
    <updated>2015-02-01T14:04:24.000Z</updated>
    <content type="html"><![CDATA[<p>其实就是实现一个效果，给一张图片，然后再右上角给出未读的信息数目，就像我们打开微信的时候，总是看到红点就忍不住想要点击去查看一样。</p>
<p>类似这种效果：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/new_weixin.jpg" alt="weixn"></p>
<p>可以知道，图片是给定的，那么只要随机生成一个数字，然后再在图片的右上角显示出来就好了，这里可以使用PIL，这样就比较方便的实现了，</p>
<p>代码：</p>
<pre><code><span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageDraw, ImageFont

<span class="keyword">import</span> random

origin_image = <span class="string">"./image/test.jpg"</span>
new_image = <span class="string">"./image/new_test.jpg"</span>
color = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)

<span class="function"><span class="keyword">def</span>  <span class="title">numRandom</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> random.randint(<span class="number">0</span>, <span class="number">100</span>)

<span class="function"><span class="keyword">def</span> <span class="title">draw_text_for_image</span><span class="params">(text, origin_image,fill_color)</span>:</span>
<span class="keyword">try</span>:
    image = Image.open(origin_image)
    size = image.size
    x = size[<span class="number">0</span>] - <span class="number">60</span>
    font = ImageFont.truetype(<span class="string">"arial.ttf"</span>, <span class="number">36</span>)
    draw = ImageDraw.Draw(image)
    draw.text((x, <span class="number">15</span>), text, font=font, fill=fill_color)
    image.save(new_image,<span class="string">'jpeg'</span>);
<span class="keyword">except</span> :
    <span class="keyword">print</span> <span class="string">"Unable to load image"</span>

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    text = str(numRandom())
    draw_text_for_image(text,origin_image,color)    
</code></pre><p>先得到需要的图片和保存的图片路径，利用随机数产生一个随机数字，ImageDraw实现在图片是添加文字。</p>
<p>image.size获得图片的长宽，返回一个元祖。</p>
<p>这里说说最后一个__name__ ==\ “__main__“:</p>
<p>　　当打开一个.py文件时,经常会在代码的最下面看到if __name<strong> == “__main</strong>“:</p>
<p>　　模块是对象,并且所有的模块都有一个内置属性name。一个模块的 _<em>name<strong> 的值取决于您如何应用模块。如果 import 一个模块，那么模块\</strong>name<strong> 的值通常为模块文件名，不带路径或者文件扩展名。但是您也可以像一个标准的程序样直接运行模块，在这 种情况下,\</strong>name<strong> 的值将是一个特别缺省”\</strong>main_</em>“。</p>
<p>在cmd 中直接运行.py文件，则__name__的值是’__main__‘；</p>
<p>而在import 一个.py文件后，__name__的值就不是’__main__‘了；</p>
<p>从而用if __name__ == ‘__main__‘来判断是否是在直接运行该.py文件</p>
<p>如:</p>
<pre><code><span class="comment">#Test.py</span>

<span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span>

<span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self)</span>:</span><span class="keyword">pass</span>

<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span><span class="keyword">print</span> <span class="string">'Hello, World!'</span>

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:

Test().f()

<span class="comment">#End</span>
</code></pre><p>你在cmd中输入：</p>
<p>C:&gt;python Test.py</p>
<p>Hello, World!</p>
<p>说明：”_<em>name<strong> == ‘\</strong>main_</em>‘“是成立的</p>
<p>你再在cmd中输入:</p>
<p>C:&gt;python</p>
<p>>&gt;&gt;import Test</p>
<p>>&gt;&gt;Test._<em>name<strong>                #Test模块的\</strong>name_</em></p>
<p>‘Test’</p>
<p>>&gt;&gt;_<em>name<strong>                       #当前程序的\</strong>name_</em></p>
<p>‘_<em>main_</em>‘</p>
<p>无论怎样，Test.py中的”_<em>name<strong> == ‘\</strong>main_</em>‘“都不会成立的!</p>
<p>所以，下一行代码永远不会运行到</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实就是实现一个效果，给一张图片，然后再右上角给出未读的信息数目，就像我们打开微信的时候，总是看到红点就忍不住想要点击去查看一样。</p>
<p>类似这种效果：<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/new_w]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python生成验证码脚本]]></title>
    <link href="http://silencewt.github.io/2015/02/01/python%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%E8%84%9A%E6%9C%AC/"/>
    <id>http://silencewt.github.io/2015/02/01/python生成验证码脚本/</id>
    <published>2015-02-01T13:14:07.000Z</published>
    <updated>2015-02-01T13:15:40.000Z</updated>
    <content type="html"><![CDATA[<p>最近每天都用python写一个小的脚本，练习使用python语法。</p>
<p>验证码的生成：</p>
<p>这里使用了python的图像处理库PIL，安装PIL的过程中出了一个小麻烦，就使用Pillow-win32的一个文件，具体的我也忘了，可以百度下。</p>
<p>直接看代码：</p>
<pre><code><span class="comment"># -*- coding:utf-8 -*-</span>

<span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageFont,ImageDraw,ImageFilter
<span class="keyword">import</span> random
<span class="comment">#返回随机字母</span>
<span class="function"><span class="keyword">def</span> <span class="title">charRandom</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> chr((random.randint(<span class="number">65</span>,<span class="number">90</span>)))
<span class="comment">#返回随机数字</span>
<span class="function"><span class="keyword">def</span> <span class="title">numRandom</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> random.randint(<span class="number">0</span>,<span class="number">9</span>)
<span class="comment">#随机颜色</span>
<span class="function"><span class="keyword">def</span> <span class="title">colorRandom1</span><span class="params">()</span>:</span>
<span class="keyword">return</span>       (random.randint(<span class="number">64</span>,<span class="number">255</span>),random.randint(<span class="number">64</span>,<span class="number">255</span>),random.randint(<span class="number">64</span>,<span class="number">255</span>))
<span class="comment">#随机长生颜色2</span>
<span class="function"><span class="keyword">def</span> <span class="title">colorRandom2</span><span class="params">()</span>:</span>
<span class="keyword">return</span> (random.randint(<span class="number">32</span>,<span class="number">127</span>),random.randint(<span class="number">32</span>,<span class="number">127</span>),random.randint(<span class="number">32</span>,<span class="number">127</span>))

width = <span class="number">60</span> * <span class="number">4</span>
height = <span class="number">60</span>
image = Image.new(<span class="string">'RGB'</span>, (width,height), (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));
<span class="comment">#创建font对象</span>
font = ImageFont.truetype(<span class="string">'Arial.ttf'</span>,<span class="number">36</span>);

<span class="comment">#创建draw对象</span>
draw = ImageDraw.Draw(image)
<span class="comment">#填充每一个颜色</span>
<span class="keyword">for</span> x <span class="keyword">in</span> range(width):
    <span class="keyword">for</span> y <span class="keyword">in</span> range(height):
        draw.point((x,y), fill=colorRandom1())

<span class="comment">#输出文字</span>
<span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">4</span>):
    draw.text((<span class="number">60</span>*t+<span class="number">10</span>,<span class="number">10</span>), charRandom(),font=font, fill=colorRandom2())

<span class="comment">#模糊</span>
image = image.filter(ImageFilter.BLUR)
image.save(<span class="string">'./image/code.jpg'</span>,<span class="string">'jpeg'</span>)
</code></pre><p>PIL对于图像的处理还是可以的：</p>
<p>这里是官方的文档：<a href="http://effbot.org/imagingbook/" target="_blank" rel="external">http://effbot.org/imagingbook/</a> 讲的很详细</p>
<p>Image 类是 PIL 库中一个非常重要的类，通过这个类来创建实例可以有直接载入图像文件，读取处理过的图像和通过抓取的方法得到的图像这三种方法。可以对图形进行简单的操作例如旋转、裁剪、缩小放大，滤波等等。</p>
<p>ImageFont模块是字体模块，可以对字体进行设置</p>
<p>上面程序的思想：</p>
<pre><code><span class="number">1</span>、定义了几个随机获取颜色和数字字母的函数，获得验证码的文字

<span class="number">2</span>、Image.<span class="keyword">new</span>生成一个黑色的画布，也就是图片，大小<span class="number">60</span>*<span class="number">240</span>

<span class="number">3</span>、ImageFont定义图片上将使用的字体

<span class="number">4</span>、对该图片生成一个draw对象，通过该draw对象，改变图像的像素，使用随见长生的颜色

<span class="number">5</span>、在图片上产生文字，文字也使用随机的颜色

<span class="number">6</span>、对图片进行模糊化处理

<span class="number">7</span>、将图片保存
</code></pre><p>最后就可以在image文件下得到code.jpg 的图片<br><img src="http://7te8s4.com1.z0.glb.clouddn.com/code.jpg" alt="code"></p>
<p><strong>扩展：</strong></p>
<p>可以的话，还可以通过draw对象在图片上随机产生几根线条，将验证码变得更难看懂，可以将文字倾斜等等。</p>
<pre><code>image.rotate(random.randint(<span class="number">0</span>,<span class="number">30</span>),expand=<span class="number">0</span>)

<span class="function"><span class="keyword">def</span> <span class="title">randomLine</span><span class="params">(self, num)</span>:</span>
　　draw = ImageDraw.Draw(self.image)
　　<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,num):
　　draw.line([self.randomPoint(),self.randomPoint()], self.randomRGB())
　　<span class="keyword">del</span> draw
</code></pre><p>　　</p>
<p>　　关于验证码还有很多可以值得看的，之前在用opencv的时候，就想着做一个验证码识别的程序，从而可以实现自动登入系统，不需要每次都手工输入验证码，这好像也是图灵研究的一部分，也是人和机器的区分标志，<strong>全自动区分计算机和人类的图灵测试</strong>（英语：Completely Automated Public Turing test to tell Computers and Humans Apart，简称<strong>CAPTCHA</strong>），俗称验证码。具体的可以百度了解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近每天都用python写一个小的脚本，练习使用python语法。</p>
<p>验证码的生成：</p>
<p>这里使用了python的图像处理库PIL，安装PIL的过程中出了一个小麻烦，就使用Pillow-win32的一个文件，具体的我也忘了，可以百度下。</p>
<p>]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python学习笔记（三）]]></title>
    <link href="http://silencewt.github.io/2015/01/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://silencewt.github.io/2015/01/17/python学习笔记（三）/</id>
    <published>2015-01-17T12:27:50.000Z</published>
    <updated>2015-01-17T12:28:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="函数式编程："><strong>函数式编程</strong>：</h4>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python内建了map()和reduce()函数。</p>
<p>map()：函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。举例：有一个函数f(x)=x^2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<p>>&gt;&gt;map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])<br>[1, 4, 9, 16, 25, 36, 49, 64, 81]</p>
<p>reduce()：把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>>&gt;&gt; def fn(x, y): …<br>return x * 10 + y …<br>>&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])<br>13579</p>
<p>filter()：和map()类似，也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<p>在一个list中，删掉偶数，只保留奇数，可以这么写：<br>def is_odd(n):<br>    return n % 2 == 1<br> filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]) # 结果: [1, 5, 9, 15]</p>
<p>sorted()：该函数可以对list进行排序，sorted([36, 5, 12, 9, 21])。它也是一个高阶函数，可以接收一个比较函数来实现自定义的排序。比如，如果要倒序排序，就可以自定义一个reversed_cmp函数：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">reversed_cmp</span><span class="params">(x, y)</span>:</span>    
<span class="keyword">if</span> x &gt; y:       
    <span class="keyword">return</span> -<span class="number">1</span>   
<span class="keyword">if</span> x &lt; y:       
     <span class="keyword">return</span> <span class="number">1</span>    
<span class="keyword">return</span> <span class="number">0</span>
</code></pre><p>传入自定义的比较函数reversed_cmp，就可以实现倒序排序：</p>
<p>>&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp) [36, 21, 12, 9, 5]</p>
<hr>
<h4 id="面向对象编程"><strong>面向对象编程</strong></h4>
<p><strong>类</strong>：</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span>               
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span>        
        self.name = name         
        self.score = score
</code></pre><p> 　　Student类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 <strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创#建的实例本身。有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</p>
<p>　　类中定义的函数和其他函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，仍然可以用默认参数、可变参数和关键字参数。</p>
<p>外部代码还是可以自由地修改一个实例的name、score属性</p>
<p>＼&gt;&gt;&gt; bart = Student(‘Bart Simpson’, 98)<br>＼&gt;&gt;&gt; bart.score<br> 98<br>＼&gt;&gt;&gt; bart.score = 59</p>
<p>　　如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<strong>。self.</strong>name = name，self.__score = score</p>
<p>　　在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<p>　　在Python中，变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，不能用<strong>name</strong>、<strong>score</strong>这样的变量名。</p>
<p><strong>多态</strong>：</p>
<p>　　当我们定义一个class的时候，就相当于定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p>
<p>判断一个变量是否是某个类型可以用isinstance()判断：</p>
<p>＼&gt;&gt;&gt; isinstance(a, list)</p>
<p>true 或 false</p>
<p>在调用类实例方法的时候，变量视作父类类型，这样，所有子类类型都可以正常被接收。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="函数式编程："><strong>函数式编程</strong>：</h4>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python内建了map()和reduce()函数。</p>
<p>map()：函数]]>
    </summary>
    
      <category term="python" scheme="http://silencewt.github.io/tags/python/"/>
    
      <category term="python" scheme="http://silencewt.github.io/categories/python/"/>
    
  </entry>
  
</feed>
